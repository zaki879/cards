/*! For license information please see bundle.js.LICENSE.txt */
(() => {
  "use strict";
  function t() {
    return (
      (t = Object.assign
        ? Object.assign.bind()
        : function (t) {
            for (var e = 1; e < arguments.length; e++) {
              var n = arguments[e];
              for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
            }
            return t;
          }),
      t.apply(this, arguments)
    );
  }
  class e {
    constructor() {
      this._events = {};
    }
    on(t, e, n) {
      void 0 === n && (n = {}),
        this._events[t] || (this._events[t] = []),
        this._events[t].push({ callback: e, options: n });
    }
    off(t, e) {
      this._events[t] = e
        ? this._events[t].filter((t) => t.callback !== e)
        : [];
    }
    trigger(t) {
      this._events[t] &&
        this._events[t].forEach((e) => {
          e.callback.call(this, ...[].slice.call(arguments, 1)),
            e.options.once && this.off(t, e.callback);
        });
    }
  }
  class n extends e {
    constructor(t, e, n) {
      super(),
        (this.app = t),
        (this.el = e),
        (this.options = n),
        (this._namespace = null),
        (this._executors = {});
    }
    onInit() {
      return Promise.resolve();
    }
    onRefresh() {
      return Promise.resolve();
    }
    onEnter() {
      return Promise.resolve();
    }
    onComplete() {
      return Promise.resolve();
    }
    onLeave() {
      return Promise.resolve();
    }
    onDestroy() {
      return Promise.resolve();
    }
    onLoaded() {
      return Promise.resolve();
    }
  }
  function i(t) {
    if (void 0 === t)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return t;
  }
  function r(t, e) {
    (t.prototype = Object.create(e.prototype)),
      (t.prototype.constructor = t),
      (t.__proto__ = e);
  }
  var s,
    a,
    o,
    l,
    c,
    u,
    h,
    d,
    p,
    f,
    m,
    g,
    v,
    _,
    x,
    y,
    S,
    M = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: { lineHeight: "" },
    },
    E = { duration: 0.5, overwrite: !1, delay: 0 },
    T = 1e8,
    b = 1e-8,
    D = 2 * Math.PI,
    w = D / 4,
    C = 0,
    A = Math.sqrt,
    R = Math.cos,
    P = Math.sin,
    L = function (t) {
      return "string" == typeof t;
    },
    I = function (t) {
      return "function" == typeof t;
    },
    U = function (t) {
      return "number" == typeof t;
    },
    N = function (t) {
      return void 0 === t;
    },
    F = function (t) {
      return "object" == typeof t;
    },
    O = function (t) {
      return !1 !== t;
    },
    B = function () {
      return "undefined" != typeof window;
    },
    z = function (t) {
      return I(t) || L(t);
    },
    k =
      ("function" == typeof ArrayBuffer && ArrayBuffer.isView) ||
      function () {},
    V = Array.isArray,
    H = /(?:-?\.?\d|\.)+/gi,
    G = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    W = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    X = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    q = /[+-]=-?[.\d]+/,
    j = /[^,'"\[\]\s]+/gi,
    Y = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    K = {},
    Z = {},
    J = function (t) {
      return (Z = Dt(t, K)) && wn;
    },
    $ = function (t, e) {
      return console.warn(
        "Invalid property",
        t,
        "set to",
        e,
        "Missing plugin? gsap.registerPlugin()"
      );
    },
    Q = function (t, e) {
      return !e && console.warn(t);
    },
    tt = function (t, e) {
      return (t && (K[t] = e) && Z && (Z[t] = e)) || K;
    },
    et = function () {
      return 0;
    },
    nt = { suppressEvents: !0, isStart: !0, kill: !1 },
    it = { suppressEvents: !0, kill: !1 },
    rt = { suppressEvents: !0 },
    st = {},
    at = [],
    ot = {},
    lt = {},
    ct = {},
    ut = 30,
    ht = [],
    dt = "",
    pt = function (t) {
      var e,
        n,
        i = t[0];
      if ((F(i) || I(i) || (t = [t]), !(e = (i._gsap || {}).harness))) {
        for (n = ht.length; n-- && !ht[n].targetTest(i); );
        e = ht[n];
      }
      for (n = t.length; n--; )
        (t[n] && (t[n]._gsap || (t[n]._gsap = new ke(t[n], e)))) ||
          t.splice(n, 1);
      return t;
    },
    ft = function (t) {
      return t._gsap || pt(ie(t))[0]._gsap;
    },
    mt = function (t, e, n) {
      return (n = t[e]) && I(n)
        ? t[e]()
        : (N(n) && t.getAttribute && t.getAttribute(e)) || n;
    },
    gt = function (t, e) {
      return (t = t.split(",")).forEach(e) || t;
    },
    vt = function (t) {
      return Math.round(1e5 * t) / 1e5 || 0;
    },
    _t = function (t) {
      return Math.round(1e7 * t) / 1e7 || 0;
    },
    xt = function (t, e) {
      var n = e.charAt(0),
        i = parseFloat(e.substr(2));
      return (
        (t = parseFloat(t)),
        "+" === n ? t + i : "-" === n ? t - i : "*" === n ? t * i : t / i
      );
    },
    yt = function (t, e) {
      for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; );
      return i < n;
    },
    St = function () {
      var t,
        e,
        n = at.length,
        i = at.slice(0);
      for (ot = {}, at.length = 0, t = 0; t < n; t++)
        (e = i[t]) &&
          e._lazy &&
          (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
    },
    Mt = function (t, e, n, i) {
      at.length && !a && St(),
        t.render(e, n, i || (a && e < 0 && (t._initted || t._startAt))),
        at.length && !a && St();
    },
    Et = function (t) {
      var e = parseFloat(t);
      return (e || 0 === e) && (t + "").match(j).length < 2
        ? e
        : L(t)
        ? t.trim()
        : t;
    },
    Tt = function (t) {
      return t;
    },
    bt = function (t, e) {
      for (var n in e) n in t || (t[n] = e[n]);
      return t;
    },
    Dt = function (t, e) {
      for (var n in e) t[n] = e[n];
      return t;
    },
    wt = function t(e, n) {
      for (var i in n)
        "__proto__" !== i &&
          "constructor" !== i &&
          "prototype" !== i &&
          (e[i] = F(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
      return e;
    },
    Ct = function (t, e) {
      var n,
        i = {};
      for (n in t) n in e || (i[n] = t[n]);
      return i;
    },
    At = function (t) {
      var e,
        n = t.parent || l,
        i = t.keyframes
          ? ((e = V(t.keyframes)),
            function (t, n) {
              for (var i in n)
                i in t ||
                  ("duration" === i && e) ||
                  "ease" === i ||
                  (t[i] = n[i]);
            })
          : bt;
      if (O(t.inherit))
        for (; n; ) i(t, n.vars.defaults), (n = n.parent || n._dp);
      return t;
    },
    Rt = function (t, e, n, i, r) {
      void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
      var s,
        a = t[i];
      if (r) for (s = e[r]; a && a[r] > s; ) a = a._prev;
      return (
        a
          ? ((e._next = a._next), (a._next = e))
          : ((e._next = t[n]), (t[n] = e)),
        e._next ? (e._next._prev = e) : (t[i] = e),
        (e._prev = a),
        (e.parent = e._dp = t),
        e
      );
    },
    Pt = function (t, e, n, i) {
      void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
      var r = e._prev,
        s = e._next;
      r ? (r._next = s) : t[n] === e && (t[n] = s),
        s ? (s._prev = r) : t[i] === e && (t[i] = r),
        (e._next = e._prev = e.parent = null);
    },
    Lt = function (t, e) {
      t.parent &&
        (!e || t.parent.autoRemoveChildren) &&
        t.parent.remove &&
        t.parent.remove(t),
        (t._act = 0);
    },
    It = function (t, e) {
      if (t && (!e || e._end > t._dur || e._start < 0))
        for (var n = t; n; ) (n._dirty = 1), (n = n.parent);
      return t;
    },
    Ut = function (t, e, n, i) {
      return (
        t._startAt &&
        (a
          ? t._startAt.revert(it)
          : (t.vars.immediateRender && !t.vars.autoRevert) ||
            t._startAt.render(e, !0, i))
      );
    },
    Nt = function t(e) {
      return !e || (e._ts && t(e.parent));
    },
    Ft = function (t) {
      return t._repeat ? Ot(t._tTime, (t = t.duration() + t._rDelay)) * t : 0;
    },
    Ot = function (t, e) {
      var n = Math.floor((t /= e));
      return t && n === t ? n - 1 : n;
    },
    Bt = function (t, e) {
      return (
        (t - e._start) * e._ts +
        (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
      );
    },
    zt = function (t) {
      return (t._end = _t(
        t._start + (t._tDur / Math.abs(t._ts || t._rts || b) || 0)
      ));
    },
    kt = function (t, e) {
      var n = t._dp;
      return (
        n &&
          n.smoothChildTiming &&
          t._ts &&
          ((t._start = _t(
            n._time -
              (t._ts > 0
                ? e / t._ts
                : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)
          )),
          zt(t),
          n._dirty || It(n, t)),
        t
      );
    },
    Vt = function (t, e) {
      var n;
      if (
        ((e._time ||
          (!e._dur && e._initted) ||
          (e._start < t._time && (e._dur || !e.add))) &&
          ((n = Bt(t.rawTime(), e)),
          (!e._dur || Qt(0, e.totalDuration(), n) - e._tTime > b) &&
            e.render(n, !0)),
        It(t, e)._dp && t._initted && t._time >= t._dur && t._ts)
      ) {
        if (t._dur < t.duration())
          for (n = t; n._dp; )
            n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
        t._zTime = -1e-8;
      }
    },
    Ht = function (t, e, n, i) {
      return (
        e.parent && Lt(e),
        (e._start = _t(
          (U(n) ? n : n || t !== l ? Zt(t, n, e) : t._time) + e._delay
        )),
        (e._end = _t(
          e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)
        )),
        Rt(t, e, "_first", "_last", t._sort ? "_start" : 0),
        qt(e) || (t._recent = e),
        i || Vt(t, e),
        t._ts < 0 && kt(t, t._tTime),
        t
      );
    },
    Gt = function (t, e) {
      
    },
    Wt = function (t, e, n, i, r) {
      return (
        Ye(t, e, r),
        t._initted
          ? !n &&
            t._pt &&
            !a &&
            ((t._dur && !1 !== t.vars.lazy) || (!t._dur && t.vars.lazy)) &&
            p !== we.frame
            ? (at.push(t), (t._lazy = [r, i]), 1)
            : void 0
          : 1
      );
    },
    Xt = function t(e) {
      var n = e.parent;
      return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n));
    },
    qt = function (t) {
      var e = t.data;
      return "isFromStart" === e || "isStart" === e;
    },
    jt = function (t, e, n, i) {
      var r = t._repeat,
        s = _t(e) || 0,
        a = t._tTime / t._tDur;
      return (
        a && !i && (t._time *= s / t._dur),
        (t._dur = s),
        (t._tDur = r ? (r < 0 ? 1e10 : _t(s * (r + 1) + t._rDelay * r)) : s),
        a > 0 && !i && kt(t, (t._tTime = t._tDur * a)),
        t.parent && zt(t),
        n || It(t.parent, t),
        t
      );
    },
    Yt = function (t) {
      return t instanceof He ? It(t) : jt(t, t._dur);
    },
    Kt = { _start: 0, endTime: et, totalDuration: et },
    Zt = function t(e, n, i) {
      var r,
        s,
        a,
        o = e.labels,
        l = e._recent || Kt,
        c = e.duration() >= T ? l.endTime(!1) : e._dur;
      return L(n) && (isNaN(n) || n in o)
        ? ((s = n.charAt(0)),
          (a = "%" === n.substr(-1)),
          (r = n.indexOf("=")),
          "<" === s || ">" === s
            ? (r >= 0 && (n = n.replace(/=/, "")),
              ("<" === s ? l._start : l.endTime(l._repeat >= 0)) +
                (parseFloat(n.substr(1)) || 0) *
                  (a ? (r < 0 ? l : i).totalDuration() / 100 : 1))
            : r < 0
            ? (n in o || (o[n] = c), o[n])
            : ((s = parseFloat(n.charAt(r - 1) + n.substr(r + 1))),
              a && i && (s = (s / 100) * (V(i) ? i[0] : i).totalDuration()),
              r > 1 ? t(e, n.substr(0, r - 1), i) + s : c + s))
        : null == n
        ? c
        : +n;
    },
    Jt = function (t, e, n) {
      var i,
        r,
        s = U(e[1]),
        a = (s ? 2 : 1) + (t < 2 ? 0 : 1),
        o = e[a];
      if ((s && (o.duration = e[1]), (o.parent = n), t)) {
        for (i = o, r = n; r && !("immediateRender" in i); )
          (i = r.vars.defaults || {}), (r = O(r.vars.inherit) && r.parent);
        (o.immediateRender = O(i.immediateRender)),
          t < 2 ? (o.runBackwards = 1) : (o.startAt = e[a - 1]);
      }
      return new Qe(e[0], o, e[a + 1]);
    },
    $t = function (t, e) {
      return t || 0 === t ? e(t) : e;
    },
    Qt = function (t, e, n) {
      return n < t ? t : n > e ? e : n;
    },
    te = function (t, e) {
      return L(t) && (e = Y.exec(t)) ? e[1] : "";
    },
    ee = [].slice,
    ne = function (t, e) {
      return (
        t &&
        F(t) &&
        "length" in t &&
        ((!e && !t.length) || (t.length - 1 in t && F(t[0]))) &&
        !t.nodeType &&
        t !== c
      );
    },
    ie = function (t, e, n) {
      return o && !e && o.selector
        ? o.selector(t)
        : !L(t) || n || (!u && Ce())
        ? V(t)
          ? (function (t, e, n) {
              return (
                void 0 === n && (n = []),
                t.forEach(function (t) {
                  var i;
                  return (L(t) && !e) || ne(t, 1)
                    ? (i = n).push.apply(i, ie(t))
                    : n.push(t);
                }) || n
              );
            })(t, n)
          : ne(t)
          ? ee.call(t, 0)
          : t
          ? [t]
          : []
        : ee.call((e || h).querySelectorAll(t), 0);
    },
    re = function (t) {
      return (
        (t = ie(t)[0] || Q("Invalid scope") || {}),
        function (e) {
          var n = t.current || t.nativeElement || t;
          return ie(
            e,
            n.querySelectorAll
              ? n
              : n === t
              ? Q("Invalid scope") || h.createElement("div")
              : t
          );
        }
      );
    },
    se = function (t) {
      return t.sort(function () {
        return 0.5 - Math.random();
      });
    },
    ae = function (t) {
      if (I(t)) return t;
      var e = F(t) ? t : { each: t },
        n = Ne(e.ease),
        i = e.from || 0,
        r = parseFloat(e.base) || 0,
        s = {},
        a = i > 0 && i < 1,
        o = isNaN(i) || a,
        l = e.axis,
        c = i,
        u = i;
      return (
        L(i)
          ? (c = u = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
          : !a && o && ((c = i[0]), (u = i[1])),
        function (t, a, h) {
          var d,
            p,
            f,
            m,
            g,
            v,
            _,
            x,
            y,
            S = (h || e).length,
            M = s[S];
          if (!M) {
            if (!(y = "auto" === e.grid ? 0 : (e.grid || [1, T])[1])) {
              for (
                _ = -T;
                _ < (_ = h[y++].getBoundingClientRect().left) && y < S;

              );
              y < S && y--;
            }
            for (
              M = s[S] = [],
                d = o ? Math.min(y, S) * c - 0.5 : i % y,
                p = y === T ? 0 : o ? (S * u) / y - 0.5 : (i / y) | 0,
                _ = 0,
                x = T,
                v = 0;
              v < S;
              v++
            )
              (f = (v % y) - d),
                (m = p - ((v / y) | 0)),
                (M[v] = g = l ? Math.abs("y" === l ? m : f) : A(f * f + m * m)),
                g > _ && (_ = g),
                g < x && (x = g);
            "random" === i && se(M),
              (M.max = _ - x),
              (M.min = x),
              (M.v = S =
                (parseFloat(e.amount) ||
                  parseFloat(e.each) *
                    (y > S
                      ? S - 1
                      : l
                      ? "y" === l
                        ? S / y
                        : y
                      : Math.max(y, S / y)) ||
                  0) * ("edges" === i ? -1 : 1)),
              (M.b = S < 0 ? r - S : r),
              (M.u = te(e.amount || e.each) || 0),
              (n = n && S < 0 ? Ie(n) : n);
          }
          return (
            (S = (M[t] - M.min) / M.max || 0),
            _t(M.b + (n ? n(S) : S) * M.v) + M.u
          );
        }
      );
    },
    oe = function (t) {
      var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
      return function (n) {
        var i = _t(Math.round(parseFloat(n) / t) * t * e);
        return (i - (i % 1)) / e + (U(n) ? 0 : te(n));
      };
    },
    le = function (t, e) {
      var n,
        i,
        r = V(t);
      return (
        !r &&
          F(t) &&
          ((n = r = t.radius || T),
          t.values
            ? ((t = ie(t.values)), (i = !U(t[0])) && (n *= n))
            : (t = oe(t.increment))),
        $t(
          e,
          r
            ? I(t)
              ? function (e) {
                  return (i = t(e)), Math.abs(i - e) <= n ? i : e;
                }
              : function (e) {
                  for (
                    var r,
                      s,
                      a = parseFloat(i ? e.x : e),
                      o = parseFloat(i ? e.y : 0),
                      l = T,
                      c = 0,
                      u = t.length;
                    u--;

                  )
                    (r = i
                      ? (r = t[u].x - a) * r + (s = t[u].y - o) * s
                      : Math.abs(t[u] - a)) < l && ((l = r), (c = u));
                  return (
                    (c = !n || l <= n ? t[c] : e),
                    i || c === e || U(e) ? c : c + te(e)
                  );
                }
            : oe(t)
        )
      );
    },
    ce = function (t, e, n, i) {
      return $t(V(t) ? !e : !0 === n ? !!(n = 0) : !i, function () {
        return V(t)
          ? t[~~(Math.random() * t.length)]
          : (n = n || 1e-5) &&
              (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
              Math.floor(
                Math.round(
                  (t - n / 2 + Math.random() * (e - t + 0.99 * n)) / n
                ) *
                  n *
                  i
              ) / i;
      });
    },
    ue = function (t, e, n) {
      return $t(n, function (n) {
        return t[~~e(n)];
      });
    },
    he = function (t) {
      for (var e, n, i, r, s = 0, a = ""; ~(e = t.indexOf("random(", s)); )
        (i = t.indexOf(")", e)),
          (r = "[" === t.charAt(e + 7)),
          (n = t.substr(e + 7, i - e - 7).match(r ? j : H)),
          (a +=
            t.substr(s, e - s) +
            ce(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)),
          (s = i + 1);
      return a + t.substr(s, t.length - s);
    },
    de = function (t, e, n, i, r) {
      var s = e - t,
        a = i - n;
      return $t(r, function (e) {
        return n + (((e - t) / s) * a || 0);
      });
    },
    pe = function (t, e, n) {
      var i,
        r,
        s,
        a = t.labels,
        o = T;
      for (i in a)
        (r = a[i] - e) < 0 == !!n &&
          r &&
          o > (r = Math.abs(r)) &&
          ((s = i), (o = r));
      return s;
    },
    fe = function (t, e, n) {
      var i,
        r,
        s,
        a = t.vars,
        l = a[e],
        c = o,
        u = t._ctx;
      if (l)
        return (
          (i = a[e + "Params"]),
          (r = a.callbackScope || t),
          n && at.length && St(),
          u && (o = u),
          (s = i ? l.apply(r, i) : l.call(r)),
          (o = c),
          s
        );
    },
    me = function (t) {
     
    },
    ge = [],
    ve = function (t) {
      if (t)
        if (((t = (!t.name && t.default) || t), B() || t.headless)) {
          var e = t.name,
            n = I(t),
            i =
              e && !n && t.init
                ? function () {
                    this._props = [];
                  }
                : t,
            r = {
              init: et,
              render: cn,
              add: qe,
              kill: hn,
              modifier: un,
              rawVars: 0,
            },
            s = {
              targetTest: 0,
              get: 0,
              getSetter: sn,
              aliases: {},
              register: 0,
            };
          if ((Ce(), t !== i)) {
            if (lt[e]) return;
            bt(i, bt(Ct(t, r), s)),
              Dt(i.prototype, Dt(r, Ct(t, s))),
              (lt[(i.prop = e)] = i),
              t.targetTest && (ht.push(i), (st[e] = 1)),
              (e =
                ("css" === e
                  ? "CSS"
                  : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin");
          }
          tt(e, i), t.register && t.register(wn, i, fn);
        } else ge.push(t);
    },
    _e = 255,
    xe = {
      aqua: [0, _e, _e],
      lime: [0, _e, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, _e],
      navy: [0, 0, 128],
      white: [_e, _e, _e],
      olive: [128, 128, 0],
      yellow: [_e, _e, 0],
      orange: [_e, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [_e, 0, 0],
      pink: [_e, 192, 203],
      cyan: [0, _e, _e],
      transparent: [_e, _e, _e, 0],
    },
    ye = function (t, e, n) {
      return (
        ((6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1
          ? e + (n - e) * t * 6
          : t < 0.5
          ? n
          : 3 * t < 2
          ? e + (n - e) * (2 / 3 - t) * 6
          : e) *
          _e +
          0.5) |
        0
      );
    },
    Se = function (t, e, n) {
      var i,
        r,
        s,
        a,
        o,
        l,
        c,
        u,
        h,
        d,
        p = t ? (U(t) ? [t >> 16, (t >> 8) & _e, t & _e] : 0) : xe.black;
      if (!p) {
        if (("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), xe[t]))
          p = xe[t];
        else if ("#" === t.charAt(0)) {
          if (
            (t.length < 6 &&
              ((i = t.charAt(1)),
              (r = t.charAt(2)),
              (s = t.charAt(3)),
              (t =
                "#" +
                i +
                i +
                r +
                r +
                s +
                s +
                (5 === t.length ? t.charAt(4) + t.charAt(4) : ""))),
            9 === t.length)
          )
            return [
              (p = parseInt(t.substr(1, 6), 16)) >> 16,
              (p >> 8) & _e,
              p & _e,
              parseInt(t.substr(7), 16) / 255,
            ];
          p = [(t = parseInt(t.substr(1), 16)) >> 16, (t >> 8) & _e, t & _e];
        } else if ("hsl" === t.substr(0, 3))
          if (((p = d = t.match(H)), e)) {
            if (~t.indexOf("="))
              return (p = t.match(G)), n && p.length < 4 && (p[3] = 1), p;
          } else
            (a = (+p[0] % 360) / 360),
              (o = +p[1] / 100),
              (i =
                2 * (l = +p[2] / 100) -
                (r = l <= 0.5 ? l * (o + 1) : l + o - l * o)),
              p.length > 3 && (p[3] *= 1),
              (p[0] = ye(a + 1 / 3, i, r)),
              (p[1] = ye(a, i, r)),
              (p[2] = ye(a - 1 / 3, i, r));
        else p = t.match(H) || xe.transparent;
        p = p.map(Number);
      }
      return (
        e &&
          !d &&
          ((i = p[0] / _e),
          (r = p[1] / _e),
          (s = p[2] / _e),
          (l = ((c = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2),
          c === u
            ? (a = o = 0)
            : ((h = c - u),
              (o = l > 0.5 ? h / (2 - c - u) : h / (c + u)),
              (a =
                c === i
                  ? (r - s) / h + (r < s ? 6 : 0)
                  : c === r
                  ? (s - i) / h + 2
                  : (i - r) / h + 4),
              (a *= 60)),
          (p[0] = ~~(a + 0.5)),
          (p[1] = ~~(100 * o + 0.5)),
          (p[2] = ~~(100 * l + 0.5))),
        n && p.length < 4 && (p[3] = 1),
        p
      );
    },
    Me = function (t) {
      var e = [],
        n = [],
        i = -1;
      return (
        t.split(Te).forEach(function (t) {
          var r = t.match(W) || [];
          e.push.apply(e, r), n.push((i += r.length + 1));
        }),
        (e.c = n),
        e
      );
    },
    Ee = function (t, e, n) {
      var i,
        r,
        s,
        a,
        o = "",
        l = (t + o).match(Te),
        c = e ? "hsla(" : "rgba(",
        u = 0;
      if (!l) return t;
      if (
        ((l = l.map(function (t) {
          return (
            (t = Se(t, e, 1)) &&
            c +
              (e
                ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3]
                : t.join(",")) +
              ")"
          );
        })),
        n && ((s = Me(t)), (i = n.c).join(o) !== s.c.join(o)))
      )
        for (a = (r = t.replace(Te, "1").split(W)).length - 1; u < a; u++)
          o +=
            r[u] +
            (~i.indexOf(u)
              ? l.shift() || c + "0,0,0,0)"
              : (s.length ? s : l.length ? l : n).shift());
      if (!r)
        for (a = (r = t.split(Te)).length - 1; u < a; u++) o += r[u] + l[u];
      return o + r[a];
    },
    Te = (function () {
      var t,
        e =
          "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
      for (t in xe) e += "|" + t + "\\b";
      return new RegExp(e + ")", "gi");
    })(),
    be = /hsl[a]?\(/,
    De = function (t) {
      var e,
        n = t.join(" ");
      if (((Te.lastIndex = 0), Te.test(n)))
        return (
          (e = be.test(n)),
          (t[1] = Ee(t[1], e)),
          (t[0] = Ee(t[0], e, Me(t[1]))),
          !0
        );
    },
    we = (function () {
      var t,
        e,
        n,
        i,
        r,
        s,
        a = Date.now,
        o = 500,
        l = 33,
        p = a(),
        f = p,
        g = 1e3 / 240,
        v = g,
        _ = [],
        x = function n(c) {
          var u,
            h,
            d,
            m,
            x = a() - f,
            y = !0 === c;
          if (
            ((x > o || x < 0) && (p += x - l),
            ((u = (d = (f += x) - p) - v) > 0 || y) &&
              ((m = ++i.frame),
              (r = d - 1e3 * i.time),
              (i.time = d /= 1e3),
              (v += u + (u >= g ? 4 : g - u)),
              (h = 1)),
            y || (t = e(n)),
            h)
          )
            for (s = 0; s < _.length; s++) _[s](d, r, m, c);
        };
      return (
        (i = {
          time: 0,
          frame: 0,
          tick: function () {
            x(!0);
          },
          deltaRatio: function (t) {
            return r / (1e3 / (t || 60));
          },
          wake: function () {
            d &&
              (!u &&
                B() &&
                ((c = u = window),
                (h = c.document || {}),
                (K.gsap = wn),
                (c.gsapVersions || (c.gsapVersions = [])).push(wn.version),
                J(Z || c.GreenSockGlobals || (!c.gsap && c) || {}),
                ge.forEach(ve)),
              (n =
                "undefined" != typeof requestAnimationFrame &&
                requestAnimationFrame),
              t && i.sleep(),
              (e =
                n ||
                function (t) {
                  return setTimeout(t, (v - 1e3 * i.time + 1) | 0);
                }),
              (m = 1),
              x(2));
          },
          sleep: function () {
            (n ? cancelAnimationFrame : clearTimeout)(t), (m = 0), (e = et);
          },
          lagSmoothing: function (t, e) {
            (o = t || 1 / 0), (l = Math.min(e || 33, o));
          },
          fps: function (t) {
            (g = 1e3 / (t || 240)), (v = 1e3 * i.time + g);
          },
          add: function (t, e, n) {
            var r = e
              ? function (e, n, s, a) {
                  t(e, n, s, a), i.remove(r);
                }
              : t;
            return i.remove(t), _[n ? "unshift" : "push"](r), Ce(), r;
          },
          remove: function (t, e) {
            ~(e = _.indexOf(t)) && _.splice(e, 1) && s >= e && s--;
          },
          _listeners: _,
        }),
        i
      );
    })(),
    Ce = function () {
      return !m && we.wake();
    },
    Ae = {},
    Re = /^[\d.\-M][\d.\-,\s]/,
    Pe = /["']/g,
    Le = function (t) {
      for (
        var e,
          n,
          i,
          r = {},
          s = t.substr(1, t.length - 3).split(":"),
          a = s[0],
          o = 1,
          l = s.length;
        o < l;
        o++
      )
        (n = s[o]),
          (e = o !== l - 1 ? n.lastIndexOf(",") : n.length),
          (i = n.substr(0, e)),
          (r[a] = isNaN(i) ? i.replace(Pe, "").trim() : +i),
          (a = n.substr(e + 1).trim());
      return r;
    },
    Ie = function (t) {
      return function (e) {
        return 1 - t(1 - e);
      };
    },
    Ue = function t(e, n) {
      for (var i, r = e._first; r; )
        r instanceof He
          ? t(r, n)
          : !r.vars.yoyoEase ||
            (r._yoyo && r._repeat) ||
            r._yoyo === n ||
            (r.timeline
              ? t(r.timeline, n)
              : ((i = r._ease),
                (r._ease = r._yEase),
                (r._yEase = i),
                (r._yoyo = n))),
          (r = r._next);
    },
    Ne = function (t, e) {
      return (
        (t &&
          (I(t)
            ? t
            : Ae[t] ||
              (function (t) {
                var e,
                  n,
                  i,
                  r,
                  s = (t + "").split("("),
                  a = Ae[s[0]];
                return a && s.length > 1 && a.config
                  ? a.config.apply(
                      null,
                      ~t.indexOf("{")
                        ? [Le(s[1])]
                        : ((e = t),
                          (n = e.indexOf("(") + 1),
                          (i = e.indexOf(")")),
                          (r = e.indexOf("(", n)),
                          e.substring(
                            n,
                            ~r && r < i ? e.indexOf(")", i + 1) : i
                          ))
                            .split(",")
                            .map(Et)
                    )
                  : Ae._CE && Re.test(t)
                  ? Ae._CE("", t)
                  : a;
              })(t))) ||
        e
      );
    },
    Fe = function (t, e, n, i) {
      void 0 === n &&
        (n = function (t) {
          return 1 - e(1 - t);
        }),
        void 0 === i &&
          (i = function (t) {
            return t < 0.5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2;
          });
      var r,
        s = { easeIn: e, easeOut: n, easeInOut: i };
      return (
        gt(t, function (t) {
          for (var e in ((Ae[t] = K[t] = s),
          (Ae[(r = t.toLowerCase())] = n),
          s))
            Ae[
              r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")
            ] = Ae[t + "." + e] = s[e];
        }),
        s
      );
    },
    Oe = function (t) {
      return function (e) {
        return e < 0.5 ? (1 - t(1 - 2 * e)) / 2 : 0.5 + t(2 * (e - 0.5)) / 2;
      };
    },
    Be = function t(e, n, i) {
      var r = n >= 1 ? n : 1,
        s = (i || (e ? 0.3 : 0.45)) / (n < 1 ? n : 1),
        a = (s / D) * (Math.asin(1 / r) || 0),
        o = function (t) {
          return 1 === t ? 1 : r * Math.pow(2, -10 * t) * P((t - a) * s) + 1;
        },
        l =
          "out" === e
            ? o
            : "in" === e
            ? function (t) {
                return 1 - o(1 - t);
              }
            : Oe(o);
      return (
        (s = D / s),
        (l.config = function (n, i) {
          return t(e, n, i);
        }),
        l
      );
    },
    ze = function t(e, n) {
      void 0 === n && (n = 1.70158);
      var i = function (t) {
          return t ? --t * t * ((n + 1) * t + n) + 1 : 0;
        },
        r =
          "out" === e
            ? i
            : "in" === e
            ? function (t) {
                return 1 - i(1 - t);
              }
            : Oe(i);
      return (
        (r.config = function (n) {
          return t(e, n);
        }),
        r
      );
    };
  gt("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) {
    var n = e < 5 ? e + 1 : e;
    Fe(
      t + ",Power" + (n - 1),
      e
        ? function (t) {
            return Math.pow(t, n);
          }
        : function (t) {
            return t;
          },
      function (t) {
        return 1 - Math.pow(1 - t, n);
      },
      function (t) {
        return t < 0.5
          ? Math.pow(2 * t, n) / 2
          : 1 - Math.pow(2 * (1 - t), n) / 2;
      }
    );
  }),
    (Ae.Linear.easeNone = Ae.none = Ae.Linear.easeIn),
    Fe("Elastic", Be("in"), Be("out"), Be()),
    (g = 7.5625),
    (x = 2 * (_ = 1 / (v = 2.75))),
    (y = 2.5 * _),
    Fe(
      "Bounce",
      function (t) {
        return 1 - S(1 - t);
      },
      (S = function (t) {
        return t < _
          ? g * t * t
          : t < x
          ? g * Math.pow(t - 1.5 / v, 2) + 0.75
          : t < y
          ? g * (t -= 2.25 / v) * t + 0.9375
          : g * Math.pow(t - 2.625 / v, 2) + 0.984375;
      })
    ),
    Fe("Expo", function (t) {
      return t ? Math.pow(2, 10 * (t - 1)) : 0;
    }),
    Fe("Circ", function (t) {
      return -(A(1 - t * t) - 1);
    }),
    Fe("Sine", function (t) {
      return 1 === t ? 1 : 1 - R(t * w);
    }),
    Fe("Back", ze("in"), ze("out"), ze()),
    (Ae.SteppedEase =
      Ae.steps =
      K.SteppedEase =
        {
          config: function (t, e) {
            void 0 === t && (t = 1);
            var n = 1 / t,
              i = t + (e ? 0 : 1),
              r = e ? 1 : 0;
            return function (t) {
              return (((i * Qt(0, 0.99999999, t)) | 0) + r) * n;
            };
          },
        }),
    (E.ease = Ae["quad.out"]),
    gt(
      "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
      function (t) {
        return (dt += t + "," + t + "Params,");
      }
    );
  var ke = function (t, e) {
      (this.id = C++),
        (t._gsap = this),
        (this.target = t),
        (this.harness = e),
        (this.get = e ? e.get : mt),
        (this.set = e ? e.getSetter : sn);
    },
    Ve = (function () {
      function t(t) {
        (this.vars = t),
          (this._delay = +t.delay || 0),
          (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
            ((this._rDelay = t.repeatDelay || 0),
            (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
          (this._ts = 1),
          jt(this, +t.duration, 1, 1),
          (this.data = t.data),
          o && ((this._ctx = o), o.data.push(this)),
          m || we.wake();
      }
      var e = t.prototype;
      return (
        (e.delay = function (t) {
          return t || 0 === t
            ? (this.parent &&
                this.parent.smoothChildTiming &&
                this.startTime(this._start + t - this._delay),
              (this._delay = t),
              this)
            : this._delay;
        }),
        (e.duration = function (t) {
          return arguments.length
            ? this.totalDuration(
                this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t
              )
            : this.totalDuration() && this._dur;
        }),
        (e.totalDuration = function (t) {
          return arguments.length
            ? ((this._dirty = 0),
              jt(
                this,
                this._repeat < 0
                  ? t
                  : (t - this._repeat * this._rDelay) / (this._repeat + 1)
              ))
            : this._tDur;
        }),
        (e.totalTime = function (t, e) {
          if ((Ce(), !arguments.length)) return this._tTime;
          var n = this._dp;
          if (n && n.smoothChildTiming && this._ts) {
            for (
              kt(this, t), !n._dp || n.parent || Vt(n, this);
              n && n.parent;

            )
              n.parent._time !==
                n._start +
                  (n._ts >= 0
                    ? n._tTime / n._ts
                    : (n.totalDuration() - n._tTime) / -n._ts) &&
                n.totalTime(n._tTime, !0),
                (n = n.parent);
            !this.parent &&
              this._dp.autoRemoveChildren &&
              ((this._ts > 0 && t < this._tDur) ||
                (this._ts < 0 && t > 0) ||
                (!this._tDur && !t)) &&
              Ht(this._dp, this, this._start - this._delay);
          }
          return (
            (this._tTime !== t ||
              (!this._dur && !e) ||
              (this._initted && Math.abs(this._zTime) === b) ||
              (!t && !this._initted && (this.add || this._ptLookup))) &&
              (this._ts || (this._pTime = t), Mt(this, t, e)),
            this
          );
        }),
        (e.time = function (t, e) {
          return arguments.length
            ? this.totalTime(
                Math.min(this.totalDuration(), t + Ft(this)) %
                  (this._dur + this._rDelay) || (t ? this._dur : 0),
                e
              )
            : this._time;
        }),
        (e.totalProgress = function (t, e) {
          return arguments.length
            ? this.totalTime(this.totalDuration() * t, e)
            : this.totalDuration()
            ? Math.min(1, this._tTime / this._tDur)
            : this.rawTime() > 0
            ? 1
            : 0;
        }),
        (e.progress = function (t, e) {
          return arguments.length
            ? this.totalTime(
                this.duration() *
                  (!this._yoyo || 1 & this.iteration() ? t : 1 - t) +
                  Ft(this),
                e
              )
            : this.duration()
            ? Math.min(1, this._time / this._dur)
            : this.rawTime() > 0
            ? 1
            : 0;
        }),
        (e.iteration = function (t, e) {
          var n = this.duration() + this._rDelay;
          return arguments.length
            ? this.totalTime(this._time + (t - 1) * n, e)
            : this._repeat
            ? Ot(this._tTime, n) + 1
            : 1;
        }),
        (e.timeScale = function (t, e) {
          if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
          if (this._rts === t) return this;
          var n =
            this.parent && this._ts ? Bt(this.parent._time, this) : this._tTime;
          return (
            (this._rts = +t || 0),
            (this._ts = this._ps || -1e-8 === t ? 0 : this._rts),
            this.totalTime(Qt(-Math.abs(this._delay), this._tDur, n), !1 !== e),
            zt(this),
            (function (t) {
              for (var e = t.parent; e && e.parent; )
                (e._dirty = 1), e.totalDuration(), (e = e.parent);
              return t;
            })(this)
          );
        }),
        (e.paused = function (t) {
          return arguments.length
            ? (this._ps !== t &&
                ((this._ps = t),
                t
                  ? ((this._pTime =
                      this._tTime || Math.max(-this._delay, this.rawTime())),
                    (this._ts = this._act = 0))
                  : (Ce(),
                    (this._ts = this._rts),
                    this.totalTime(
                      this.parent && !this.parent.smoothChildTiming
                        ? this.rawTime()
                        : this._tTime || this._pTime,
                      1 === this.progress() &&
                        Math.abs(this._zTime) !== b &&
                        (this._tTime -= b)
                    ))),
              this)
            : this._ps;
        }),
        (e.startTime = function (t) {
          if (arguments.length) {
            this._start = t;
            var e = this.parent || this._dp;
            return (
              e && (e._sort || !this.parent) && Ht(e, this, t - this._delay),
              this
            );
          }
          return this._start;
        }),
        (e.endTime = function (t) {
          return (
            this._start +
            (O(t) ? this.totalDuration() : this.duration()) /
              Math.abs(this._ts || 1)
          );
        }),
        (e.rawTime = function (t) {
          var e = this.parent || this._dp;
          return e
            ? t &&
              (!this._ts ||
                (this._repeat && this._time && this.totalProgress() < 1))
              ? this._tTime % (this._dur + this._rDelay)
              : this._ts
              ? Bt(e.rawTime(t), this)
              : this._tTime
            : this._tTime;
        }),
        (e.revert = function (t) {
          void 0 === t && (t = rt);
          var e = a;
          return (
            (a = t),
            (this._initted || this._startAt) &&
              (this.timeline && this.timeline.revert(t),
              this.totalTime(-0.01, t.suppressEvents)),
            "nested" !== this.data && !1 !== t.kill && this.kill(),
            (a = e),
            this
          );
        }),
        (e.globalTime = function (t) {
          for (var e = this, n = arguments.length ? t : e.rawTime(); e; )
            (n = e._start + n / (Math.abs(e._ts) || 1)), (e = e._dp);
          return !this.parent && this._sat ? this._sat.globalTime(t) : n;
        }),
        (e.repeat = function (t) {
          return arguments.length
            ? ((this._repeat = t === 1 / 0 ? -2 : t), Yt(this))
            : -2 === this._repeat
            ? 1 / 0
            : this._repeat;
        }),
        (e.repeatDelay = function (t) {
          if (arguments.length) {
            var e = this._time;
            return (this._rDelay = t), Yt(this), e ? this.time(e) : this;
          }
          return this._rDelay;
        }),
        (e.yoyo = function (t) {
          return arguments.length ? ((this._yoyo = t), this) : this._yoyo;
        }),
        (e.seek = function (t, e) {
          return this.totalTime(Zt(this, t), O(e));
        }),
        (e.restart = function (t, e) {
          return this.play().totalTime(t ? -this._delay : 0, O(e));
        }),
        (e.play = function (t, e) {
          return null != t && this.seek(t, e), this.reversed(!1).paused(!1);
        }),
        (e.reverse = function (t, e) {
          return (
            null != t && this.seek(t || this.totalDuration(), e),
            this.reversed(!0).paused(!1)
          );
        }),
        (e.pause = function (t, e) {
          return null != t && this.seek(t, e), this.paused(!0);
        }),
        (e.resume = function () {
          return this.paused(!1);
        }),
        (e.reversed = function (t) {
          return arguments.length
            ? (!!t !== this.reversed() &&
                this.timeScale(-this._rts || (t ? -1e-8 : 0)),
              this)
            : this._rts < 0;
        }),
        (e.invalidate = function () {
          return (this._initted = this._act = 0), (this._zTime = -1e-8), this;
        }),
        (e.isActive = function () {
          var t,
            e = this.parent || this._dp,
            n = this._start;
          return !(
            e &&
            !(
              this._ts &&
              this._initted &&
              e.isActive() &&
              (t = e.rawTime(!0)) >= n &&
              t < this.endTime(!0) - b
            )
          );
        }),
        (e.eventCallback = function (t, e, n) {
          var i = this.vars;
          return arguments.length > 1
            ? (e
                ? ((i[t] = e),
                  n && (i[t + "Params"] = n),
                  "onUpdate" === t && (this._onUpdate = e))
                : delete i[t],
              this)
            : i[t];
        }),
        (e.then = function (t) {
          var e = this;
          return new Promise(function (n) {
            var i = I(t) ? t : Tt,
              r = function () {
                var t = e.then;
                (e.then = null),
                  I(i) && (i = i(e)) && (i.then || i === e) && (e.then = t),
                  n(i),
                  (e.then = t);
              };
            (e._initted && 1 === e.totalProgress() && e._ts >= 0) ||
            (!e._tTime && e._ts < 0)
              ? r()
              : (e._prom = r);
          });
        }),
        (e.kill = function () {
          me(this);
        }),
        t
      );
    })();
  bt(Ve.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -1e-8,
    _prom: 0,
    _ps: !1,
    _rts: 1,
  });
  var He = (function (t) {
    function e(e, n) {
      var r;
      return (
        void 0 === e && (e = {}),
        ((r = t.call(this, e) || this).labels = {}),
        (r.smoothChildTiming = !!e.smoothChildTiming),
        (r.autoRemoveChildren = !!e.autoRemoveChildren),
        (r._sort = O(e.sortChildren)),
        l && Ht(e.parent || l, i(r), n),
        e.reversed && r.reverse(),
        e.paused && r.paused(!0),
        r
      );
    }
    r(e, t);
    var n = e.prototype;
    return (
      (n.to = function (t, e, n) {
        return Jt(0, arguments, this), this;
      }),
      (n.from = function (t, e, n) {
        return Jt(1, arguments, this), this;
      }),
      (n.fromTo = function (t, e, n, i) {
        return Jt(2, arguments, this), this;
      }),
      (n.set = function (t, e, n) {
        return (
          (e.duration = 0),
          (e.parent = this),
          At(e).repeatDelay || (e.repeat = 0),
          (e.immediateRender = !!e.immediateRender),
          new Qe(t, e, Zt(this, n), 1),
          this
        );
      }),
      (n.call = function (t, e, n) {
        return Ht(this, Qe.delayedCall(0, t, e), n);
      }),
      (n.staggerTo = function (t, e, n, i, r, s, a) {
        return (
          (n.duration = e),
          (n.stagger = n.stagger || i),
          (n.onComplete = s),
          (n.onCompleteParams = a),
          (n.parent = this),
          new Qe(t, n, Zt(this, r)),
          this
        );
      }),
      (n.staggerFrom = function (t, e, n, i, r, s, a) {
        return (
          (n.runBackwards = 1),
          (At(n).immediateRender = O(n.immediateRender)),
          this.staggerTo(t, e, n, i, r, s, a)
        );
      }),
      (n.staggerFromTo = function (t, e, n, i, r, s, a, o) {
        return (
          (i.startAt = n),
          (At(i).immediateRender = O(i.immediateRender)),
          this.staggerTo(t, e, i, r, s, a, o)
        );
      }),
      (n.render = function (t, e, n) {
        var i,
          r,
          s,
          o,
          c,
          u,
          h,
          d,
          p,
          f,
          m,
          g,
          v = this._time,
          _ = this._dirty ? this.totalDuration() : this._tDur,
          x = this._dur,
          y = t <= 0 ? 0 : _t(t),
          S = this._zTime < 0 != t < 0 && (this._initted || !x);
        if (
          (this !== l && y > _ && t >= 0 && (y = _),
          y !== this._tTime || n || S)
        ) {
          if (
            (v !== this._time &&
              x &&
              ((y += this._time - v), (t += this._time - v)),
            (i = y),
            (p = this._start),
            (u = !(d = this._ts)),
            S && (x || (v = this._zTime), (t || !e) && (this._zTime = t)),
            this._repeat)
          ) {
            if (
              ((m = this._yoyo),
              (c = x + this._rDelay),
              this._repeat < -1 && t < 0)
            )
              return this.totalTime(100 * c + t, e, n);
            if (
              ((i = _t(y % c)),
              y === _
                ? ((o = this._repeat), (i = x))
                : ((o = ~~(y / c)) && o === y / c && ((i = x), o--),
                  i > x && (i = x)),
              (f = Ot(this._tTime, c)),
              !v &&
                this._tTime &&
                f !== o &&
                this._tTime - f * c - this._dur <= 0 &&
                (f = o),
              m && 1 & o && ((i = x - i), (g = 1)),
              o !== f && !this._lock)
            ) {
              var M = m && 1 & f,
                E = M === (m && 1 & o);
              if (
                (o < f && (M = !M),
                (v = M ? 0 : y % x ? x : y),
                (this._lock = 1),
                (this.render(v || (g ? 0 : _t(o * c)), e, !x)._lock = 0),
                (this._tTime = y),
                !e && this.parent && fe(this, "onRepeat"),
                this.vars.repeatRefresh && !g && (this.invalidate()._lock = 1),
                (v && v !== this._time) ||
                  u !== !this._ts ||
                  (this.vars.onRepeat && !this.parent && !this._act))
              )
                return this;
              if (
                ((x = this._dur),
                (_ = this._tDur),
                E &&
                  ((this._lock = 2),
                  (v = M ? x : -1e-4),
                  this.render(v, !0),
                  this.vars.repeatRefresh && !g && this.invalidate()),
                (this._lock = 0),
                !this._ts && !u)
              )
                return this;
              Ue(this, g);
            }
          }
          if (
            (this._hasPause &&
              !this._forcing &&
              this._lock < 2 &&
              ((h = (function (t, e, n) {
                var i;
                if (n > e)
                  for (i = t._first; i && i._start <= n; ) {
                    if ("isPause" === i.data && i._start > e) return i;
                    i = i._next;
                  }
                else
                  for (i = t._last; i && i._start >= n; ) {
                    if ("isPause" === i.data && i._start < e) return i;
                    i = i._prev;
                  }
              })(this, _t(v), _t(i))),
              h && (y -= i - (i = h._start))),
            (this._tTime = y),
            (this._time = i),
            (this._act = !d),
            this._initted ||
              ((this._onUpdate = this.vars.onUpdate),
              (this._initted = 1),
              (this._zTime = t),
              (v = 0)),
            !v && i && !e && !o && (fe(this, "onStart"), this._tTime !== y))
          )
            return this;
          if (i >= v && t >= 0)
            for (r = this._first; r; ) {
              if (
                ((s = r._next), (r._act || i >= r._start) && r._ts && h !== r)
              ) {
                if (r.parent !== this) return this.render(t, e, n);
                if (
                  (r.render(
                    r._ts > 0
                      ? (i - r._start) * r._ts
                      : (r._dirty ? r.totalDuration() : r._tDur) +
                          (i - r._start) * r._ts,
                    e,
                    n
                  ),
                  i !== this._time || (!this._ts && !u))
                ) {
                  (h = 0), s && (y += this._zTime = -1e-8);
                  break;
                }
              }
              r = s;
            }
          else {
            r = this._last;
            for (var T = t < 0 ? t : i; r; ) {
              if (
                ((s = r._prev), (r._act || T <= r._end) && r._ts && h !== r)
              ) {
                if (r.parent !== this) return this.render(t, e, n);
                if (
                  (r.render(
                    r._ts > 0
                      ? (T - r._start) * r._ts
                      : (r._dirty ? r.totalDuration() : r._tDur) +
                          (T - r._start) * r._ts,
                    e,
                    n || (a && (r._initted || r._startAt))
                  ),
                  i !== this._time || (!this._ts && !u))
                ) {
                  (h = 0), s && (y += this._zTime = T ? -1e-8 : b);
                  break;
                }
              }
              r = s;
            }
          }
          if (
            h &&
            !e &&
            (this.pause(),
            (h.render(i >= v ? 0 : -1e-8)._zTime = i >= v ? 1 : -1),
            this._ts)
          )
            return (this._start = p), zt(this), this.render(t, e, n);
          this._onUpdate && !e && fe(this, "onUpdate", !0),
            ((y === _ && this._tTime >= this.totalDuration()) || (!y && v)) &&
              ((p !== this._start && Math.abs(d) === Math.abs(this._ts)) ||
                this._lock ||
                ((t || !x) &&
                  ((y === _ && this._ts > 0) || (!y && this._ts < 0)) &&
                  Lt(this, 1),
                e ||
                  (t < 0 && !v) ||
                  (!y && !v && _) ||
                  (fe(
                    this,
                    y === _ && t >= 0 ? "onComplete" : "onReverseComplete",
                    !0
                  ),
                  this._prom &&
                    !(y < _ && this.timeScale() > 0) &&
                    this._prom())));
        }
        return this;
      }),
      (n.add = function (t, e) {
        var n = this;
        if ((U(e) || (e = Zt(this, e, t)), !(t instanceof Ve))) {
          if (V(t))
            return (
              t.forEach(function (t) {
                return n.add(t, e);
              }),
              this
            );
          if (L(t)) return this.addLabel(t, e);
          if (!I(t)) return this;
          t = Qe.delayedCall(0, t);
        }
        return this !== t ? Ht(this, t, e) : this;
      }),
      (n.getChildren = function (t, e, n, i) {
        void 0 === t && (t = !0),
          void 0 === e && (e = !0),
          void 0 === n && (n = !0),
          void 0 === i && (i = -T);
        for (var r = [], s = this._first; s; )
          s._start >= i &&
            (s instanceof Qe
              ? e && r.push(s)
              : (n && r.push(s),
                t && r.push.apply(r, s.getChildren(!0, e, n)))),
            (s = s._next);
        return r;
      }),
      (n.getById = function (t) {
        for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
          if (e[n].vars.id === t) return e[n];
      }),
      (n.remove = function (t) {
        return L(t)
          ? this.removeLabel(t)
          : I(t)
          ? this.killTweensOf(t)
          : (Pt(this, t),
            t === this._recent && (this._recent = this._last),
            It(this));
      }),
      (n.totalTime = function (e, n) {
        return arguments.length
          ? ((this._forcing = 1),
            !this._dp &&
              this._ts &&
              (this._start = _t(
                we.time -
                  (this._ts > 0
                    ? e / this._ts
                    : (this.totalDuration() - e) / -this._ts)
              )),
            t.prototype.totalTime.call(this, e, n),
            (this._forcing = 0),
            this)
          : this._tTime;
      }),
      (n.addLabel = function (t, e) {
        return (this.labels[t] = Zt(this, e)), this;
      }),
      (n.removeLabel = function (t) {
        return delete this.labels[t], this;
      }),
      (n.addPause = function (t, e, n) {
        var i = Qe.delayedCall(0, e || et, n);
        return (
          (i.data = "isPause"), (this._hasPause = 1), Ht(this, i, Zt(this, t))
        );
      }),
      (n.removePause = function (t) {
        var e = this._first;
        for (t = Zt(this, t); e; )
          e._start === t && "isPause" === e.data && Lt(e), (e = e._next);
      }),
      (n.killTweensOf = function (t, e, n) {
        for (var i = this.getTweensOf(t, n), r = i.length; r--; )
          Ge !== i[r] && i[r].kill(t, e);
        return this;
      }),
      (n.getTweensOf = function (t, e) {
        for (var n, i = [], r = ie(t), s = this._first, a = U(e); s; )
          s instanceof Qe
            ? yt(s._targets, r) &&
              (a
                ? (!Ge || (s._initted && s._ts)) &&
                  s.globalTime(0) <= e &&
                  s.globalTime(s.totalDuration()) > e
                : !e || s.isActive()) &&
              i.push(s)
            : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n),
            (s = s._next);
        return i;
      }),
      (n.tweenTo = function (t, e) {
        e = e || {};
        var n,
          i = this,
          r = Zt(i, t),
          s = e,
          a = s.startAt,
          o = s.onStart,
          l = s.onStartParams,
          c = s.immediateRender,
          u = Qe.to(
            i,
            bt(
              {
                ease: e.ease || "none",
                lazy: !1,
                immediateRender: !1,
                time: r,
                overwrite: "auto",
                duration:
                  e.duration ||
                  Math.abs(
                    (r - (a && "time" in a ? a.time : i._time)) / i.timeScale()
                  ) ||
                  b,
                onStart: function () {
                  if ((i.pause(), !n)) {
                    var t =
                      e.duration ||
                      Math.abs(
                        (r - (a && "time" in a ? a.time : i._time)) /
                          i.timeScale()
                      );
                    u._dur !== t && jt(u, t, 0, 1).render(u._time, !0, !0),
                      (n = 1);
                  }
                  o && o.apply(u, l || []);
                },
              },
              e
            )
          );
        return c ? u.render(0) : u;
      }),
      (n.tweenFromTo = function (t, e, n) {
        return this.tweenTo(e, bt({ startAt: { time: Zt(this, t) } }, n));
      }),
      (n.recent = function () {
        return this._recent;
      }),
      (n.nextLabel = function (t) {
        return void 0 === t && (t = this._time), pe(this, Zt(this, t));
      }),
      (n.previousLabel = function (t) {
        return void 0 === t && (t = this._time), pe(this, Zt(this, t), 1);
      }),
      (n.currentLabel = function (t) {
        return arguments.length
          ? this.seek(t, !0)
          : this.previousLabel(this._time + b);
      }),
      (n.shiftChildren = function (t, e, n) {
        void 0 === n && (n = 0);
        for (var i, r = this._first, s = this.labels; r; )
          r._start >= n && ((r._start += t), (r._end += t)), (r = r._next);
        if (e) for (i in s) s[i] >= n && (s[i] += t);
        return It(this);
      }),
      (n.invalidate = function (e) {
        var n = this._first;
        for (this._lock = 0; n; ) n.invalidate(e), (n = n._next);
        return t.prototype.invalidate.call(this, e);
      }),
      (n.clear = function (t) {
        void 0 === t && (t = !0);
        for (var e, n = this._first; n; )
          (e = n._next), this.remove(n), (n = e);
        return (
          this._dp && (this._time = this._tTime = this._pTime = 0),
          t && (this.labels = {}),
          It(this)
        );
      }),
      (n.totalDuration = function (t) {
        var e,
          n,
          i,
          r = 0,
          s = this,
          a = s._last,
          o = T;
        if (arguments.length)
          return s.timeScale(
            (s._repeat < 0 ? s.duration() : s.totalDuration()) /
              (s.reversed() ? -t : t)
          );
        if (s._dirty) {
          for (i = s.parent; a; )
            (e = a._prev),
              a._dirty && a.totalDuration(),
              (n = a._start) > o && s._sort && a._ts && !s._lock
                ? ((s._lock = 1), (Ht(s, a, n - a._delay, 1)._lock = 0))
                : (o = n),
              n < 0 &&
                a._ts &&
                ((r -= n),
                ((!i && !s._dp) || (i && i.smoothChildTiming)) &&
                  ((s._start += n / s._ts), (s._time -= n), (s._tTime -= n)),
                s.shiftChildren(-n, !1, -Infinity),
                (o = 0)),
              a._end > r && a._ts && (r = a._end),
              (a = e);
          jt(s, s === l && s._time > r ? s._time : r, 1, 1), (s._dirty = 0);
        }
        return s._tDur;
      }),
      (e.updateRoot = function (t) {
        if ((l._ts && (Mt(l, Bt(t, l)), (p = we.frame)), we.frame >= ut)) {
          ut += M.autoSleep || 120;
          var e = l._first;
          if ((!e || !e._ts) && M.autoSleep && we._listeners.length < 2) {
            for (; e && !e._ts; ) e = e._next;
            e || we.sleep();
          }
        }
      }),
      e
    );
  })(Ve);
  bt(He.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
  var Ge,
    We,
    Xe = function (t, e, n, i, r, s, a) {
      var o,
        l,
        c,
        u,
        h,
        d,
        p,
        f,
        m = new fn(this._pt, t, e, 0, 1, ln, null, r),
        g = 0,
        v = 0;
      for (
        m.b = n,
          m.e = i,
          n += "",
          (p = ~(i += "").indexOf("random(")) && (i = he(i)),
          s && (s((f = [n, i]), t, e), (n = f[0]), (i = f[1])),
          l = n.match(X) || [];
        (o = X.exec(i));

      )
        (u = o[0]),
          (h = i.substring(g, o.index)),
          c ? (c = (c + 1) % 5) : "rgba(" === h.substr(-5) && (c = 1),
          u !== l[v++] &&
            ((d = parseFloat(l[v - 1]) || 0),
            (m._pt = {
              _next: m._pt,
              p: h || 1 === v ? h : ",",
              s: d,
              c: "=" === u.charAt(1) ? xt(d, u) - d : parseFloat(u) - d,
              m: c && c < 4 ? Math.round : 0,
            }),
            (g = X.lastIndex));
      return (
        (m.c = g < i.length ? i.substring(g, i.length) : ""),
        (m.fp = a),
        (q.test(i) || p) && (m.e = 0),
        (this._pt = m),
        m
      );
    },
    qe = function (t, e, n, i, r, s, a, o, l, c) {
      I(i) && (i = i(r || 0, t, s));
      var u,
        h = t[e],
        d =
          "get" !== n
            ? n
            : I(h)
            ? l
              ? t[
                  e.indexOf("set") || !I(t["get" + e.substr(3)])
                    ? e
                    : "get" + e.substr(3)
                ](l)
              : t[e]()
            : h,
        p = I(h) ? (l ? nn : en) : tn;
      if (
        (L(i) &&
          (~i.indexOf("random(") && (i = he(i)),
          "=" === i.charAt(1) &&
            ((u = xt(d, i) + (te(d) || 0)) || 0 === u) &&
            (i = u)),
        !c || d !== i || We)
      )
        return isNaN(d * i) || "" === i
          ? (!h && !(e in t) && $(e, i),
            Xe.call(this, t, e, d, i, p, o || M.stringFilter, l))
          : ((u = new fn(
              this._pt,
              t,
              e,
              +d || 0,
              i - (d || 0),
              "boolean" == typeof h ? on : an,
              0,
              p
            )),
            l && (u.fp = l),
            a && u.modifier(a, this, t),
            (this._pt = u));
    },
    je = function (t, e, n, i, r, s) {
      var a, o, l, c;
      if (
        lt[t] &&
        !1 !==
          (a = new lt[t]()).init(
            r,
            a.rawVars
              ? e[t]
              : (function (t, e, n, i, r) {
                  if (
                    (I(t) && (t = Ze(t, r, e, n, i)),
                    !F(t) || (t.style && t.nodeType) || V(t) || k(t))
                  )
                    return L(t) ? Ze(t, r, e, n, i) : t;
                  var s,
                    a = {};
                  for (s in t) a[s] = Ze(t[s], r, e, n, i);
                  return a;
                })(e[t], i, r, s, n),
            n,
            i,
            s
          ) &&
        ((n._pt = o = new fn(n._pt, r, t, 0, 1, a.render, a, 0, a.priority)),
        n !== f)
      )
        for (l = n._ptLookup[n._targets.indexOf(r)], c = a._props.length; c--; )
          l[a._props[c]] = o;
      return a;
    },
    Ye = function t(e, n, i) {
      var r,
        o,
        c,
        u,
        h,
        d,
        p,
        f,
        m,
        g,
        v,
        _,
        x,
        y = e.vars,
        S = y.ease,
        M = y.startAt,
        D = y.immediateRender,
        w = y.lazy,
        C = y.onUpdate,
        A = y.runBackwards,
        R = y.yoyoEase,
        P = y.keyframes,
        L = y.autoRevert,
        I = e._dur,
        U = e._startAt,
        N = e._targets,
        F = e.parent,
        B = F && "nested" === F.data ? F.vars.targets : N,
        z = "auto" === e._overwrite && !s,
        k = e.timeline;
      if (
        (k && (!P || !S) && (S = "none"),
        (e._ease = Ne(S, E.ease)),
        (e._yEase = R ? Ie(Ne(!0 === R ? S : R, E.ease)) : 0),
        R &&
          e._yoyo &&
          !e._repeat &&
          ((R = e._yEase), (e._yEase = e._ease), (e._ease = R)),
        (e._from = !k && !!y.runBackwards),
        !k || (P && !y.stagger))
      ) {
        if (
          ((_ = (f = N[0] ? ft(N[0]).harness : 0) && y[f.prop]),
          (r = Ct(y, st)),
          U &&
            (U._zTime < 0 && U.progress(1),
            n < 0 && A && D && !L
              ? U.render(-1, !0)
              : U.revert(A && I ? it : nt),
            (U._lazy = 0)),
          M)
        ) {
          if (
            (Lt(
              (e._startAt = Qe.set(
                N,
                bt(
                  {
                    data: "isStart",
                    overwrite: !1,
                    parent: F,
                    immediateRender: !0,
                    lazy: !U && O(w),
                    startAt: null,
                    delay: 0,
                    onUpdate:
                      C &&
                      function () {
                        return fe(e, "onUpdate");
                      },
                    stagger: 0,
                  },
                  M
                )
              ))
            ),
            (e._startAt._dp = 0),
            (e._startAt._sat = e),
            n < 0 && (a || (!D && !L)) && e._startAt.revert(it),
            D && I && n <= 0 && i <= 0)
          )
            return void (n && (e._zTime = n));
        } else if (A && I && !U)
          if (
            (n && (D = !1),
            (c = bt(
              {
                overwrite: !1,
                data: "isFromStart",
                lazy: D && !U && O(w),
                immediateRender: D,
                stagger: 0,
                parent: F,
              },
              r
            )),
            _ && (c[f.prop] = _),
            Lt((e._startAt = Qe.set(N, c))),
            (e._startAt._dp = 0),
            (e._startAt._sat = e),
            n < 0 && (a ? e._startAt.revert(it) : e._startAt.render(-1, !0)),
            (e._zTime = n),
            D)
          ) {
            if (!n) return;
          } else t(e._startAt, b, b);
        for (
          e._pt = e._ptCache = 0, w = (I && O(w)) || (w && !I), o = 0;
          o < N.length;
          o++
        ) {
          if (
            ((p = (h = N[o])._gsap || pt(N)[o]._gsap),
            (e._ptLookup[o] = g = {}),
            ot[p.id] && at.length && St(),
            (v = B === N ? o : B.indexOf(h)),
            f &&
              !1 !== (m = new f()).init(h, _ || r, e, v, B) &&
              ((e._pt = u =
                new fn(e._pt, h, m.name, 0, 1, m.render, m, 0, m.priority)),
              m._props.forEach(function (t) {
                g[t] = u;
              }),
              m.priority && (d = 1)),
            !f || _)
          )
            for (c in r)
              lt[c] && (m = je(c, r, e, v, h, B))
                ? m.priority && (d = 1)
                : (g[c] = u =
                    qe.call(e, h, c, "get", r[c], v, B, 0, y.stringFilter));
          e._op && e._op[o] && e.kill(h, e._op[o]),
            z &&
              e._pt &&
              ((Ge = e),
              l.killTweensOf(h, g, e.globalTime(n)),
              (x = !e.parent),
              (Ge = 0)),
            e._pt && w && (ot[p.id] = 1);
        }
        d && pn(e), e._onInit && e._onInit(e);
      }
      (e._onUpdate = C),
        (e._initted = (!e._op || e._pt) && !x),
        P && n <= 0 && k.render(T, !0, !0);
    },
    Ke = function (t, e, n, i) {
      var r,
        s,
        a = e.ease || i || "power1.inOut";
      if (V(e))
        (s = n[t] || (n[t] = [])),
          e.forEach(function (t, n) {
            return s.push({ t: (n / (e.length - 1)) * 100, v: t, e: a });
          });
      else
        for (r in e)
          (s = n[r] || (n[r] = [])),
            "ease" === r || s.push({ t: parseFloat(t), v: e[r], e: a });
    },
    Ze = function (t, e, n, i, r) {
      return I(t)
        ? t.call(e, n, i, r)
        : L(t) && ~t.indexOf("random(")
        ? he(t)
        : t;
    },
    Je = dt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    $e = {};
  gt(Je + ",id,stagger,delay,duration,paused", function (t) {
    return ($e[t] = 1);
  });
  var Qe = (function (t) {
    function e(e, n, r, a) {
      var o;
      "number" == typeof n && ((r.duration = n), (n = r), (r = null));
      var c,
        u,
        h,
        d,
        p,
        f,
        m,
        g,
        v = (o = t.call(this, a ? n : At(n)) || this).vars,
        _ = v.duration,
        x = v.delay,
        y = v.immediateRender,
        S = v.stagger,
        E = v.overwrite,
        T = v.keyframes,
        b = v.defaults,
        D = v.scrollTrigger,
        w = v.yoyoEase,
        C = n.parent || l,
        A = (V(e) || k(e) ? U(e[0]) : "length" in n) ? [e] : ie(e);
      if (
        ((o._targets = A.length
          ? pt(A)
          : Q(
              "GSAP target " + e + " not found. https://gsap.com",
              !M.nullTargetWarn
            ) || []),
        (o._ptLookup = []),
        (o._overwrite = E),
        T || S || z(_) || z(x))
      ) {
        if (
          ((n = o.vars),
          (c = o.timeline =
            new He({
              data: "nested",
              defaults: b || {},
              targets: C && "nested" === C.data ? C.vars.targets : A,
            })).kill(),
          (c.parent = c._dp = i(o)),
          (c._start = 0),
          S || z(_) || z(x))
        ) {
          if (((d = A.length), (m = S && ae(S)), F(S)))
            for (p in S) ~Je.indexOf(p) && (g || (g = {}), (g[p] = S[p]));
          for (u = 0; u < d; u++)
            ((h = Ct(n, $e)).stagger = 0),
              w && (h.yoyoEase = w),
              g && Dt(h, g),
              (f = A[u]),
              (h.duration = +Ze(_, i(o), u, f, A)),
              (h.delay = (+Ze(x, i(o), u, f, A) || 0) - o._delay),
              !S &&
                1 === d &&
                h.delay &&
                ((o._delay = x = h.delay), (o._start += x), (h.delay = 0)),
              c.to(f, h, m ? m(u, f, A) : 0),
              (c._ease = Ae.none);
          c.duration() ? (_ = x = 0) : (o.timeline = 0);
        } else if (T) {
          At(bt(c.vars.defaults, { ease: "none" })),
            (c._ease = Ne(T.ease || n.ease || "none"));
          var R,
            P,
            L,
            I = 0;
          if (V(T))
            T.forEach(function (t) {
              return c.to(A, t, ">");
            }),
              c.duration();
          else {
            for (p in ((h = {}), T))
              "ease" === p || "easeEach" === p || Ke(p, T[p], h, T.easeEach);
            for (p in h)
              for (
                R = h[p].sort(function (t, e) {
                  return t.t - e.t;
                }),
                  I = 0,
                  u = 0;
                u < R.length;
                u++
              )
                ((L = {
                  ease: (P = R[u]).e,
                  duration: ((P.t - (u ? R[u - 1].t : 0)) / 100) * _,
                })[p] = P.v),
                  c.to(A, L, I),
                  (I += L.duration);
            c.duration() < _ && c.to({}, { duration: _ - c.duration() });
          }
        }
        _ || o.duration((_ = c.duration()));
      } else o.timeline = 0;
      return (
        !0 !== E || s || ((Ge = i(o)), l.killTweensOf(A), (Ge = 0)),
        Ht(C, i(o), r),
        n.reversed && o.reverse(),
        n.paused && o.paused(!0),
        (y ||
          (!_ &&
            !T &&
            o._start === _t(C._time) &&
            O(y) &&
            Nt(i(o)) &&
            "nested" !== C.data)) &&
          ((o._tTime = -1e-8), o.render(Math.max(0, -x) || 0)),
        D && Gt(i(o), D),
        o
      );
    }
    r(e, t);
    var n = e.prototype;
    return (
      (n.render = function (t, e, n) {
        var i,
          r,
          s,
          o,
          l,
          c,
          u,
          h,
          d,
          p = this._time,
          f = this._tDur,
          m = this._dur,
          g = t < 0,
          v = t > f - b && !g ? f : t < b ? 0 : t;
        if (m) {
          if (
            v !== this._tTime ||
            !t ||
            n ||
            (!this._initted && this._tTime) ||
            (this._startAt && this._zTime < 0 !== g)
          ) {
            if (((i = v), (h = this.timeline), this._repeat)) {
              if (((o = m + this._rDelay), this._repeat < -1 && g))
                return this.totalTime(100 * o + t, e, n);
              if (
                ((i = _t(v % o)),
                v === f
                  ? ((s = this._repeat), (i = m))
                  : ((s = ~~(v / o)) && s === _t(v / o) && ((i = m), s--),
                    i > m && (i = m)),
                (c = this._yoyo && 1 & s) && ((d = this._yEase), (i = m - i)),
                (l = Ot(this._tTime, o)),
                i === p && !n && this._initted && s === l)
              )
                return (this._tTime = v), this;
              s !== l &&
                (h && this._yEase && Ue(h, c),
                this.vars.repeatRefresh &&
                  !c &&
                  !this._lock &&
                  this._time !== o &&
                  this._initted &&
                  ((this._lock = n = 1),
                  (this.render(_t(o * s), !0).invalidate()._lock = 0)));
            }
            if (!this._initted) {
              if (Wt(this, g ? t : i, n, e, v)) return (this._tTime = 0), this;
              if (
                !(p === this._time || (n && this.vars.repeatRefresh && s !== l))
              )
                return this;
              if (m !== this._dur) return this.render(t, e, n);
            }
            if (
              ((this._tTime = v),
              (this._time = i),
              !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
              (this.ratio = u = (d || this._ease)(i / m)),
              this._from && (this.ratio = u = 1 - u),
              i && !p && !e && !s && (fe(this, "onStart"), this._tTime !== v))
            )
              return this;
            for (r = this._pt; r; ) r.r(u, r.d), (r = r._next);
            (h &&
              h.render(t < 0 ? t : h._dur * h._ease(i / this._dur), e, n)) ||
              (this._startAt && (this._zTime = t)),
              this._onUpdate &&
                !e &&
                (g && Ut(this, t, 0, n), fe(this, "onUpdate")),
              this._repeat &&
                s !== l &&
                this.vars.onRepeat &&
                !e &&
                this.parent &&
                fe(this, "onRepeat"),
              (v !== this._tDur && v) ||
                this._tTime !== v ||
                (g && !this._onUpdate && Ut(this, t, 0, !0),
                (t || !m) &&
                  ((v === this._tDur && this._ts > 0) ||
                    (!v && this._ts < 0)) &&
                  Lt(this, 1),
                e ||
                  (g && !p) ||
                  !(v || p || c) ||
                  (fe(this, v === f ? "onComplete" : "onReverseComplete", !0),
                  this._prom &&
                    !(v < f && this.timeScale() > 0) &&
                    this._prom()));
          }
        } else
          !(function (t, e, n, i) {
            var r,
              s,
              o,
              l = t.ratio,
              c =
                e < 0 ||
                (!e &&
                  ((!t._start && Xt(t) && (t._initted || !qt(t))) ||
                    ((t._ts < 0 || t._dp._ts < 0) && !qt(t))))
                  ? 0
                  : 1,
              u = t._rDelay,
              h = 0;
            if (
              (u &&
                t._repeat &&
                ((h = Qt(0, t._tDur, e)),
                (s = Ot(h, u)),
                t._yoyo && 1 & s && (c = 1 - c),
                s !== Ot(t._tTime, u) &&
                  ((l = 1 - c),
                  t.vars.repeatRefresh && t._initted && t.invalidate())),
              c !== l || a || i || t._zTime === b || (!e && t._zTime))
            ) {
              if (!t._initted && Wt(t, e, i, n, h)) return;
              for (
                o = t._zTime,
                  t._zTime = e || (n ? b : 0),
                  n || (n = e && !o),
                  t.ratio = c,
                  t._from && (c = 1 - c),
                  t._time = 0,
                  t._tTime = h,
                  r = t._pt;
                r;

              )
                r.r(c, r.d), (r = r._next);
              e < 0 && Ut(t, e, 0, !0),
                t._onUpdate && !n && fe(t, "onUpdate"),
                h && t._repeat && !n && t.parent && fe(t, "onRepeat"),
                (e >= t._tDur || e < 0) &&
                  t.ratio === c &&
                  (c && Lt(t, 1),
                  n ||
                    a ||
                    (fe(t, c ? "onComplete" : "onReverseComplete", !0),
                    t._prom && t._prom()));
            } else t._zTime || (t._zTime = e);
          })(this, t, e, n);
        return this;
      }),
      (n.targets = function () {
        return this._targets;
      }),
      (n.invalidate = function (e) {
        return (
          (!e || !this.vars.runBackwards) && (this._startAt = 0),
          (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
          (this._ptLookup = []),
          this.timeline && this.timeline.invalidate(e),
          t.prototype.invalidate.call(this, e)
        );
      }),
      (n.resetTo = function (t, e, n, i, r) {
        m || we.wake(), this._ts || this.play();
        var s = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
        return (
          this._initted || Ye(this, s),
          (function (t, e, n, i, r, s, a, o) {
            var l,
              c,
              u,
              h,
              d = ((t._pt && t._ptCache) || (t._ptCache = {}))[e];
            if (!d)
              for (
                d = t._ptCache[e] = [], u = t._ptLookup, h = t._targets.length;
                h--;

              ) {
                if ((l = u[h][e]) && l.d && l.d._pt)
                  for (l = l.d._pt; l && l.p !== e && l.fp !== e; ) l = l._next;
                if (!l)
                  return (
                    (We = 1),
                    (t.vars[e] = "+=0"),
                    Ye(t, a),
                    (We = 0),
                    o ? Q(e + " not eligible for reset") : 1
                  );
                d.push(l);
              }
            for (h = d.length; h--; )
              ((l = (c = d[h])._pt || c).s =
                (!i && 0 !== i) || r ? l.s + (i || 0) + s * l.c : i),
                (l.c = n - l.s),
                c.e && (c.e = vt(n) + te(c.e)),
                c.b && (c.b = l.s + te(c.b));
          })(this, t, e, n, i, this._ease(s / this._dur), s, r)
            ? this.resetTo(t, e, n, i, 1)
            : (kt(this, 0),
              this.parent ||
                Rt(
                  this._dp,
                  this,
                  "_first",
                  "_last",
                  this._dp._sort ? "_start" : 0
                ),
              this.render(0))
        );
      }),
      (n.kill = function (t, e) {
        if ((void 0 === e && (e = "all"), !(t || (e && "all" !== e))))
          return (this._lazy = this._pt = 0), this.parent ? me(this) : this;
        if (this.timeline) {
          var n = this.timeline.totalDuration();
          return (
            this.timeline.killTweensOf(t, e, Ge && !0 !== Ge.vars.overwrite)
              ._first || me(this),
            this.parent &&
              n !== this.timeline.totalDuration() &&
              jt(this, (this._dur * this.timeline._tDur) / n, 0, 1),
            this
          );
        }
        var i,
          r,
          s,
          a,
          o,
          l,
          c,
          u = this._targets,
          h = t ? ie(t) : u,
          d = this._ptLookup,
          p = this._pt;
        if (
          (!e || "all" === e) &&
          (function (t, e) {
            for (
              var n = t.length, i = n === e.length;
              i && n-- && t[n] === e[n];

            );
            return n < 0;
          })(u, h)
        )
          return "all" === e && (this._pt = 0), me(this);
        for (
          i = this._op = this._op || [],
            "all" !== e &&
              (L(e) &&
                ((o = {}),
                gt(e, function (t) {
                  return (o[t] = 1);
                }),
                (e = o)),
              (e = (function (t, e) {
                var n,
                  i,
                  r,
                  s,
                  a = t[0] ? ft(t[0]).harness : 0,
                  o = a && a.aliases;
                if (!o) return e;
                for (i in ((n = Dt({}, e)), o))
                  if ((i in n))
                    for (r = (s = o[i].split(",")).length; r--; )
                      n[s[r]] = n[i];
                return n;
              })(u, e))),
            c = u.length;
          c--;

        )
          if (~h.indexOf(u[c]))
            for (o in ((r = d[c]),
            "all" === e
              ? ((i[c] = e), (a = r), (s = {}))
              : ((s = i[c] = i[c] || {}), (a = e)),
            a))
              (l = r && r[o]) &&
                (("kill" in l.d && !0 !== l.d.kill(o)) || Pt(this, l, "_pt"),
                delete r[o]),
                "all" !== s && (s[o] = 1);
        return this._initted && !this._pt && p && me(this), this;
      }),
      (e.to = function (t, n) {
        return new e(t, n, arguments[2]);
      }),
      (e.from = function (t, e) {
        return Jt(1, arguments);
      }),
      (e.delayedCall = function (t, n, i, r) {
        return new e(n, 0, {
          immediateRender: !1,
          lazy: !1,
          overwrite: !1,
          delay: t,
          onComplete: n,
          onReverseComplete: n,
          onCompleteParams: i,
          onReverseCompleteParams: i,
          callbackScope: r,
        });
      }),
      (e.fromTo = function (t, e, n) {
        return Jt(2, arguments);
      }),
      (e.set = function (t, n) {
        return (n.duration = 0), n.repeatDelay || (n.repeat = 0), new e(t, n);
      }),
      (e.killTweensOf = function (t, e, n) {
        return l.killTweensOf(t, e, n);
      }),
      e
    );
  })(Ve);
  bt(Qe.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }),
    gt("staggerTo,staggerFrom,staggerFromTo", function (t) {
      Qe[t] = function () {
        var e = new He(),
          n = ee.call(arguments, 0);
        return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n);
      };
    });
  var tn = function (t, e, n) {
      return (t[e] = n);
    },
    en = function (t, e, n) {
      return t[e](n);
    },
    nn = function (t, e, n, i) {
      return t[e](i.fp, n);
    },
    rn = function (t, e, n) {
      return t.setAttribute(e, n);
    },
    sn = function (t, e) {
      return I(t[e]) ? en : N(t[e]) && t.setAttribute ? rn : tn;
    },
    an = function (t, e) {
      return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e);
    },
    on = function (t, e) {
      return e.set(e.t, e.p, !!(e.s + e.c * t), e);
    },
    ln = function (t, e) {
      var n = e._pt,
        i = "";
      if (!t && e.b) i = e.b;
      else if (1 === t && e.e) i = e.e;
      else {
        for (; n; )
          (i =
            n.p +
            (n.m
              ? n.m(n.s + n.c * t)
              : Math.round(1e4 * (n.s + n.c * t)) / 1e4) +
            i),
            (n = n._next);
        i += e.c;
      }
      e.set(e.t, e.p, i, e);
    },
    cn = function (t, e) {
      for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
    },
    un = function (t, e, n, i) {
      for (var r, s = this._pt; s; )
        (r = s._next), s.p === i && s.modifier(t, e, n), (s = r);
    },
    hn = function (t) {
      for (var e, n, i = this._pt; i; )
        (n = i._next),
          (i.p === t && !i.op) || i.op === t
            ? Pt(this, i, "_pt")
            : i.dep || (e = 1),
          (i = n);
      return !e;
    },
    dn = function (t, e, n, i) {
      i.mSet(t, e, i.m.call(i.tween, n, i.mt), i);
    },
    pn = function (t) {
      for (var e, n, i, r, s = t._pt; s; ) {
        for (e = s._next, n = i; n && n.pr > s.pr; ) n = n._next;
        (s._prev = n ? n._prev : r) ? (s._prev._next = s) : (i = s),
          (s._next = n) ? (n._prev = s) : (r = s),
          (s = e);
      }
      t._pt = i;
    },
    fn = (function () {
      function t(t, e, n, i, r, s, a, o, l) {
        (this.t = e),
          (this.s = i),
          (this.c = r),
          (this.p = n),
          (this.r = s || an),
          (this.d = a || this),
          (this.set = o || tn),
          (this.pr = l || 0),
          (this._next = t),
          t && (t._prev = this);
      }
      return (
        (t.prototype.modifier = function (t, e, n) {
          (this.mSet = this.mSet || this.set),
            (this.set = dn),
            (this.m = t),
            (this.mt = n),
            (this.tween = e);
        }),
        t
      );
    })();
  gt(
    dt +
      "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
    function (t) {
      return (st[t] = 1);
    }
  ),
    (K.TweenMax = K.TweenLite = Qe),
    (K.TimelineLite = K.TimelineMax = He),
    (l = new He({
      sortChildren: !1,
      defaults: E,
      autoRemoveChildren: !0,
      id: "root",
      smoothChildTiming: !0,
    })),
    (M.stringFilter = De);
  var mn = [],
    gn = {},
    vn = [],
    _n = 0,
    xn = 0,
    yn = function (t) {
      return (gn[t] || vn).map(function (t) {
        return t();
      });
    },
    Sn = function () {
      var t = Date.now(),
        e = [];
      t - _n > 2 &&
        (yn("matchMediaInit"),
        mn.forEach(function (t) {
          var n,
            i,
            r,
            s,
            a = t.queries,
            o = t.conditions;
          for (i in a)
            (n = c.matchMedia(a[i]).matches) && (r = 1),
              n !== o[i] && ((o[i] = n), (s = 1));
          s && (t.revert(), r && e.push(t));
        }),
        yn("matchMediaRevert"),
        e.forEach(function (t) {
          return t.onMatch(t, function (e) {
            return t.add(null, e);
          });
        }),
        (_n = t),
        yn("matchMedia"));
    },
    Mn = (function () {
      function t(t, e) {
        (this.selector = e && re(e)),
          (this.data = []),
          (this._r = []),
          (this.isReverted = !1),
          (this.id = xn++),
          t && this.add(t);
      }
      var e = t.prototype;
      return (
        (e.add = function (t, e, n) {
          I(t) && ((n = e), (e = t), (t = I));
          var i = this,
            r = function () {
              var t,
                r = o,
                s = i.selector;
              return (
                r && r !== i && r.data.push(i),
                n && (i.selector = re(n)),
                (o = i),
                (t = e.apply(i, arguments)),
                I(t) && i._r.push(t),
                (o = r),
                (i.selector = s),
                (i.isReverted = !1),
                t
              );
            };
          return (
            (i.last = r),
            t === I
              ? r(i, function (t) {
                  return i.add(null, t);
                })
              : t
              ? (i[t] = r)
              : r
          );
        }),
        (e.ignore = function (t) {
          var e = o;
          (o = null), t(this), (o = e);
        }),
        (e.getTweens = function () {
          var e = [];
          return (
            this.data.forEach(function (n) {
              return n instanceof t
                ? e.push.apply(e, n.getTweens())
                : n instanceof Qe &&
                    !(n.parent && "nested" === n.parent.data) &&
                    e.push(n);
            }),
            e
          );
        }),
        (e.clear = function () {
          this._r.length = this.data.length = 0;
        }),
        (e.kill = function (t, e) {
          var n = this;
          if (
            (t
              ? (function () {
                  for (var e, i = n.getTweens(), r = n.data.length; r--; )
                    "isFlip" === (e = n.data[r]).data &&
                      (e.revert(),
                      e.getChildren(!0, !0, !1).forEach(function (t) {
                        return i.splice(i.indexOf(t), 1);
                      }));
                  for (
                    i
                      .map(function (t) {
                        return {
                          g:
                            t._dur ||
                            t._delay ||
                            (t._sat && !t._sat.vars.immediateRender)
                              ? t.globalTime(0)
                              : -1 / 0,
                          t,
                        };
                      })
                      .sort(function (t, e) {
                        return e.g - t.g || -1 / 0;
                      })
                      .forEach(function (e) {
                        return e.t.revert(t);
                      }),
                      r = n.data.length;
                    r--;

                  )
                
                  n._r.forEach(function (e) {
                    return e(t, n);
                  }),
                    (n.isReverted = !0);
                })()
              : this.data.forEach(function (t) {
                  return t.kill && t.kill();
                }),
            this.clear(),
            e)
          )
            for (var i = mn.length; i--; )
              mn[i].id === this.id && mn.splice(i, 1);
        }),
        (e.revert = function (t) {
          this.kill(t || {});
        }),
        t
      );
    })(),
    En = (function () {
      function t(t) {
        (this.contexts = []), (this.scope = t), o && o.data.push(this);
      }
      var e = t.prototype;
      return (
        (e.add = function (t, e, n) {
          F(t) || (t = { matches: t });
          var i,
            r,
            s,
            a = new Mn(0, n || this.scope),
            l = (a.conditions = {});
          for (r in (o && !a.selector && (a.selector = o.selector),
          this.contexts.push(a),
          (e = a.add("onMatch", e)),
          (a.queries = t),
          t))
            "all" === r
              ? (s = 1)
              : (i = c.matchMedia(t[r])) &&
                (mn.indexOf(a) < 0 && mn.push(a),
                (l[r] = i.matches) && (s = 1),
                i.addListener
                  ? i.addListener(Sn)
                  : i.addEventListener("change", Sn));
          return (
            s &&
              e(a, function (t) {
                return a.add(null, t);
              }),
            this
          );
        }),
        (e.revert = function (t) {
          this.kill(t || {});
        }),
        (e.kill = function (t) {
          this.contexts.forEach(function (e) {
            return e.kill(t, !0);
          });
        }),
        t
      );
    })(),
    Tn = {
      registerPlugin: function () {
        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
          e[n] = arguments[n];
        e.forEach(function (t) {
          return ve(t);
        });
      },
      timeline: function (t) {
        return new He(t);
      },
      getTweensOf: function (t, e) {
        return l.getTweensOf(t, e);
      },
      getProperty: function (t, e, n, i) {
        L(t) && (t = ie(t)[0]);
        var r = ft(t || {}).get,
          s = n ? Tt : Et;
        return (
          "native" === n && (n = ""),
          t
            ? e
              ? s(((lt[e] && lt[e].get) || r)(t, e, n, i))
              : function (e, n, i) {
                  return s(((lt[e] && lt[e].get) || r)(t, e, n, i));
                }
            : t
        );
      },
      quickSetter: function (t, e, n) {
        if ((t = ie(t)).length > 1) {
          var i = t.map(function (t) {
              return wn.quickSetter(t, e, n);
            }),
            r = i.length;
          return function (t) {
            for (var e = r; e--; ) i[e](t);
          };
        }
        t = t[0] || {};
        var s = lt[e],
          a = ft(t),
          o = (a.harness && (a.harness.aliases || {})[e]) || e,
          l = s
            ? function (e) {
                var i = new s();
                (f._pt = 0),
                  i.init(t, n ? e + n : e, f, 0, [t]),
                  i.render(1, i),
                  f._pt && cn(1, f);
              }
            : a.set(t, o);
        return s
          ? l
          : function (e) {
              return l(t, o, n ? e + n : e, a, 1);
            };
      },
      quickTo: function (t, e, n) {
        var i,
          r = wn.to(
            t,
            Dt((((i = {})[e] = "+=0.1"), (i.paused = !0), i), n || {})
          ),
          s = function (t, n, i) {
            return r.resetTo(e, t, n, i);
          };
        return (s.tween = r), s;
      },
      isTweening: function (t) {
        return l.getTweensOf(t, !0).length > 0;
      },
      defaults: function (t) {
        return t && t.ease && (t.ease = Ne(t.ease, E.ease)), wt(E, t || {});
      },
      config: function (t) {
        return wt(M, t || {});
      },
      registerEffect: function (t) {
        var e = t.name,
          n = t.effect,
          i = t.plugins,
          r = t.defaults,
          s = t.extendTimeline;
        (i || "").split(",").forEach(function (t) {
          return (
            t && !lt[t] && !K[t] && Q(e + " effect requires " + t + " plugin.")
          );
        }),
          (ct[e] = function (t, e, i) {
            return n(ie(t), bt(e || {}, r), i);
          }),
          s &&
            (He.prototype[e] = function (t, n, i) {
              return this.add(ct[e](t, F(n) ? n : (i = n) && {}, this), i);
            });
      },
      registerEase: function (t, e) {
        Ae[t] = Ne(e);
      },
      parseEase: function (t, e) {
        return arguments.length ? Ne(t, e) : Ae;
      },
      getById: function (t) {
        return l.getById(t);
      },
      exportRoot: function (t, e) {
        void 0 === t && (t = {});
        var n,
          i,
          r = new He(t);
        for (
          r.smoothChildTiming = O(t.smoothChildTiming),
            l.remove(r),
            r._dp = 0,
            r._time = r._tTime = l._time,
            n = l._first;
          n;

        )
          (i = n._next),
            (!e &&
              !n._dur &&
              n instanceof Qe &&
              n.vars.onComplete === n._targets[0]) ||
              Ht(r, n, n._start - n._delay),
            (n = i);
        return Ht(l, r, 0), r;
      },
      context: function (t, e) {
        return t ? new Mn(t, e) : o;
      },
      matchMedia: function (t) {
        return new En(t);
      },
      matchMediaRefresh: function () {
        return (
          mn.forEach(function (t) {
            var e,
              n,
              i = t.conditions;
            for (n in i) i[n] && ((i[n] = !1), (e = 1));
            e && t.revert();
          }) || Sn()
        );
      },
      addEventListener: function (t, e) {
        var n = gn[t] || (gn[t] = []);
        ~n.indexOf(e) || n.push(e);
      },
      removeEventListener: function (t, e) {
        var n = gn[t],
          i = n && n.indexOf(e);
        i >= 0 && n.splice(i, 1);
      },
      utils: {
        wrap: function t(e, n, i) {
          var r = n - e;
          return V(e)
            ? ue(e, t(0, e.length), n)
            : $t(i, function (t) {
                return ((r + ((t - e) % r)) % r) + e;
              });
        },
        wrapYoyo: function t(e, n, i) {
          var r = n - e,
            s = 2 * r;
          return V(e)
            ? ue(e, t(0, e.length - 1), n)
            : $t(i, function (t) {
                return e + ((t = (s + ((t - e) % s)) % s || 0) > r ? s - t : t);
              });
        },
        distribute: ae,
        random: ce,
        snap: le,
        normalize: function (t, e, n) {
          return de(t, e, 0, 1, n);
        },
        getUnit: te,
        clamp: function (t, e, n) {
          return $t(n, function (n) {
            return Qt(t, e, n);
          });
        },
        splitColor: Se,
        toArray: ie,
        selector: re,
        mapRange: de,
        pipe: function () {
          for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
            e[n] = arguments[n];
          return function (t) {
            return e.reduce(function (t, e) {
              return e(t);
            }, t);
          };
        },
        unitize: function (t, e) {
          return function (n) {
            return t(parseFloat(n)) + (e || te(n));
          };
        },
        interpolate: function t(e, n, i, r) {
          var s = isNaN(e + n)
            ? 0
            : function (t) {
                return (1 - t) * e + t * n;
              };
          if (!s) {
            var a,
              o,
              l,
              c,
              u,
              h = L(e),
              d = {};
            if ((!0 === i && (r = 1) && (i = null), h))
              (e = { p: e }), (n = { p: n });
            else if (V(e) && !V(n)) {
              for (l = [], c = e.length, u = c - 2, o = 1; o < c; o++)
                l.push(t(e[o - 1], e[o]));
              c--,
                (s = function (t) {
                  t *= c;
                  var e = Math.min(u, ~~t);
                  return l[e](t - e);
                }),
                (i = n);
            } else r || (e = Dt(V(e) ? [] : {}, e));
            if (!l) {
              for (a in n) qe.call(d, e, a, "get", n[a]);
              s = function (t) {
                return cn(t, d) || (h ? e.p : e);
              };
            }
          }
          return $t(i, s);
        },
        shuffle: se,
      },
      install: J,
      effects: ct,
      ticker: we,
      updateRoot: He.updateRoot,
      plugins: lt,
      globalTimeline: l,
      core: {
        PropTween: fn,
        globals: tt,
        Tween: Qe,
        Timeline: He,
        Animation: Ve,
        getCache: ft,
        _removeLinkedListItem: Pt,
        reverting: function () {
          return a;
        },
        context: function (t) {
          return t && o && (o.data.push(t), (t._ctx = o)), o;
        },
        suppressOverwrites: function (t) {
          return (s = t);
        },
      },
    };
  gt("to,from,fromTo,delayedCall,set,killTweensOf", function (t) {
    return (Tn[t] = Qe[t]);
  }),
    we.add(He.updateRoot),
    (f = Tn.to({}, { duration: 0 }));
  var bn = function (t, e) {
      for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
        n = n._next;
      return n;
    },
    Dn = function (t, e) {
      return {
        name: t,
        rawVars: 1,
        init: function (t, n, i) {
          i._onInit = function (t) {
            var i, r;
            if (
              (L(n) &&
                ((i = {}),
                gt(n, function (t) {
                  return (i[t] = 1);
                }),
                (n = i)),
              e)
            ) {
              for (r in ((i = {}), n)) i[r] = e(n[r]);
              n = i;
            }
            !(function (t, e) {
              var n,
                i,
                r,
                s = t._targets;
              for (n in e)
                for (i = s.length; i--; )
                  (r = t._ptLookup[i][n]) &&
                    (r = r.d) &&
                    (r._pt && (r = bn(r, n)),
                    r && r.modifier && r.modifier(e[n], t, s[i], n));
            })(t, n);
          };
        },
      };
    },
    wn =
      Tn.registerPlugin(
        {
          name: "attr",
          init: function (t, e, n, i, r) {
            var s, a, o;
            for (s in ((this.tween = n), e))
              (o = t.getAttribute(s) || ""),
                ((a = this.add(
                  t,
                  "setAttribute",
                  (o || 0) + "",
                  e[s],
                  i,
                  r,
                  0,
                  0,
                  s
                )).op = s),
                (a.b = o),
                this._props.push(s);
          },
          render: function (t, e) {
            for (var n = e._pt; n; )
              a ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), (n = n._next);
          },
        },
        {
          name: "endArray",
          init: function (t, e) {
            for (var n = e.length; n--; )
              this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1);
          },
        },
        Dn("roundProps", oe),
        Dn("modifiers"),
        Dn("snap", le)
      ) || Tn;
  (Qe.version = He.version = wn.version = "3.12.5"),
    (d = 1),
    B() && Ce(),
    Ae.Power0,
    Ae.Power1,
    Ae.Power2,
    Ae.Power3,
    Ae.Power4,
    Ae.Linear,
    Ae.Quad,
    Ae.Cubic,
    Ae.Quart,
    Ae.Quint,
    Ae.Strong,
    Ae.Elastic,
    Ae.Back,
    Ae.SteppedEase,
    Ae.Bounce,
    Ae.Sine,
    Ae.Expo,
    Ae.Circ;
  var Cn,
    An,
    Rn,
    Pn,
    Ln,
    In,
    Un,
    Nn,
    Fn = {},
    On = 180 / Math.PI,
    Bn = Math.PI / 180,
    zn = Math.atan2,
    kn = /([A-Z])/g,
    Vn = /(left|right|width|margin|padding|x)/i,
    Hn = /[\s,\(]\S/,
    Gn = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity",
    },
    Wn = function (t, e) {
      return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e);
    },
    Xn = function (t, e) {
      return e.set(
        e.t,
        e.p,
        1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
        e
      );
    },
    qn = function (t, e) {
      return e.set(
        e.t,
        e.p,
        t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b,
        e
      );
    },
    jn = function (t, e) {
      var n = e.s + e.c * t;
      e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e);
    },
    Yn = function (t, e) {
      return e.set(e.t, e.p, t ? e.e : e.b, e);
    },
    Kn = function (t, e) {
      return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e);
    },
    Zn = function (t, e, n) {
      return (t.style[e] = n);
    },
    Jn = function (t, e, n) {
      return t.style.setProperty(e, n);
    },
    $n = function (t, e, n) {
      return (t._gsap[e] = n);
    },
    Qn = function (t, e, n) {
      return (t._gsap.scaleX = t._gsap.scaleY = n);
    },
    ti = function (t, e, n, i, r) {
      var s = t._gsap;
      (s.scaleX = s.scaleY = n), s.renderTransform(r, s);
    },
    ei = function (t, e, n, i, r) {
      var s = t._gsap;
      (s[e] = n), s.renderTransform(r, s);
    },
    ni = "transform",
    ii = ni + "Origin",
    ri = function t(e, n) {
      var i = this,
        r = this.target,
        s = r.style,
        a = r._gsap;
      if (e in Fn && s) {
        if (((this.tfm = this.tfm || {}), "transform" === e))
          return Gn.transform.split(",").forEach(function (e) {
            return t.call(i, e, n);
          });
        if (
          (~(e = Gn[e] || e).indexOf(",")
            ? e.split(",").forEach(function (t) {
                return (i.tfm[t] = Mi(r, t));
              })
            : (this.tfm[e] = a.x ? a[e] : Mi(r, e)),
          e === ii && (this.tfm.zOrigin = a.zOrigin),
          this.props.indexOf(ni) >= 0)
        )
          return;
        a.svg &&
          ((this.svgo = r.getAttribute("data-svg-origin")),
          this.props.push(ii, n, "")),
          (e = ni);
      }
      (s || n) && this.props.push(e, n, s[e]);
    },
    si = function (t) {
      t.translate &&
        (t.removeProperty("translate"),
        t.removeProperty("scale"),
        t.removeProperty("rotate"));
    },
    ai = function () {
      var t,
        e,
        n = this.props,
        i = this.target,
        r = i.style,
        s = i._gsap;
      for (t = 0; t < n.length; t += 3)
        n[t + 1]
          ? (i[n[t]] = n[t + 2])
          : n[t + 2]
          ? (r[n[t]] = n[t + 2])
          : r.removeProperty(
              "--" === n[t].substr(0, 2)
                ? n[t]
                : n[t].replace(kn, "-$1").toLowerCase()
            );
      if (this.tfm) {
        for (e in this.tfm) s[e] = this.tfm[e];
        s.svg &&
          (s.renderTransform(),
          i.setAttribute("data-svg-origin", this.svgo || "")),
          ((t = Un()) && t.isStart) ||
            r[ni] ||
            (si(r),
            s.zOrigin &&
              r[ii] &&
              ((r[ii] += " " + s.zOrigin + "px"),
              (s.zOrigin = 0),
              s.renderTransform()),
            (s.uncache = 1));
      }
    },
    oi = function (t, e) {
      var n = { target: t, props: [], revert: ai, save: ri };
      return (
        t._gsap || wn.core.getCache(t),
        e &&
          e.split(",").forEach(function (t) {
            return n.save(t);
          }),
        n
      );
    },
    li = function (t, e) {
      var n = An.createElementNS
        ? An.createElementNS(
            (e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
            t
          )
        : An.createElement(t);
      return n && n.style ? n : An.createElement(t);
    },
    ci = function t(e, n, i) {
      var r = getComputedStyle(e);
      return (
        r[n] ||
        r.getPropertyValue(n.replace(kn, "-$1").toLowerCase()) ||
        r.getPropertyValue(n) ||
        (!i && t(e, hi(n) || n, 1)) ||
        ""
      );
    },
    ui = "O,Moz,ms,Ms,Webkit".split(","),
    hi = function (t, e, n) {
      var i = (e || Ln).style,
        r = 5;
      if (t in i && !n) return t;
      for (
        t = t.charAt(0).toUpperCase() + t.substr(1);
        r-- && !(ui[r] + t in i);

      );
      return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? ui[r] : "") + t;
    },
    di = function () {
      "undefined" != typeof window &&
        window.document &&
        ((Cn = window),
        (An = Cn.document),
        (Rn = An.documentElement),
        (Ln = li("div") || { style: {} }),
        li("div"),
        (ni = hi(ni)),
        (ii = ni + "Origin"),
        (Ln.style.cssText =
          "border-width:0;line-height:0;position:absolute;padding:0"),
        (Nn = !!hi("perspective")),
        (Un = wn.core.reverting),
        (Pn = 1));
    },
    pi = function t(e) {
      var n,
        i = li(
          "svg",
          (this.ownerSVGElement &&
            this.ownerSVGElement.getAttribute("xmlns")) ||
            "http://www.w3.org/2000/svg"
        ),
        r = this.parentNode,
        s = this.nextSibling,
        a = this.style.cssText;
      if (
        (Rn.appendChild(i),
        i.appendChild(this),
        (this.style.display = "block"),
        e)
      )
        try {
          (n = this.getBBox()),
            (this._gsapBBox = this.getBBox),
            (this.getBBox = t);
        } catch (t) {}
      else this._gsapBBox && (n = this._gsapBBox());
      return (
        r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
        Rn.removeChild(i),
        (this.style.cssText = a),
        n
      );
    },
    fi = function (t, e) {
      for (var n = e.length; n--; )
        if (t.hasAttribute(e[n])) return t.getAttribute(e[n]);
    },
    mi = function (t) {
      var e;
      try {
        e = t.getBBox();
      } catch (n) {
        e = pi.call(t, !0);
      }
      return (
        (e && (e.width || e.height)) ||
          t.getBBox === pi ||
          (e = pi.call(t, !0)),
        !e || e.width || e.x || e.y
          ? e
          : {
              x: +fi(t, ["x", "cx", "x1"]) || 0,
              y: +fi(t, ["y", "cy", "y1"]) || 0,
              width: 0,
              height: 0,
            }
      );
    },
    gi = function (t) {
      return !(!t.getCTM || (t.parentNode && !t.ownerSVGElement) || !mi(t));
    },
    vi = function (t, e) {
      if (e) {
        var n,
          i = t.style;
        e in Fn && e !== ii && (e = ni),
          i.removeProperty
            ? (("ms" !== (n = e.substr(0, 2)) && "webkit" !== e.substr(0, 6)) ||
                (e = "-" + e),
              i.removeProperty(
                "--" === n ? e : e.replace(kn, "-$1").toLowerCase()
              ))
            : i.removeAttribute(e);
      }
    },
    _i = function (t, e, n, i, r, s) {
      var a = new fn(t._pt, e, n, 0, 1, s ? Kn : Yn);
      return (t._pt = a), (a.b = i), (a.e = r), t._props.push(n), a;
    },
    xi = { deg: 1, rad: 1, turn: 1 },
    yi = { grid: 1, flex: 1 },
    Si = function t(e, n, i, r) {
      var s,
        a,
        o,
        l,
        c = parseFloat(i) || 0,
        u = (i + "").trim().substr((c + "").length) || "px",
        h = Ln.style,
        d = Vn.test(n),
        p = "svg" === e.tagName.toLowerCase(),
        f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
        m = 100,
        g = "px" === r,
        v = "%" === r;
      if (r === u || !c || xi[r] || xi[u]) return c;
      if (
        ("px" !== u && !g && (c = t(e, n, i, "px")),
        (l = e.getCTM && gi(e)),
        (v || "%" === u) && (Fn[n] || ~n.indexOf("adius")))
      )
        return (
          (s = l ? e.getBBox()[d ? "width" : "height"] : e[f]),
          vt(v ? (c / s) * m : (c / 100) * s)
        );
      if (
        ((h[d ? "width" : "height"] = m + (g ? u : r)),
        (a =
          ~n.indexOf("adius") || ("em" === r && e.appendChild && !p)
            ? e
            : e.parentNode),
        l && (a = (e.ownerSVGElement || {}).parentNode),
        (a && a !== An && a.appendChild) || (a = An.body),
        (o = a._gsap) && v && o.width && d && o.time === we.time && !o.uncache)
      )
        return vt((c / o.width) * m);
      if (!v || ("height" !== n && "width" !== n))
        (v || "%" === u) &&
          !yi[ci(a, "display")] &&
          (h.position = ci(e, "position")),
          a === e && (h.position = "static"),
          a.appendChild(Ln),
          (s = Ln[f]),
          a.removeChild(Ln),
          (h.position = "absolute");
      else {
        var _ = e.style[n];
        (e.style[n] = m + r), (s = e[f]), _ ? (e.style[n] = _) : vi(e, n);
      }
      return (
        d && v && (((o = ft(a)).time = we.time), (o.width = a[f])),
        vt(g ? (s * c) / m : s && c ? (m / s) * c : 0)
      );
    },
    Mi = function (t, e, n, i) {
      var r;
      return (
        Pn || di(),
        e in Gn &&
          "transform" !== e &&
          ~(e = Gn[e]).indexOf(",") &&
          (e = e.split(",")[0]),
        Fn[e] && "transform" !== e
          ? ((r = Ii(t, i)),
            (r =
              "transformOrigin" !== e
                ? r[e]
                : r.svg
                ? r.origin
                : Ui(ci(t, ii)) + " " + r.zOrigin + "px"))
          : (!(r = t.style[e]) ||
              "auto" === r ||
              i ||
              ~(r + "").indexOf("calc(")) &&
            (r =
              (Di[e] && Di[e](t, e, n)) ||
              ci(t, e) ||
              mt(t, e) ||
              ("opacity" === e ? 1 : 0)),
        n && !~(r + "").trim().indexOf(" ") ? Si(t, e, r, n) + n : r
      );
    },
    Ei = function (t, e, n, i) {
      if (!n || "none" === n) {
        var r = hi(e, t, 1),
          s = r && ci(t, r, 1);
        s && s !== n
          ? ((e = r), (n = s))
          : "borderColor" === e && (n = ci(t, "borderTopColor"));
      }
      var a,
        o,
        l,
        c,
        u,
        h,
        d,
        p,
        f,
        m,
        g,
        v = new fn(this._pt, t.style, e, 0, 1, ln),
        _ = 0,
        x = 0;
      if (
        ((v.b = n),
        (v.e = i),
        (n += ""),
        "auto" == (i += "") &&
          ((h = t.style[e]),
          (t.style[e] = i),
          (i = ci(t, e) || i),
          h ? (t.style[e] = h) : vi(t, e)),
        De((a = [n, i])),
        (i = a[1]),
        (l = (n = a[0]).match(W) || []),
        (i.match(W) || []).length)
      ) {
        for (; (o = W.exec(i)); )
          (d = o[0]),
            (f = i.substring(_, o.index)),
            u
              ? (u = (u + 1) % 5)
              : ("rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5)) ||
                (u = 1),
            d !== (h = l[x++] || "") &&
              ((c = parseFloat(h) || 0),
              (g = h.substr((c + "").length)),
              "=" === d.charAt(1) && (d = xt(c, d) + g),
              (p = parseFloat(d)),
              (m = d.substr((p + "").length)),
              (_ = W.lastIndex - m.length),
              m ||
                ((m = m || M.units[e] || g),
                _ === i.length && ((i += m), (v.e += m))),
              g !== m && (c = Si(t, e, h, m) || 0),
              (v._pt = {
                _next: v._pt,
                p: f || 1 === x ? f : ",",
                s: c,
                c: p - c,
                m: (u && u < 4) || "zIndex" === e ? Math.round : 0,
              }));
        v.c = _ < i.length ? i.substring(_, i.length) : "";
      } else v.r = "display" === e && "none" === i ? Kn : Yn;
      return q.test(i) && (v.e = 0), (this._pt = v), v;
    },
    Ti = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%",
    },
    bi = function (t, e) {
      if (e.tween && e.tween._time === e.tween._dur) {
        var n,
          i,
          r,
          s = e.t,
          a = s.style,
          o = e.u,
          l = s._gsap;
        if ("all" === o || !0 === o) (a.cssText = ""), (i = 1);
        else
          for (r = (o = o.split(",")).length; --r > -1; )
            (n = o[r]),
              Fn[n] && ((i = 1), (n = "transformOrigin" === n ? ii : ni)),
              vi(s, n);
        i &&
          (vi(s, ni),
          l &&
            (l.svg && s.removeAttribute("transform"),
            Ii(s, 1),
            (l.uncache = 1),
            si(a)));
      }
    },
    Di = {
      clearProps: function (t, e, n, i, r) {
        if ("isFromStart" !== r.data) {
          var s = (t._pt = new fn(t._pt, e, n, 0, 0, bi));
          return (s.u = i), (s.pr = -10), (s.tween = r), t._props.push(n), 1;
        }
      },
    },
    wi = [1, 0, 0, 1, 0, 0],
    Ci = {},
    Ai = function (t) {
      return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t;
    },
    Ri = function (t) {
      var e = ci(t, ni);
      return Ai(e) ? wi : e.substr(7).match(G).map(vt);
    },
    Pi = function (t, e) {
      var n,
        i,
        r,
        s,
        a = t._gsap || ft(t),
        o = t.style,
        l = Ri(t);
      return a.svg && t.getAttribute("transform")
        ? "1,0,0,1,0,0" ===
          (l = [
            (r = t.transform.baseVal.consolidate().matrix).a,
            r.b,
            r.c,
            r.d,
            r.e,
            r.f,
          ]).join(",")
          ? wi
          : l
        : (l !== wi ||
            t.offsetParent ||
            t === Rn ||
            a.svg ||
            ((r = o.display),
            (o.display = "block"),
            ((n = t.parentNode) && t.offsetParent) ||
              ((s = 1), (i = t.nextElementSibling), Rn.appendChild(t)),
            (l = Ri(t)),
            r ? (o.display = r) : vi(t, "display"),
            s &&
              (i
                ? n.insertBefore(t, i)
                : n
                ? n.appendChild(t)
                : Rn.removeChild(t))),
          e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l);
    },
    Li = function (t, e, n, i, r, s) {
      var a,
        o,
        l,
        c = t._gsap,
        u = r || Pi(t, !0),
        h = c.xOrigin || 0,
        d = c.yOrigin || 0,
        p = c.xOffset || 0,
        f = c.yOffset || 0,
        m = u[0],
        g = u[1],
        v = u[2],
        _ = u[3],
        x = u[4],
        y = u[5],
        S = e.split(" "),
        M = parseFloat(S[0]) || 0,
        E = parseFloat(S[1]) || 0;
      n
        ? u !== wi &&
          (o = m * _ - g * v) &&
          ((l = M * (-g / o) + E * (m / o) - (m * y - g * x) / o),
          (M = M * (_ / o) + E * (-v / o) + (v * y - _ * x) / o),
          (E = l))
        : ((M = (a = mi(t)).x + (~S[0].indexOf("%") ? (M / 100) * a.width : M)),
          (E =
            a.y + (~(S[1] || S[0]).indexOf("%") ? (E / 100) * a.height : E))),
        i || (!1 !== i && c.smooth)
          ? ((x = M - h),
            (y = E - d),
            (c.xOffset = p + (x * m + y * v) - x),
            (c.yOffset = f + (x * g + y * _) - y))
          : (c.xOffset = c.yOffset = 0),
        (c.xOrigin = M),
        (c.yOrigin = E),
        (c.smooth = !!i),
        (c.origin = e),
        (c.originIsAbsolute = !!n),
        (t.style[ii] = "0px 0px"),
        s &&
          (_i(s, c, "xOrigin", h, M),
          _i(s, c, "yOrigin", d, E),
          _i(s, c, "xOffset", p, c.xOffset),
          _i(s, c, "yOffset", f, c.yOffset)),
        t.setAttribute("data-svg-origin", M + " " + E);
    },
    Ii = function (t, e) {
      var n = t._gsap || new ke(t);
      if ("x" in n && !e && !n.uncache) return n;
      var i,
        r,
        s,
        a,
        o,
        l,
        c,
        u,
        h,
        d,
        p,
        f,
        m,
        g,
        v,
        _,
        x,
        y,
        S,
        E,
        T,
        b,
        D,
        w,
        C,
        A,
        R,
        P,
        L,
        I,
        U,
        N,
        F = t.style,
        O = n.scaleX < 0,
        B = "px",
        z = "deg",
        k = getComputedStyle(t),
        V = ci(t, ii) || "0";
      return (
        (i = r = s = l = c = u = h = d = p = 0),
        (a = o = 1),
        (n.svg = !(!t.getCTM || !gi(t))),
        k.translate &&
          (("none" === k.translate &&
            "none" === k.scale &&
            "none" === k.rotate) ||
            (F[ni] =
              ("none" !== k.translate
                ? "translate3d(" +
                  (k.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                  ") "
                : "") +
              ("none" !== k.rotate ? "rotate(" + k.rotate + ") " : "") +
              ("none" !== k.scale
                ? "scale(" + k.scale.split(" ").join(",") + ") "
                : "") +
              ("none" !== k[ni] ? k[ni] : "")),
          (F.scale = F.rotate = F.translate = "none")),
        (g = Pi(t, n.svg)),
        n.svg &&
          (n.uncache
            ? ((C = t.getBBox()),
              (V = n.xOrigin - C.x + "px " + (n.yOrigin - C.y) + "px"),
              (w = ""))
            : (w = !e && t.getAttribute("data-svg-origin")),
          Li(t, w || V, !!w || n.originIsAbsolute, !1 !== n.smooth, g)),
        (f = n.xOrigin || 0),
        (m = n.yOrigin || 0),
        g !== wi &&
          ((y = g[0]),
          (S = g[1]),
          (E = g[2]),
          (T = g[3]),
          (i = b = g[4]),
          (r = D = g[5]),
          6 === g.length
            ? ((a = Math.sqrt(y * y + S * S)),
              (o = Math.sqrt(T * T + E * E)),
              (l = y || S ? zn(S, y) * On : 0),
              (h = E || T ? zn(E, T) * On + l : 0) &&
                (o *= Math.abs(Math.cos(h * Bn))),
              n.svg && ((i -= f - (f * y + m * E)), (r -= m - (f * S + m * T))))
            : ((N = g[6]),
              (I = g[7]),
              (R = g[8]),
              (P = g[9]),
              (L = g[10]),
              (U = g[11]),
              (i = g[12]),
              (r = g[13]),
              (s = g[14]),
              (c = (v = zn(N, L)) * On),
              v &&
                ((w = b * (_ = Math.cos(-v)) + R * (x = Math.sin(-v))),
                (C = D * _ + P * x),
                (A = N * _ + L * x),
                (R = b * -x + R * _),
                (P = D * -x + P * _),
                (L = N * -x + L * _),
                (U = I * -x + U * _),
                (b = w),
                (D = C),
                (N = A)),
              (u = (v = zn(-E, L)) * On),
              v &&
                ((_ = Math.cos(-v)),
                (U = T * (x = Math.sin(-v)) + U * _),
                (y = w = y * _ - R * x),
                (S = C = S * _ - P * x),
                (E = A = E * _ - L * x)),
              (l = (v = zn(S, y)) * On),
              v &&
                ((w = y * (_ = Math.cos(v)) + S * (x = Math.sin(v))),
                (C = b * _ + D * x),
                (S = S * _ - y * x),
                (D = D * _ - b * x),
                (y = w),
                (b = C)),
              c &&
                Math.abs(c) + Math.abs(l) > 359.9 &&
                ((c = l = 0), (u = 180 - u)),
              (a = vt(Math.sqrt(y * y + S * S + E * E))),
              (o = vt(Math.sqrt(D * D + N * N))),
              (v = zn(b, D)),
              (h = Math.abs(v) > 2e-4 ? v * On : 0),
              (p = U ? 1 / (U < 0 ? -U : U) : 0)),
          n.svg &&
            ((w = t.getAttribute("transform")),
            (n.forceCSS = t.setAttribute("transform", "") || !Ai(ci(t, ni))),
            w && t.setAttribute("transform", w))),
        Math.abs(h) > 90 &&
          Math.abs(h) < 270 &&
          (O
            ? ((a *= -1),
              (h += l <= 0 ? 180 : -180),
              (l += l <= 0 ? 180 : -180))
            : ((o *= -1), (h += h <= 0 ? 180 : -180))),
        (e = e || n.uncache),
        (n.x =
          i -
          ((n.xPercent =
            i &&
            ((!e && n.xPercent) ||
              (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0)))
            ? (t.offsetWidth * n.xPercent) / 100
            : 0) +
          B),
        (n.y =
          r -
          ((n.yPercent =
            r &&
            ((!e && n.yPercent) ||
              (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0)))
            ? (t.offsetHeight * n.yPercent) / 100
            : 0) +
          B),
        (n.z = s + B),
        (n.scaleX = vt(a)),
        (n.scaleY = vt(o)),
        (n.rotation = vt(l) + z),
        (n.rotationX = vt(c) + z),
        (n.rotationY = vt(u) + z),
        (n.skewX = h + z),
        (n.skewY = d + z),
        (n.transformPerspective = p + B),
        (n.zOrigin = parseFloat(V.split(" ")[2]) || (!e && n.zOrigin) || 0) &&
          (F[ii] = Ui(V)),
        (n.xOffset = n.yOffset = 0),
        (n.force3D = M.force3D),
        (n.renderTransform = n.svg ? Vi : Nn ? ki : Fi),
        (n.uncache = 0),
        n
      );
    },
    Ui = function (t) {
      return (t = t.split(" "))[0] + " " + t[1];
    },
    Ni = function (t, e, n) {
      var i = te(e);
      return vt(parseFloat(e) + parseFloat(Si(t, "x", n + "px", i))) + i;
    },
    Fi = function (t, e) {
      (e.z = "0px"),
        (e.rotationY = e.rotationX = "0deg"),
        (e.force3D = 0),
        ki(t, e);
    },
    Oi = "0deg",
    Bi = "0px",
    zi = ") ",
    ki = function (t, e) {
      var n = e || this,
        i = n.xPercent,
        r = n.yPercent,
        s = n.x,
        a = n.y,
        o = n.z,
        l = n.rotation,
        c = n.rotationY,
        u = n.rotationX,
        h = n.skewX,
        d = n.skewY,
        p = n.scaleX,
        f = n.scaleY,
        m = n.transformPerspective,
        g = n.force3D,
        v = n.target,
        _ = n.zOrigin,
        x = "",
        y = ("auto" === g && t && 1 !== t) || !0 === g;
      if (_ && (u !== Oi || c !== Oi)) {
        var S,
          M = parseFloat(c) * Bn,
          E = Math.sin(M),
          T = Math.cos(M);
        (M = parseFloat(u) * Bn),
          (S = Math.cos(M)),
          (s = Ni(v, s, E * S * -_)),
          (a = Ni(v, a, -Math.sin(M) * -_)),
          (o = Ni(v, o, T * S * -_ + _));
      }
      m !== Bi && (x += "perspective(" + m + zi),
        (i || r) && (x += "translate(" + i + "%, " + r + "%) "),
        (y || s !== Bi || a !== Bi || o !== Bi) &&
          (x +=
            o !== Bi || y
              ? "translate3d(" + s + ", " + a + ", " + o + ") "
              : "translate(" + s + ", " + a + zi),
        l !== Oi && (x += "rotate(" + l + zi),
        c !== Oi && (x += "rotateY(" + c + zi),
        u !== Oi && (x += "rotateX(" + u + zi),
        (h === Oi && d === Oi) || (x += "skew(" + h + ", " + d + zi),
        (1 === p && 1 === f) || (x += "scale(" + p + ", " + f + zi),
        (v.style[ni] = x || "translate(0, 0)");
    },
    Vi = function (t, e) {
      var n,
        i,
        r,
        s,
        a,
        o = e || this,
        l = o.xPercent,
        c = o.yPercent,
        u = o.x,
        h = o.y,
        d = o.rotation,
        p = o.skewX,
        f = o.skewY,
        m = o.scaleX,
        g = o.scaleY,
        v = o.target,
        _ = o.xOrigin,
        x = o.yOrigin,
        y = o.xOffset,
        S = o.yOffset,
        M = o.forceCSS,
        E = parseFloat(u),
        T = parseFloat(h);
      (d = parseFloat(d)),
        (p = parseFloat(p)),
        (f = parseFloat(f)) && ((p += f = parseFloat(f)), (d += f)),
        d || p
          ? ((d *= Bn),
            (p *= Bn),
            (n = Math.cos(d) * m),
            (i = Math.sin(d) * m),
            (r = Math.sin(d - p) * -g),
            (s = Math.cos(d - p) * g),
            p &&
              ((f *= Bn),
              (a = Math.tan(p - f)),
              (r *= a = Math.sqrt(1 + a * a)),
              (s *= a),
              f &&
                ((a = Math.tan(f)), (n *= a = Math.sqrt(1 + a * a)), (i *= a))),
            (n = vt(n)),
            (i = vt(i)),
            (r = vt(r)),
            (s = vt(s)))
          : ((n = m), (s = g), (i = r = 0)),
        ((E && !~(u + "").indexOf("px")) || (T && !~(h + "").indexOf("px"))) &&
          ((E = Si(v, "x", u, "px")), (T = Si(v, "y", h, "px"))),
        (_ || x || y || S) &&
          ((E = vt(E + _ - (_ * n + x * r) + y)),
          (T = vt(T + x - (_ * i + x * s) + S))),
        (l || c) &&
          ((a = v.getBBox()),
          (E = vt(E + (l / 100) * a.width)),
          (T = vt(T + (c / 100) * a.height))),
        (a =
          "matrix(" +
          n +
          "," +
          i +
          "," +
          r +
          "," +
          s +
          "," +
          E +
          "," +
          T +
          ")"),
        v.setAttribute("transform", a),
        M && (v.style[ni] = a);
    },
    Hi = function (t, e, n, i, r) {
      var s,
        a,
        o = 360,
        l = L(r),
        c = parseFloat(r) * (l && ~r.indexOf("rad") ? On : 1) - i,
        u = i + c + "deg";
      return (
        l &&
          ("short" === (s = r.split("_")[1]) &&
            (c %= o) != c % 180 &&
            (c += c < 0 ? o : -360),
          "cw" === s && c < 0
            ? (c = ((c + 36e9) % o) - ~~(c / o) * o)
            : "ccw" === s && c > 0 && (c = ((c - 36e9) % o) - ~~(c / o) * o)),
        (t._pt = a = new fn(t._pt, e, n, i, c, Xn)),
        (a.e = u),
        (a.u = "deg"),
        t._props.push(n),
        a
      );
    },
    Gi = function (t, e) {
      for (var n in e) t[n] = e[n];
      return t;
    },
    Wi = function (t, e, n) {
      var i,
        r,
        s,
        a,
        o,
        l,
        c,
        u = Gi({}, n._gsap),
        h = n.style;
      for (r in (u.svg
        ? ((s = n.getAttribute("transform")),
          n.setAttribute("transform", ""),
          (h[ni] = e),
          (i = Ii(n, 1)),
          vi(n, ni),
          n.setAttribute("transform", s))
        : ((s = getComputedStyle(n)[ni]),
          (h[ni] = e),
          (i = Ii(n, 1)),
          (h[ni] = s)),
      Fn))
        (s = u[r]) !== (a = i[r]) &&
          "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 &&
          ((o = te(s) !== (c = te(a)) ? Si(n, r, s, c) : parseFloat(s)),
          (l = parseFloat(a)),
          (t._pt = new fn(t._pt, i, r, o, l - o, Wn)),
          (t._pt.u = c || 0),
          t._props.push(r));
      Gi(i, u);
    };
  gt("padding,margin,Width,Radius", function (t, e) {
    var n = "Top",
      i = "Right",
      r = "Bottom",
      s = "Left",
      a = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map(function (
        n
      ) {
        return e < 2 ? t + n : "border" + n + t;
      });
    Di[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
      var s, o;
      if (arguments.length < 4)
        return (
          (s = a.map(function (e) {
            return Mi(t, e, n);
          })),
          5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o
        );
      (s = (i + "").split(" ")),
        (o = {}),
        a.forEach(function (t, e) {
          return (o[t] = s[e] = s[e] || s[((e - 1) / 2) | 0]);
        }),
        t.init(e, o, r);
    };
  });
  var Xi,
    qi,
    ji = {
      name: "css",
      register: di,
      targetTest: function (t) {
        return t.style && t.nodeType;
      },
      init: function (t, e, n, i, r) {
        var s,
          a,
          o,
          l,
          c,
          u,
          h,
          d,
          p,
          f,
          m,
          g,
          v,
          _,
          x,
          y,
          S,
          E,
          T,
          b,
          D = this._props,
          w = t.style,
          C = n.vars.startAt;
        for (h in (Pn || di(),
        (this.styles = this.styles || oi(t)),
        (y = this.styles.props),
        (this.tween = n),
        e))
          if (
            "autoRound" !== h &&
            ((a = e[h]), !lt[h] || !je(h, e, n, i, t, r))
          )
            if (
              ((c = typeof a),
              (u = Di[h]),
              "function" === c && (c = typeof (a = a.call(n, i, t, r))),
              "string" === c && ~a.indexOf("random(") && (a = he(a)),
              u)
            )
              u(this, t, h, a, n) && (x = 1);
            else if ("--" === h.substr(0, 2))
              (s = (getComputedStyle(t).getPropertyValue(h) + "").trim()),
                (a += ""),
                (Te.lastIndex = 0),
                Te.test(s) || ((d = te(s)), (p = te(a))),
                p ? d !== p && (s = Si(t, h, s, p) + p) : d && (a += d),
                this.add(w, "setProperty", s, a, i, r, 0, 0, h),
                D.push(h),
                y.push(h, 0, w[h]);
            else if ("undefined" !== c) {
              if (
                (C && h in C
                  ? ((s =
                      "function" == typeof C[h] ? C[h].call(n, i, t, r) : C[h]),
                    L(s) && ~s.indexOf("random(") && (s = he(s)),
                    te(s + "") ||
                      "auto" === s ||
                      (s += M.units[h] || te(Mi(t, h)) || ""),
                    "=" === (s + "").charAt(1) && (s = Mi(t, h)))
                  : (s = Mi(t, h)),
                (l = parseFloat(s)),
                (f = "string" === c && "=" === a.charAt(1) && a.substr(0, 2)) &&
                  (a = a.substr(2)),
                (o = parseFloat(a)),
                h in Gn &&
                  ("autoAlpha" === h &&
                    (1 === l &&
                      "hidden" === Mi(t, "visibility") &&
                      o &&
                      (l = 0),
                    y.push("visibility", 0, w.visibility),
                    _i(
                      this,
                      w,
                      "visibility",
                      l ? "inherit" : "hidden",
                      o ? "inherit" : "hidden",
                      !o
                    )),
                  "scale" !== h &&
                    "transform" !== h &&
                    ~(h = Gn[h]).indexOf(",") &&
                    (h = h.split(",")[0])),
                (m = h in Fn))
              )
                if (
                  (this.styles.save(h),
                  g ||
                    (((v = t._gsap).renderTransform && !e.parseTransform) ||
                      Ii(t, e.parseTransform),
                    (_ = !1 !== e.smoothOrigin && v.smooth),
                    ((g = this._pt =
                      new fn(
                        this._pt,
                        w,
                        ni,
                        0,
                        1,
                        v.renderTransform,
                        v,
                        0,
                        -1
                      )).dep = 1)),
                  "scale" === h)
                )
                  (this._pt = new fn(
                    this._pt,
                    v,
                    "scaleY",
                    v.scaleY,
                    (f ? xt(v.scaleY, f + o) : o) - v.scaleY || 0,
                    Wn
                  )),
                    (this._pt.u = 0),
                    D.push("scaleY", h),
                    (h += "X");
                else {
                  if ("transformOrigin" === h) {
                    y.push(ii, 0, w[ii]),
                      (E = void 0),
                      (T = void 0),
                      (b = void 0),
                      (T = (E = (S = a).split(" "))[0]),
                      (b = E[1] || "50%"),
                      ("top" !== T &&
                        "bottom" !== T &&
                        "left" !== b &&
                        "right" !== b) ||
                        ((S = T), (T = b), (b = S)),
                      (E[0] = Ti[T] || T),
                      (E[1] = Ti[b] || b),
                      (a = E.join(" ")),
                      v.svg
                        ? Li(t, a, 0, _, 0, this)
                        : ((p = parseFloat(a.split(" ")[2]) || 0) !==
                            v.zOrigin && _i(this, v, "zOrigin", v.zOrigin, p),
                          _i(this, w, h, Ui(s), Ui(a)));
                    continue;
                  }
                  if ("svgOrigin" === h) {
                    Li(t, a, 1, _, 0, this);
                    continue;
                  }
                  if (h in Ci) {
                    Hi(this, v, h, l, f ? xt(l, f + a) : a);
                    continue;
                  }
                  if ("smoothOrigin" === h) {
                    _i(this, v, "smooth", v.smooth, a);
                    continue;
                  }
                  if ("force3D" === h) {
                    v[h] = a;
                    continue;
                  }
                  if ("transform" === h) {
                    Wi(this, a, t);
                    continue;
                  }
                }
              else h in w || (h = hi(h) || h);
              if (
                m ||
                ((o || 0 === o) && (l || 0 === l) && !Hn.test(a) && h in w)
              )
                o || (o = 0),
                  (d = (s + "").substr((l + "").length)) !==
                    (p = te(a) || (h in M.units ? M.units[h] : d)) &&
                    (l = Si(t, h, s, p)),
                  (this._pt = new fn(
                    this._pt,
                    m ? v : w,
                    h,
                    l,
                    (f ? xt(l, f + o) : o) - l,
                    m || ("px" !== p && "zIndex" !== h) || !1 === e.autoRound
                      ? Wn
                      : jn
                  )),
                  (this._pt.u = p || 0),
                  d !== p && "%" !== p && ((this._pt.b = s), (this._pt.r = qn));
              else if (h in w) Ei.call(this, t, h, s, f ? f + a : a);
              else if (h in t) this.add(t, h, s || t[h], f ? f + a : a, i, r);
              else if ("parseTransform" !== h) {
                $(h, a);
                continue;
              }
              m || (h in w ? y.push(h, 0, w[h]) : y.push(h, 1, s || t[h])),
                D.push(h);
            }
        x && pn(this);
      },
      render: function (t, e) {
        if (e.tween._time || !Un())
          for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
        else e.styles.revert();
      },
      get: Mi,
      aliases: Gn,
      getSetter: function (t, e, n) {
        var i = Gn[e];
        return (
          i && i.indexOf(",") < 0 && (e = i),
          e in Fn && e !== ii && (t._gsap.x || Mi(t, "x"))
            ? n && In === n
              ? "scale" === e
                ? Qn
                : $n
              : (In = n || {}) && ("scale" === e ? ti : ei)
            : t.style && !N(t.style[e])
            ? Zn
            : ~e.indexOf("-")
            ? Jn
            : sn(t, e)
        );
      },
      core: { _removeProperty: vi, _getMatrix: Pi },
    };
  (wn.utils.checkPrefix = hi),
    (wn.core.getStyleSaver = oi),
    (qi = gt(
      "x,y,z,scale,scaleX,scaleY,xPercent,yPercent" +
        "," +
        (Xi = "rotation,rotationX,rotationY,skewX,skewY") +
        ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
      function (t) {
        Fn[t] = 1;
      }
    )),
    gt(Xi, function (t) {
      (M.units[t] = "deg"), (Ci[t] = 1);
    }),
    (Gn[qi[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + Xi),
    gt(
      "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
      function (t) {
        var e = t.split(":");
        Gn[e[1]] = qi[e[0]];
      }
    ),
    gt(
      "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
      function (t) {
        M.units[t] = "px";
      }
    ),
    wn.registerPlugin(ji);
  var Yi = wn.registerPlugin(ji) || wn;
  function Ki(t, e) {
    for (var n = 0; n < e.length; n++) {
      var i = e[n];
      (i.enumerable = i.enumerable || !1),
        (i.configurable = !0),
        "value" in i && (i.writable = !0),
        Object.defineProperty(t, i.key, i);
    }
  }
  Yi.core.Tween;
  var Zi,
    Ji,
    $i,
    Qi,
    tr,
    er,
    nr,
    ir,
    rr,
    sr,
    ar,
    or,
    lr,
    cr = function () {
      return (
        Zi ||
        ("undefined" != typeof window &&
          (Zi = window.gsap) &&
          Zi.registerPlugin &&
          Zi)
      );
    },
    ur = 1,
    hr = [],
    dr = [],
    pr = [],
    fr = Date.now,
    mr = function (t, e) {
      return e;
    },
    gr = function (t, e) {
      return ~pr.indexOf(t) && pr[pr.indexOf(t) + 1][e];
    },
    vr = function (t) {
      return !!~sr.indexOf(t);
    },
    _r = function (t, e, n, i, r) {
      return t.addEventListener(e, n, { passive: !1 !== i, capture: !!r });
    },
    xr = function (t, e, n, i) {
      return t.removeEventListener(e, n, !!i);
    },
    yr = "scrollLeft",
    Sr = "scrollTop",
    Mr = function () {
      return (ar && ar.isPressed) || dr.cache++;
    },
    Er = function (t, e) {
 
    },
    Tr = {
      s: yr,
      p: "left",
      p2: "Left",
      os: "right",
      os2: "Right",
      d: "width",
      d2: "Width",
      a: "x",
      sc: Er(function (t) {
        return arguments.length
          ? $i.scrollTo(t, br.sc())
          : $i.pageXOffset || Qi[yr] || tr[yr] || er[yr] || 0;
      }),
    },
    br = {
      s: Sr,
      p: "top",
      p2: "Top",
      os: "bottom",
      os2: "Bottom",
      d: "height",
      d2: "Height",
      a: "y",
      op: Tr,
      sc: Er(function (t) {
        return arguments.length
          ? $i.scrollTo(Tr.sc(), t)
          : $i.pageYOffset || Qi[Sr] || tr[Sr] || er[Sr] || 0;
      }),
    },
    Dr = function (t, e) {
      return (
        ((e && e._ctx && e._ctx.selector) || Zi.utils.toArray)(t)[0] ||
        ("string" == typeof t && !1 !== Zi.config().nullTargetWarn
          ? console.warn("Element not found:", t)
          : null)
      );
    },
    wr = function (t, e) {
      var n = e.s,
        i = e.sc;
      vr(t) && (t = Qi.scrollingElement || tr);
      var r = dr.indexOf(t),
        s = i === br.sc ? 1 : 2;
      !~r && (r = dr.push(t) - 1), dr[r + s] || _r(t, "scroll", Mr);
      var a = dr[r + s],
        o =
          a ||
          (dr[r + s] =
            Er(gr(t, n), !0) ||
            (vr(t)
              ? i
              : Er(function (e) {
                  return arguments.length ? (t[n] = e) : t[n];
                })));
      return (
        (o.target = t),
        a || (o.smooth = "smooth" === Zi.getProperty(t, "scrollBehavior")),
        o
      );
    },
    Cr = function (t, e, n) {
      var i = t,
        r = t,
        s = fr(),
        a = s,
        o = e || 50,
        l = Math.max(500, 3 * o),
        c = function (t, e) {
          var l = fr();
          e || l - s > o
            ? ((r = i), (i = t), (a = s), (s = l))
            : n
            ? (i += t)
            : (i = r + ((t - r) / (l - a)) * (s - a));
        };
      return {
        update: c,
        reset: function () {
          (r = i = n ? 0 : i), (a = s = 0);
        },
        getVelocity: function (t) {
          var e = a,
            o = r,
            u = fr();
          return (
            (t || 0 === t) && t !== i && c(t),
            s === a || u - a > l
              ? 0
              : ((i + (n ? o : -o)) / ((n ? u : s) - e)) * 1e3
          );
        },
      };
    },
    Ar = function (t, e) {
      return (
        e && !t._gsapAllow && t.preventDefault(),
        t.changedTouches ? t.changedTouches[0] : t
      );
    },
    Rr = function (t) {
      var e = Math.max.apply(Math, t),
        n = Math.min.apply(Math, t);
      return Math.abs(e) >= Math.abs(n) ? e : n;
    },
    Pr = function () {
      var t, e, n, i;
      (rr = Zi.core.globals().ScrollTrigger) &&
        rr.core &&
        ((t = rr.core),
        (e = t.bridge || {}),
        (n = t._scrollers),
        (i = t._proxies),
        n.push.apply(n, dr),
        i.push.apply(i, pr),
        (dr = n),
        (pr = i),
        (mr = function (t, n) {
          return e[t](n);
        }));
    },
    Lr = function (t) {
      return (
        (Zi = t || cr()),
        !Ji &&
          Zi &&
          "undefined" != typeof document &&
          document.body &&
          (($i = window),
          (Qi = document),
          (tr = Qi.documentElement),
          (er = Qi.body),
          (sr = [$i, Qi, tr, er]),
          Zi.utils.clamp,
          (lr = Zi.core.context || function () {}),
          (ir = "onpointerenter" in er ? "pointer" : "mouse"),
          (nr = Ir.isTouch =
            $i.matchMedia &&
            $i.matchMedia("(hover: none), (pointer: coarse)").matches
              ? 1
              : "ontouchstart" in $i ||
                navigator.maxTouchPoints > 0 ||
                navigator.msMaxTouchPoints > 0
              ? 2
              : 0),
          (or = Ir.eventTypes =
            (
              "ontouchstart" in tr
                ? "touchstart,touchmove,touchcancel,touchend"
                : "onpointerdown" in tr
                ? "pointerdown,pointermove,pointercancel,pointerup"
                : "mousedown,mousemove,mouseup,mouseup"
            ).split(",")),
          setTimeout(function () {
            return (ur = 0);
          }, 500),
          Pr(),
          (Ji = 1)),
        Ji
      );
    };
  (Tr.op = br), (dr.cache = 0);
  var Ir = (function () {
    function t(t) {
      this.init(t);
    }
    var e, n;
    return (
      (t.prototype.init = function (t) {
        Ji || Lr(Zi) || console.warn("Please gsap.registerPlugin(Observer)"),
          rr || Pr();
        var e = t.tolerance,
          n = t.dragMinimum,
          i = t.type,
          r = t.target,
          s = t.lineHeight,
          a = t.debounce,
          o = t.preventDefault,
          l = t.onStop,
          c = t.onStopDelay,
          u = t.ignore,
          h = t.wheelSpeed,
          d = t.event,
          p = t.onDragStart,
          f = t.onDragEnd,
          m = t.onDrag,
          g = t.onPress,
          v = t.onRelease,
          _ = t.onRight,
          x = t.onLeft,
          y = t.onUp,
          S = t.onDown,
          M = t.onChangeX,
          E = t.onChangeY,
          T = t.onChange,
          b = t.onToggleX,
          D = t.onToggleY,
          w = t.onHover,
          C = t.onHoverEnd,
          A = t.onMove,
          R = t.ignoreCheck,
          P = t.isNormalizer,
          L = t.onGestureStart,
          I = t.onGestureEnd,
          U = t.onWheel,
          N = t.onEnable,
          F = t.onDisable,
          O = t.onClick,
          B = t.scrollSpeed,
          z = t.capture,
          k = t.allowClicks,
          V = t.lockAxis,
          H = t.onLockAxis;
        (this.target = r = Dr(r) || tr),
          (this.vars = t),
          u && (u = Zi.utils.toArray(u)),
          (e = e || 1e-9),
          (n = n || 0),
          (h = h || 1),
          (B = B || 1),
          (i = i || "wheel,touch,pointer"),
          (a = !1 !== a),
          s || (s = parseFloat($i.getComputedStyle(er).lineHeight) || 22);
        var G,
          W,
          X,
          q,
          j,
          Y,
          K,
          Z = this,
          J = 0,
          $ = 0,
          Q = t.passive || !o,
          tt = wr(r, Tr),
          et = wr(r, br),
          nt = tt(),
          it = et(),
          rt =
            ~i.indexOf("touch") &&
            !~i.indexOf("pointer") &&
            "pointerdown" === or[0],
          st = vr(r),
          at = r.ownerDocument || Qi,
          ot = [0, 0, 0],
          lt = [0, 0, 0],
          ct = 0,
          ut = function () {
            return (ct = fr());
          },
          ht = function (t, e) {
            return (
              ((Z.event = t) && u && ~u.indexOf(t.target)) ||
              (e && rt && "touch" !== t.pointerType) ||
              (R && R(t, e))
            );
          },
          dt = function () {
            var t = (Z.deltaX = Rr(ot)),
              n = (Z.deltaY = Rr(lt)),
              i = Math.abs(t) >= e,
              r = Math.abs(n) >= e;
            T && (i || r) && T(Z, t, n, ot, lt),
              i &&
                (_ && Z.deltaX > 0 && _(Z),
                x && Z.deltaX < 0 && x(Z),
                M && M(Z),
                b && Z.deltaX < 0 != J < 0 && b(Z),
                (J = Z.deltaX),
                (ot[0] = ot[1] = ot[2] = 0)),
              r &&
                (S && Z.deltaY > 0 && S(Z),
                y && Z.deltaY < 0 && y(Z),
                E && E(Z),
                D && Z.deltaY < 0 != $ < 0 && D(Z),
                ($ = Z.deltaY),
                (lt[0] = lt[1] = lt[2] = 0)),
              (q || X) && (A && A(Z), X && (m(Z), (X = !1)), (q = !1)),
              Y && !(Y = !1) && H && H(Z),
              j && (U(Z), (j = !1)),
              (G = 0);
          },
          pt = function (t, e, n) {
            (ot[n] += t),
              (lt[n] += e),
              Z._vx.update(t),
              Z._vy.update(e),
              a ? G || (G = requestAnimationFrame(dt)) : dt();
          },
          ft = function (t, e) {
            V &&
              !K &&
              ((Z.axis = K = Math.abs(t) > Math.abs(e) ? "x" : "y"), (Y = !0)),
              "y" !== K && ((ot[2] += t), Z._vx.update(t, !0)),
              "x" !== K && ((lt[2] += e), Z._vy.update(e, !0)),
              a ? G || (G = requestAnimationFrame(dt)) : dt();
          },
          mt = function (t) {
            if (!ht(t, 1)) {
              var e = (t = Ar(t, o)).clientX,
                i = t.clientY,
                r = e - Z.x,
                s = i - Z.y,
                a = Z.isDragging;
              (Z.x = e),
                (Z.y = i),
                (a ||
                  Math.abs(Z.startX - e) >= n ||
                  Math.abs(Z.startY - i) >= n) &&
                  (m && (X = !0),
                  a || (Z.isDragging = !0),
                  ft(r, s),
                  a || (p && p(Z)));
            }
          },
          gt = (Z.onPress = function (t) {
            ht(t, 1) ||
              (t && t.button) ||
              ((Z.axis = K = null),
              W.pause(),
              (Z.isPressed = !0),
              (t = Ar(t)),
              (J = $ = 0),
              (Z.startX = Z.x = t.clientX),
              (Z.startY = Z.y = t.clientY),
              Z._vx.reset(),
              Z._vy.reset(),
              _r(P ? r : at, or[1], mt, Q, !0),
              (Z.deltaX = Z.deltaY = 0),
              g && g(Z));
          }),
          vt = (Z.onRelease = function (t) {
            if (!ht(t, 1)) {
              xr(P ? r : at, or[1], mt, !0);
              var e = !isNaN(Z.y - Z.startY),
                n = Z.isDragging,
                i =
                  n &&
                  (Math.abs(Z.x - Z.startX) > 3 ||
                    Math.abs(Z.y - Z.startY) > 3),
                s = Ar(t);
              !i &&
                e &&
                (Z._vx.reset(),
                Z._vy.reset(),
                o &&
                  k &&
                  Zi.delayedCall(0.08, function () {
                    if (fr() - ct > 300 && !t.defaultPrevented)
                      if (t.target.click) t.target.click();
                      else if (at.createEvent) {
                        var e = at.createEvent("MouseEvents");
                        e.initMouseEvent(
                          "click",
                          !0,
                          !0,
                          $i,
                          1,
                          s.screenX,
                          s.screenY,
                          s.clientX,
                          s.clientY,
                          !1,
                          !1,
                          !1,
                          !1,
                          0,
                          null
                        ),
                          t.target.dispatchEvent(e);
                      }
                  })),
                (Z.isDragging = Z.isGesturing = Z.isPressed = !1),
                l && n && !P && W.restart(!0),
                f && n && f(Z),
                v && v(Z, i);
            }
          }),
          _t = function (t) {
            return (
              t.touches &&
              t.touches.length > 1 &&
              (Z.isGesturing = !0) &&
              L(t, Z.isDragging)
            );
          },
          xt = function () {
            return (Z.isGesturing = !1) || I(Z);
          },
          yt = function (t) {
            if (!ht(t)) {
              var e = tt(),
                n = et();
              pt((e - nt) * B, (n - it) * B, 1),
                (nt = e),
                (it = n),
                l && W.restart(!0);
            }
          },
          St = function (t) {
            if (!ht(t)) {
              (t = Ar(t, o)), U && (j = !0);
              var e =
                (1 === t.deltaMode
                  ? s
                  : 2 === t.deltaMode
                  ? $i.innerHeight
                  : 1) * h;
              pt(t.deltaX * e, t.deltaY * e, 0), l && !P && W.restart(!0);
            }
          },
          Mt = function (t) {
            if (!ht(t)) {
              var e = t.clientX,
                n = t.clientY,
                i = e - Z.x,
                r = n - Z.y;
              (Z.x = e),
                (Z.y = n),
                (q = !0),
                l && W.restart(!0),
                (i || r) && ft(i, r);
            }
          },
          Et = function (t) {
            (Z.event = t), w(Z);
          },
          Tt = function (t) {
            (Z.event = t), C(Z);
          },
          bt = function (t) {
            return ht(t) || (Ar(t, o) && O(Z));
          };
        (W = Z._dc =
          Zi.delayedCall(c || 0.25, function () {
            Z._vx.reset(), Z._vy.reset(), W.pause(), l && l(Z);
          }).pause()),
          (Z.deltaX = Z.deltaY = 0),
          (Z._vx = Cr(0, 50, !0)),
          (Z._vy = Cr(0, 50, !0)),
          (Z.scrollX = tt),
          (Z.scrollY = et),
          (Z.isDragging = Z.isGesturing = Z.isPressed = !1),
          lr(this),
          (Z.enable = function (t) {
            return (
              Z.isEnabled ||
                (_r(st ? at : r, "scroll", Mr),
                i.indexOf("scroll") >= 0 && _r(st ? at : r, "scroll", yt, Q, z),
                i.indexOf("wheel") >= 0 && _r(r, "wheel", St, Q, z),
                ((i.indexOf("touch") >= 0 && nr) ||
                  i.indexOf("pointer") >= 0) &&
                  (_r(r, or[0], gt, Q, z),
                  _r(at, or[2], vt),
                  _r(at, or[3], vt),
                  k && _r(r, "click", ut, !0, !0),
                  O && _r(r, "click", bt),
                  L && _r(at, "gesturestart", _t),
                  I && _r(at, "gestureend", xt),
                  w && _r(r, ir + "enter", Et),
                  C && _r(r, ir + "leave", Tt),
                  A && _r(r, ir + "move", Mt)),
                (Z.isEnabled = !0),
                t && t.type && gt(t),
                N && N(Z)),
              Z
            );
          }),
          (Z.disable = function () {
            Z.isEnabled &&
              (hr.filter(function (t) {
                return t !== Z && vr(t.target);
              }).length || xr(st ? at : r, "scroll", Mr),
              Z.isPressed &&
                (Z._vx.reset(), Z._vy.reset(), xr(P ? r : at, or[1], mt, !0)),
              xr(st ? at : r, "scroll", yt, z),
              xr(r, "wheel", St, z),
              xr(r, or[0], gt, z),
              xr(at, or[2], vt),
              xr(at, or[3], vt),
              xr(r, "click", ut, !0),
              xr(r, "click", bt),
              xr(at, "gesturestart", _t),
              xr(at, "gestureend", xt),
              xr(r, ir + "enter", Et),
              xr(r, ir + "leave", Tt),
              xr(r, ir + "move", Mt),
              (Z.isEnabled = Z.isPressed = Z.isDragging = !1),
              F && F(Z));
          }),
          (Z.kill = Z.revert =
            function () {
              Z.disable();
              var t = hr.indexOf(Z);
              t >= 0 && hr.splice(t, 1), ar === Z && (ar = 0);
            }),
          hr.push(Z),
          P && vr(r) && (ar = Z),
          Z.enable(d);
      }),
      (e = t),
      (n = [
        {
          key: "velocityX",
          get: function () {
            return this._vx.getVelocity();
          },
        },
        {
          key: "velocityY",
          get: function () {
            return this._vy.getVelocity();
          },
        },
      ]) && Ki(e.prototype, n),
      t
    );
  })();
  (Ir.version = "3.12.5"),
    (Ir.create = function (t) {
      return new Ir(t);
    }),
    (Ir.register = Lr),
    (Ir.getAll = function () {
      return hr.slice();
    }),
    (Ir.getById = function (t) {
      return hr.filter(function (e) {
        return e.vars.id === t;
      })[0];
    }),
    cr() && Zi.registerPlugin(Ir);
  var Ur,
    Nr,
    Fr,
    Or,
    Br,
    zr,
    kr,
    Vr,
    Hr,
    Gr,
    Wr,
    Xr,
    qr,
    jr,
    Yr,
    Kr,
    Zr,
    Jr,
    $r,
    Qr,
    ts,
    es,
    ns,
    is,
    rs,
    ss,
    as,
    os,
    ls,
    cs,
    us,
    hs,
    ds,
    ps,
    fs,
    ms,
    gs,
    vs,
    _s = 1,
    xs = Date.now,
    ys = xs(),
    Ss = 0,
    Ms = 0,
    Es = function (t, e, n) {
      var i = Os(t) && ("clamp(" === t.substr(0, 6) || t.indexOf("max") > -1);
      return (n["_" + e + "Clamp"] = i), i ? t.substr(6, t.length - 7) : t;
    },
    Ts = function (t, e) {
      return !e || (Os(t) && "clamp(" === t.substr(0, 6))
        ? t
        : "clamp(" + t + ")";
    },
    bs = function t() {
      return Ms && requestAnimationFrame(t);
    },
    Ds = function () {
      return (jr = 1);
    },
    ws = function () {
      return (jr = 0);
    },
    Cs = function (t) {
      return t;
    },
    As = function (t) {
      return Math.round(1e5 * t) / 1e5 || 0;
    },
    Rs = function () {
      return "undefined" != typeof window;
    },
    Ps = function () {
      return Ur || (Rs() && (Ur = window.gsap) && Ur.registerPlugin && Ur);
    },
    Ls = function (t) {
      return !!~kr.indexOf(t);
    },
    Is = function (t) {
      return (
        ("Height" === t ? us : Fr["inner" + t]) ||
        Br["client" + t] ||
        zr["client" + t]
      );
    },
    Us = function (t) {
      return (
        gr(t, "getBoundingClientRect") ||
        (Ls(t)
          ? function () {
              return (ja.width = Fr.innerWidth), (ja.height = us), ja;
            }
          : function () {
              return aa(t);
            })
      );
    },
    Ns = function (t, e) {
      var n = e.s,
        i = e.d2,
        r = e.d,
        s = e.a;
      return Math.max(
        0,
        (n = "scroll" + i) && (s = gr(t, n))
          ? s() - Us(t)()[r]
          : Ls(t)
          ? (Br[n] || zr[n]) - Is(i)
          : t[n] - t["offset" + i]
      );
    },
    Fs = function (t, e) {
      for (var n = 0; n < $r.length; n += 3)
        (!e || ~e.indexOf($r[n + 1])) && t($r[n], $r[n + 1], $r[n + 2]);
    },
    Os = function (t) {
      return "string" == typeof t;
    },
    Bs = function (t) {
      return "function" == typeof t;
    },
    zs = function (t) {
      return "number" == typeof t;
    },
    ks = function (t) {
      return "object" == typeof t;
    },
    Vs = function (t, e, n) {
      return t && t.progress(e ? 0 : 1) && n && t.pause();
    },
    Hs = function (t, e) {
      if (t.enabled) {
        var n = t._ctx
          ? t._ctx.add(function () {
              return e(t);
            })
          : e(t);
        n && n.totalTime && (t.callbackAnimation = n);
      }
    },
    Gs = Math.abs,
    Ws = "left",
    Xs = "right",
    qs = "bottom",
    js = "width",
    Ys = "height",
    Ks = "Right",
    Zs = "Left",
    Js = "Top",
    $s = "Bottom",
    Qs = "padding",
    ta = "margin",
    ea = "Width",
    na = "Height",
    ia = "px",
    ra = function (t) {
      return Fr.getComputedStyle(t);
    },
    sa = function (t, e) {
      for (var n in e) n in t || (t[n] = e[n]);
      return t;
    },
    aa = function (t, e) {
      var n =
          e &&
          "matrix(1, 0, 0, 1, 0, 0)" !== ra(t)[Yr] &&
          Ur.to(t, {
            x: 0,
            y: 0,
            xPercent: 0,
            yPercent: 0,
            rotation: 0,
            rotationX: 0,
            rotationY: 0,
            scale: 1,
            skewX: 0,
            skewY: 0,
          }).progress(1),
        i = t.getBoundingClientRect();
      return n && n.progress(0).kill(), i;
    },
    oa = function (t, e) {
      var n = e.d2;
      return t["offset" + n] || t["client" + n] || 0;
    },
    la = function (t) {
      var e,
        n = [],
        i = t.labels,
        r = t.duration();
      for (e in i) n.push(i[e] / r);
      return n;
    },
    ca = function (t) {
      var e = Ur.utils.snap(t),
        n =
          Array.isArray(t) &&
          t.slice(0).sort(function (t, e) {
            return t - e;
          });
      return n
        ? function (t, i, r) {
            var s;
            if ((void 0 === r && (r = 0.001), !i)) return e(t);
            if (i > 0) {
              for (t -= r, s = 0; s < n.length; s++) if (n[s] >= t) return n[s];
              return n[s - 1];
            }
            for (s = n.length, t += r; s--; ) if (n[s] <= t) return n[s];
            return n[0];
          }
        : function (n, i, r) {
            void 0 === r && (r = 0.001);
            var s = e(n);
            return !i || Math.abs(s - n) < r || s - n < 0 == i < 0
              ? s
              : e(i < 0 ? n - t : n + t);
          };
    },
    ua = function (t, e, n, i) {
      return n.split(",").forEach(function (n) {
        return t(e, n, i);
      });
    },
    ha = function (t, e, n, i, r) {
      return t.addEventListener(e, n, { passive: !i, capture: !!r });
    },
    da = function (t, e, n, i) {
      return t.removeEventListener(e, n, !!i);
    },
    pa = function (t, e, n) {
      (n = n && n.wheelHandler) && (t(e, "wheel", n), t(e, "touchmove", n));
    },
    fa = {
      startColor: "green",
      endColor: "red",
      indent: 0,
      fontSize: "16px",
      fontWeight: "normal",
    },
    ma = { toggleActions: "play", anticipatePin: 0 },
    ga = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 },
    va = function (t, e) {
      if (Os(t)) {
        var n = t.indexOf("="),
          i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
        ~n && (t.indexOf("%") > n && (i *= e / 100), (t = t.substr(0, n - 1))),
          (t =
            i +
            (t in ga
              ? ga[t] * e
              : ~t.indexOf("%")
              ? (parseFloat(t) * e) / 100
              : parseFloat(t) || 0));
      }
      return t;
    },
    _a = function (t, e, n, i, r, s, a, o) {
      var l = r.startColor,
        c = r.endColor,
        u = r.fontSize,
        h = r.indent,
        d = r.fontWeight,
        p = Or.createElement("div"),
        f = Ls(n) || "fixed" === gr(n, "pinType"),
        m = -1 !== t.indexOf("scroller"),
        g = f ? zr : n,
        v = -1 !== t.indexOf("start"),
        _ = v ? l : c,
        x =
          "border-color:" +
          _ +
          ";font-size:" +
          u +
          ";color:" +
          _ +
          ";font-weight:" +
          d +
          ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
      return (
        (x += "position:" + ((m || o) && f ? "fixed;" : "absolute;")),
        (m || o || !f) &&
          (x += (i === br ? Xs : qs) + ":" + (s + parseFloat(h)) + "px;"),
        a &&
          (x +=
            "box-sizing:border-box;text-align:left;width:" +
            a.offsetWidth +
            "px;"),
        (p._isStart = v),
        p.setAttribute("class", "gsap-marker-" + t + (e ? " marker-" + e : "")),
        (p.style.cssText = x),
        (p.innerText = e || 0 === e ? t + "-" + e : t),
        g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p),
        (p._offset = p["offset" + i.op.d2]),
        xa(p, 0, i, v),
        p
      );
    },
    xa = function (t, e, n, i) {
      var r = { display: "block" },
        s = n[i ? "os2" : "p2"],
        a = n[i ? "p2" : "os2"];
      (t._isFlipped = i),
        (r[n.a + "Percent"] = i ? -100 : 0),
        (r[n.a] = i ? "1px" : 0),
        (r["border" + s + ea] = 1),
        (r["border" + a + ea] = 0),
        (r[n.p] = e + "px"),
        Ur.set(t, r);
    },
    ya = [],
    Sa = {},
    Ma = function () {
      return xs() - Ss > 34 && (fs || (fs = requestAnimationFrame(ka)));
    },
    Ea = function () {
      (!ns || !ns.isPressed || ns.startX > zr.clientWidth) &&
        (dr.cache++,
        ns ? fs || (fs = requestAnimationFrame(ka)) : ka(),
        Ss || Aa("scrollStart"),
        (Ss = xs()));
    },
    Ta = function () {
      (ss = Fr.innerWidth), (rs = Fr.innerHeight);
    },
    ba = function () {
      dr.cache++,
        !qr &&
          !es &&
          !Or.fullscreenElement &&
          !Or.webkitFullscreenElement &&
          (!is ||
            ss !== Fr.innerWidth ||
            Math.abs(Fr.innerHeight - rs) > 0.25 * Fr.innerHeight) &&
          Vr.restart(!0);
    },
    Da = {},
    wa = [],
    Ca = function t() {
      return da(to, "scrollEnd", t) || Oa(!0);
    },
    Aa = function (t) {
      return (
        (Da[t] &&
          Da[t].map(function (t) {
            return t();
          })) ||
        wa
      );
    },
    Ra = [],
    Pa = function (t) {
      for (var e = 0; e < Ra.length; e += 5)
        (!t || (Ra[e + 4] && Ra[e + 4].query === t)) &&
          ((Ra[e].style.cssText = Ra[e + 1]),
          Ra[e].getBBox && Ra[e].setAttribute("transform", Ra[e + 2] || ""),
          (Ra[e + 3].uncache = 1));
    },
    La = function (t, e) {
      var n;
      for (Kr = 0; Kr < ya.length; Kr++)
        !(n = ya[Kr]) ||
          (e && n._ctx !== e) ||
          (t ? n.kill(1) : n.revert(!0, !0));
      (hs = !0), e && Pa(e), e || Aa("revert");
    },
    Ia = function (t, e) {
      dr.cache++,
        (e || !ms) &&
          dr.forEach(function (t) {
            return Bs(t) && t.cacheID++ && (t.rec = 0);
          }),
        Os(t) && (Fr.history.scrollRestoration = ls = t);
    },
    Ua = 0,
    Na = function () {
      zr.appendChild(cs),
        (us = (!ns && cs.offsetHeight) || Fr.innerHeight),
        zr.removeChild(cs);
    },
    Fa = function (t) {
      return Hr(
        ".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end"
      ).forEach(function (e) {
        return (e.style.display = t ? "none" : "block");
      });
    },
    Oa = function (t, e) {
      if (!Ss || t || hs) {
        Na(),
          (ms = to.isRefreshing = !0),
          dr.forEach(function (t) {
            return Bs(t) && ++t.cacheID && (t.rec = t());
          });
        var n = Aa("refreshInit");
        Qr && to.sort(),
          e || La(),
          dr.forEach(function (t) {
            Bs(t) &&
              (t.smooth && (t.target.style.scrollBehavior = "auto"), t(0));
          }),
          ya.slice(0).forEach(function (t) {
            return t.refresh();
          }),
          (hs = !1),
          ya.forEach(function (t) {
            if (t._subPinOffset && t.pin) {
              var e = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
                n = t.pin[e];
              t.revert(!0, 1), t.adjustPinSpacing(t.pin[e] - n), t.refresh();
            }
          }),
          (ds = 1),
          Fa(!0),
          ya.forEach(function (t) {
            var e = Ns(t.scroller, t._dir),
              n = "max" === t.vars.end || (t._endClamp && t.end > e),
              i = t._startClamp && t.start >= e;
            (n || i) &&
              t.setPositions(
                i ? e - 1 : t.start,
                n ? Math.max(i ? e : t.start + 1, e) : t.end,
                !0
              );
          }),
          Fa(!1),
          (ds = 0),
          n.forEach(function (t) {
            return t && t.render && t.render(-1);
          }),
          dr.forEach(function (t) {
            Bs(t) &&
              (t.smooth &&
                requestAnimationFrame(function () {
                  return (t.target.style.scrollBehavior = "smooth");
                }),
              t.rec && t(t.rec));
          }),
          Ia(ls, 1),
          Vr.pause(),
          Ua++,
          (ms = 2),
          ka(2),
          ya.forEach(function (t) {
            return Bs(t.vars.onRefresh) && t.vars.onRefresh(t);
          }),
          (ms = to.isRefreshing = !1),
          Aa("refresh");
      } else ha(to, "scrollEnd", Ca);
    },
    Ba = 0,
    za = 1,
    ka = function (t) {
      if (2 === t || (!ms && !hs)) {
        (to.isUpdating = !0), vs && vs.update(0);
        var e = ya.length,
          n = xs(),
          i = n - ys >= 50,
          r = e && ya[0].scroll();
        if (
          ((za = Ba > r ? -1 : 1),
          ms || (Ba = r),
          i &&
            (Ss && !jr && n - Ss > 200 && ((Ss = 0), Aa("scrollEnd")),
            (Wr = ys),
            (ys = n)),
          za < 0)
        ) {
          for (Kr = e; Kr-- > 0; ) ya[Kr] && ya[Kr].update(0, i);
          za = 1;
        } else for (Kr = 0; Kr < e; Kr++) ya[Kr] && ya[Kr].update(0, i);
        to.isUpdating = !1;
      }
      fs = 0;
    },
    Va = [
      Ws,
      "top",
      qs,
      Xs,
      ta + $s,
      ta + Ks,
      ta + Js,
      ta + Zs,
      "display",
      "flexShrink",
      "float",
      "zIndex",
      "gridColumnStart",
      "gridColumnEnd",
      "gridRowStart",
      "gridRowEnd",
      "gridArea",
      "justifySelf",
      "alignSelf",
      "placeSelf",
      "order",
    ],
    Ha = Va.concat([
      js,
      Ys,
      "boxSizing",
      "max" + ea,
      "max" + na,
      "position",
      ta,
      Qs,
      Qs + Js,
      Qs + Ks,
      Qs + $s,
      Qs + Zs,
    ]),
    Ga = function (t, e, n, i) {
      if (!t._gsap.swappedIn) {
        for (var r, s = Va.length, a = e.style, o = t.style; s--; )
          a[(r = Va[s])] = n[r];
        (a.position = "absolute" === n.position ? "absolute" : "relative"),
          "inline" === n.display && (a.display = "inline-block"),
          (o[qs] = o[Xs] = "auto"),
          (a.flexBasis = n.flexBasis || "auto"),
          (a.overflow = "visible"),
          (a.boxSizing = "border-box"),
          (a[js] = oa(t, Tr) + ia),
          (a[Ys] = oa(t, br) + ia),
          (a[Qs] = o[ta] = o.top = o[Ws] = "0"),
          Xa(i),
          (o[js] = o["max" + ea] = n[js]),
          (o[Ys] = o["max" + na] = n[Ys]),
          (o[Qs] = n[Qs]),
          t.parentNode !== e &&
            (t.parentNode.insertBefore(e, t), e.appendChild(t)),
          (t._gsap.swappedIn = !0);
      }
    },
    Wa = /([A-Z])/g,
    Xa = function (t) {
      if (t) {
        var e,
          n,
          i = t.t.style,
          r = t.length,
          s = 0;
        for ((t.t._gsap || Ur.core.getCache(t.t)).uncache = 1; s < r; s += 2)
          (n = t[s + 1]),
            (e = t[s]),
            n
              ? (i[e] = n)
              : i[e] && i.removeProperty(e.replace(Wa, "-$1").toLowerCase());
      }
    },
    qa = function (t) {
      for (var e = Ha.length, n = t.style, i = [], r = 0; r < e; r++)
        i.push(Ha[r], n[Ha[r]]);
      return (i.t = t), i;
    },
    ja = { left: 0, top: 0 },
    Ya = function (t, e, n, i, r, s, a, o, l, c, u, h, d, p) {
      Bs(t) && (t = t(o)),
        Os(t) &&
          "max" === t.substr(0, 3) &&
          (t = h + ("=" === t.charAt(4) ? va("0" + t.substr(3), n) : 0));
      var f,
        m,
        g,
        v = d ? d.time() : 0;
      if ((d && d.seek(0), isNaN(t) || (t = +t), zs(t)))
        d &&
          (t = Ur.utils.mapRange(
            d.scrollTrigger.start,
            d.scrollTrigger.end,
            0,
            h,
            t
          )),
          a && xa(a, n, i, !0);
      else {
        Bs(e) && (e = e(o));
        var _,
          x,
          y,
          S,
          M = (t || "0").split(" ");
        (g = Dr(e, o) || zr),
          ((_ = aa(g) || {}) && (_.left || _.top)) ||
            "none" !== ra(g).display ||
            ((S = g.style.display),
            (g.style.display = "block"),
            (_ = aa(g)),
            S ? (g.style.display = S) : g.style.removeProperty("display")),
          (x = va(M[0], _[i.d])),
          (y = va(M[1] || "0", n)),
          (t = _[i.p] - l[i.p] - c + x + r - y),
          a && xa(a, y, i, n - y < 20 || (a._isStart && y > 20)),
          (n -= n - y);
      }
      if ((p && ((o[p] = t || -0.001), t < 0 && (t = 0)), s)) {
        var E = t + n,
          T = s._isStart;
        (f = "scroll" + i.d2),
          xa(
            s,
            E,
            i,
            (T && E > 20) ||
              (!T && (u ? Math.max(zr[f], Br[f]) : s.parentNode[f]) <= E + 1)
          ),
          u &&
            ((l = aa(a)),
            u && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + ia));
      }
      return (
        d &&
          g &&
          ((f = aa(g)),
          d.seek(h),
          (m = aa(g)),
          (d._caScrollDist = f[i.p] - m[i.p]),
          (t = (t / d._caScrollDist) * h)),
        d && d.seek(v),
        d ? t : Math.round(t)
      );
    },
    Ka = /(webkit|moz|length|cssText|inset)/i,
    Za = function (t, e, n, i) {
      if (t.parentNode !== e) {
        var r,
          s,
          a = t.style;
        if (e === zr) {
          for (r in ((t._stOrig = a.cssText), (s = ra(t))))
            +r ||
              Ka.test(r) ||
              !s[r] ||
              "string" != typeof a[r] ||
              "0" === r ||
              (a[r] = s[r]);
          (a.top = n), (a.left = i);
        } else a.cssText = t._stOrig;
        (Ur.core.getCache(t).uncache = 1), e.appendChild(t);
      }
    },
    Ja = function (t, e, n) {
      var i = e,
        r = i;
      return function (e) {
        var s = Math.round(t());
        return (
          s !== i &&
            s !== r &&
            Math.abs(s - i) > 3 &&
            Math.abs(s - r) > 3 &&
            ((e = s), n && n()),
          (r = i),
          (i = e),
          e
        );
      };
    },
    $a = function (t, e, n) {
      var i = {};
      (i[e.p] = "+=" + n), Ur.set(t, i);
    },
    Qa = function (t, e) {
      var n = wr(t, e),
        i = "_scroll" + e.p2,
        r = function e(r, s, a, o, l) {
          var c = e.tween,
            u = s.onComplete,
            h = {};
          a = a || n();
          var d = Ja(n, a, function () {
            c.kill(), (e.tween = 0);
          });
          return (
            (l = (o && l) || 0),
            (o = o || r - a),
            c && c.kill(),
            (s[i] = r),
            (s.inherit = !1),
            (s.modifiers = h),
            (h[i] = function () {
              return d(a + o * c.ratio + l * c.ratio * c.ratio);
            }),
            (s.onUpdate = function () {
              dr.cache++, e.tween && ka();
            }),
            (s.onComplete = function () {
              (e.tween = 0), u && u.call(c);
            }),
            (c = e.tween = Ur.to(t, s))
          );
        };
      return (
        (t[i] = n),
        (n.wheelHandler = function () {
          return r.tween && r.tween.kill() && (r.tween = 0);
        }),
        ha(t, "wheel", n.wheelHandler),
        to.isTouch && ha(t, "touchmove", n.wheelHandler),
        r
      );
    },
    to = (function () {
      function t(e, n) {
        Nr ||
          t.register(Ur) ||
          console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
          os(this),
          this.init(e, n);
      }
      return (
        (t.prototype.init = function (e, n) {
          if (
            ((this.progress = this.start = 0),
            this.vars && this.kill(!0, !0),
            Ms)
          ) {
            var i,
              r,
              s,
              a,
              o,
              l,
              c,
              u,
              h,
              d,
              p,
              f,
              m,
              g,
              v,
              _,
              x,
              y,
              S,
              M,
              E,
              T,
              b,
              D,
              w,
              C,
              A,
              R,
              P,
              L,
              I,
              U,
              N,
              F,
              O,
              B,
              z,
              k,
              V,
              H,
              G,
              W,
              X = (e = sa(
                Os(e) || zs(e) || e.nodeType ? { trigger: e } : e,
                ma
              )),
              q = X.onUpdate,
              j = X.toggleClass,
              Y = X.id,
              K = X.onToggle,
              Z = X.onRefresh,
              J = X.scrub,
              $ = X.trigger,
              Q = X.pin,
              tt = X.pinSpacing,
              et = X.invalidateOnRefresh,
              nt = X.anticipatePin,
              it = X.onScrubComplete,
              rt = X.onSnapComplete,
              st = X.once,
              at = X.snap,
              ot = X.pinReparent,
              lt = X.pinSpacer,
              ct = X.containerAnimation,
              ut = X.fastScrollEnd,
              ht = X.preventOverlaps,
              dt =
                e.horizontal || (e.containerAnimation && !1 !== e.horizontal)
                  ? Tr
                  : br,
              pt = !J && 0 !== J,
              ft = Dr(e.scroller || Fr),
              mt = Ur.core.getCache(ft),
              gt = Ls(ft),
              vt =
                "fixed" ===
                ("pinType" in e
                  ? e.pinType
                  : gr(ft, "pinType") || (gt && "fixed")),
              _t = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack],
              xt = pt && e.toggleActions.split(" "),
              yt = "markers" in e ? e.markers : ma.markers,
              St = gt ? 0 : parseFloat(ra(ft)["border" + dt.p2 + ea]) || 0,
              Mt = this,
              Et =
                e.onRefreshInit &&
                function () {
                  return e.onRefreshInit(Mt);
                },
              Tt = (function (t, e, n) {
                var i = n.d,
                  r = n.d2,
                  s = n.a;
                return (s = gr(t, "getBoundingClientRect"))
                  ? function () {
                      return s()[i];
                    }
                  : function () {
                      return (e ? Is(r) : t["client" + r]) || 0;
                    };
              })(ft, gt, dt),
              bt = (function (t, e) {
                return !e || ~pr.indexOf(t)
                  ? Us(t)
                  : function () {
                      return ja;
                    };
              })(ft, gt),
              Dt = 0,
              wt = 0,
              Ct = 0,
              At = wr(ft, dt);
            if (
              ((Mt._startClamp = Mt._endClamp = !1),
              (Mt._dir = dt),
              (nt *= 45),
              (Mt.scroller = ft),
              (Mt.scroll = ct ? ct.time.bind(ct) : At),
              (a = At()),
              (Mt.vars = e),
              (n = n || e.animation),
              "refreshPriority" in e &&
                ((Qr = 1), -9999 === e.refreshPriority && (vs = Mt)),
              (mt.tweenScroll = mt.tweenScroll || {
                top: Qa(ft, br),
                left: Qa(ft, Tr),
              }),
              (Mt.tweenTo = i = mt.tweenScroll[dt.p]),
              (Mt.scrubDuration = function (t) {
                (N = zs(t) && t)
                  ? U
                    ? U.duration(t)
                    : (U = Ur.to(n, {
                        ease: "expo",
                        totalProgress: "+=0",
                        inherit: !1,
                        duration: N,
                        paused: !0,
                        onComplete: function () {
                          return it && it(Mt);
                        },
                      }))
                  : (U && U.progress(1).kill(), (U = 0));
              }),
              n &&
                ((n.vars.lazy = !1),
                (n._initted && !Mt.isReverted) ||
                  (!1 !== n.vars.immediateRender &&
                    !1 !== e.immediateRender &&
                    n.duration() &&
                    n.render(0, !0, !0)),
                (Mt.animation = n.pause()),
                (n.scrollTrigger = Mt),
                Mt.scrubDuration(J),
                (L = 0),
                Y || (Y = n.vars.id)),
              at &&
                ((ks(at) && !at.push) || (at = { snapTo: at }),
                "scrollBehavior" in zr.style &&
                  Ur.set(gt ? [zr, Br] : ft, { scrollBehavior: "auto" }),
                dr.forEach(function (t) {
                  return (
                    Bs(t) &&
                    t.target === (gt ? Or.scrollingElement || Br : ft) &&
                    (t.smooth = !1)
                  );
                }),
                (s = Bs(at.snapTo)
                  ? at.snapTo
                  : "labels" === at.snapTo
                  ? (function (t) {
                      return function (e) {
                        return Ur.utils.snap(la(t), e);
                      };
                    })(n)
                  : "labelsDirectional" === at.snapTo
                  ? ((H = n),
                    function (t, e) {
                      return ca(la(H))(t, e.direction);
                    })
                  : !1 !== at.directional
                  ? function (t, e) {
                      return ca(at.snapTo)(
                        t,
                        xs() - wt < 500 ? 0 : e.direction
                      );
                    }
                  : Ur.utils.snap(at.snapTo)),
                (F = at.duration || { min: 0.1, max: 2 }),
                (F = ks(F) ? Gr(F.min, F.max) : Gr(F, F)),
                (O = Ur.delayedCall(at.delay || N / 2 || 0.1, function () {
                  var t = At(),
                    e = xs() - wt < 500,
                    r = i.tween;
                  if (
                    !(e || Math.abs(Mt.getVelocity()) < 10) ||
                    r ||
                    jr ||
                    Dt === t
                  )
                    Mt.isActive && Dt !== t && O.restart(!0);
                  else {
                    var a,
                      o,
                      u = (t - l) / g,
                      h = n && !pt ? n.totalProgress() : u,
                      d = e ? 0 : ((h - I) / (xs() - Wr)) * 1e3 || 0,
                      p = Ur.utils.clamp(-u, 1 - u, (Gs(d / 2) * d) / 0.185),
                      f = u + (!1 === at.inertia ? 0 : p),
                      m = at,
                      v = m.onStart,
                      _ = m.onInterrupt,
                      x = m.onComplete;
                    if (
                      ((a = s(f, Mt)),
                      zs(a) || (a = f),
                      (o = Math.round(l + a * g)),
                      t <= c && t >= l && o !== t)
                    ) {
                      if (r && !r._initted && r.data <= Gs(o - t)) return;
                      !1 === at.inertia && (p = a - u),
                        i(
                          o,
                          {
                            duration: F(
                              Gs(
                                (0.185 * Math.max(Gs(f - h), Gs(a - h))) /
                                  d /
                                  0.05 || 0
                              )
                            ),
                            ease: at.ease || "power3",
                            data: Gs(o - t),
                            onInterrupt: function () {
                              return O.restart(!0) && _ && _(Mt);
                            },
                            onComplete: function () {
                              Mt.update(),
                                (Dt = At()),
                                n &&
                                  (U
                                    ? U.resetTo(
                                        "totalProgress",
                                        a,
                                        n._tTime / n._tDur
                                      )
                                    : n.progress(a)),
                                (L = I =
                                  n && !pt ? n.totalProgress() : Mt.progress),
                                rt && rt(Mt),
                                x && x(Mt);
                            },
                          },
                          t,
                          p * g,
                          o - t - p * g
                        ),
                        v && v(Mt, i.tween);
                    }
                  }
                }).pause())),
              Y && (Sa[Y] = Mt),
              (V =
                ($ = Mt.trigger = Dr($ || (!0 !== Q && Q))) &&
                $._gsap &&
                $._gsap.stRevert) && (V = V(Mt)),
              (Q = !0 === Q ? $ : Dr(Q)),
              Os(j) && (j = { targets: $, className: j }),
              Q &&
                (!1 === tt ||
                  tt === ta ||
                  (tt =
                    !(
                      !tt &&
                      Q.parentNode &&
                      Q.parentNode.style &&
                      "flex" === ra(Q.parentNode).display
                    ) && Qs),
                (Mt.pin = Q),
                (r = Ur.core.getCache(Q)).spacer
                  ? (v = r.pinState)
                  : (lt &&
                      ((lt = Dr(lt)) &&
                        !lt.nodeType &&
                        (lt = lt.current || lt.nativeElement),
                      (r.spacerIsNative = !!lt),
                      lt && (r.spacerState = qa(lt))),
                    (r.spacer = y = lt || Or.createElement("div")),
                    y.classList.add("pin-spacer"),
                    Y && y.classList.add("pin-spacer-" + Y),
                    (r.pinState = v = qa(Q))),
                !1 !== e.force3D && Ur.set(Q, { force3D: !0 }),
                (Mt.spacer = y = r.spacer),
                (P = ra(Q)),
                (D = P[tt + dt.os2]),
                (M = Ur.getProperty(Q)),
                (E = Ur.quickSetter(Q, dt.a, ia)),
                Ga(Q, y, P),
                (x = qa(Q))),
              yt)
            ) {
              (f = ks(yt) ? sa(yt, fa) : fa),
                (d = _a("scroller-start", Y, ft, dt, f, 0)),
                (p = _a("scroller-end", Y, ft, dt, f, 0, d)),
                (S = d["offset" + dt.op.d2]);
              var Rt = Dr(gr(ft, "content") || ft);
              (u = this.markerStart = _a("start", Y, Rt, dt, f, S, 0, ct)),
                (h = this.markerEnd = _a("end", Y, Rt, dt, f, S, 0, ct)),
                ct && (k = Ur.quickSetter([u, h], dt.a, ia)),
                vt ||
                  (pr.length && !0 === gr(ft, "fixedMarkers")) ||
                  ((W = ra((G = gt ? zr : ft)).position),
                  (G.style.position =
                    "absolute" === W || "fixed" === W ? W : "relative"),
                  Ur.set([d, p], { force3D: !0 }),
                  (C = Ur.quickSetter(d, dt.a, ia)),
                  (R = Ur.quickSetter(p, dt.a, ia)));
            }
            if (ct) {
              var Pt = ct.vars.onUpdate,
                Lt = ct.vars.onUpdateParams;
              ct.eventCallback("onUpdate", function () {
                Mt.update(0, 0, 1), Pt && Pt.apply(ct, Lt || []);
              });
            }
            if (
              ((Mt.previous = function () {
                return ya[ya.indexOf(Mt) - 1];
              }),
              (Mt.next = function () {
                return ya[ya.indexOf(Mt) + 1];
              }),
              (Mt.revert = function (t, e) {
                if (!e) return Mt.kill(!0);
                var i = !1 !== t || !Mt.enabled,
                  r = qr;
                i !== Mt.isReverted &&
                  (i &&
                    ((B = Math.max(At(), Mt.scroll.rec || 0)),
                    (Ct = Mt.progress),
                    (z = n && n.progress())),
                  u &&
                    [u, h, d, p].forEach(function (t) {
                      return (t.style.display = i ? "none" : "block");
                    }),
                  i && ((qr = Mt), Mt.update(i)),
                  !Q ||
                    (ot && Mt.isActive) ||
                    (i
                      ? (function (t, e, n) {
                          Xa(n);
                          var i = t._gsap;
                          if (i.spacerIsNative) Xa(i.spacerState);
                          else if (t._gsap.swappedIn) {
                            var r = e.parentNode;
                            r && (r.insertBefore(t, e), r.removeChild(e));
                          }
                          t._gsap.swappedIn = !1;
                        })(Q, y, v)
                      : Ga(Q, y, ra(Q), w)),
                  i || Mt.update(i),
                  (qr = r),
                  (Mt.isReverted = i));
              }),
              (Mt.refresh = function (r, s, f, S) {
                if ((!qr && Mt.enabled) || s)
                  if (Q && r && Ss) ha(t, "scrollEnd", Ca);
                  else {
                    !ms && Et && Et(Mt),
                      (qr = Mt),
                      i.tween && !f && (i.tween.kill(), (i.tween = 0)),
                      U && U.pause(),
                      et && n && n.revert({ kill: !1 }).invalidate(),
                      Mt.isReverted || Mt.revert(!0, !0),
                      (Mt._subPinOffset = !1);
                    var E,
                      D,
                      C,
                      R,
                      P,
                      L,
                      I,
                      N,
                      F,
                      k,
                      V,
                      H,
                      G,
                      W = Tt(),
                      X = bt(),
                      q = ct ? ct.duration() : Ns(ft, dt),
                      j = g <= 0.01,
                      Y = 0,
                      K = S || 0,
                      J = ks(f) ? f.end : e.end,
                      nt = e.endTrigger || $,
                      it = ks(f)
                        ? f.start
                        : e.start ||
                          (0 !== e.start && $ ? (Q ? "0 0" : "0 100%") : 0),
                      rt = (Mt.pinnedContainer =
                        e.pinnedContainer && Dr(e.pinnedContainer, Mt)),
                      st = ($ && Math.max(0, ya.indexOf(Mt))) || 0,
                      at = st;
                    for (
                      yt &&
                      ks(f) &&
                      ((H = Ur.getProperty(d, dt.p)),
                      (G = Ur.getProperty(p, dt.p)));
                      at--;

                    )
                      (L = ya[at]).end || L.refresh(0, 1) || (qr = Mt),
                        !(I = L.pin) ||
                          (I !== $ && I !== Q && I !== rt) ||
                          L.isReverted ||
                          (k || (k = []), k.unshift(L), L.revert(!0, !0)),
                        L !== ya[at] && (st--, at--);
                    for (
                      Bs(it) && (it = it(Mt)),
                        it = Es(it, "start", Mt),
                        l =
                          Ya(
                            it,
                            $,
                            W,
                            dt,
                            At(),
                            u,
                            d,
                            Mt,
                            X,
                            St,
                            vt,
                            q,
                            ct,
                            Mt._startClamp && "_startClamp"
                          ) || (Q ? -0.001 : 0),
                        Bs(J) && (J = J(Mt)),
                        Os(J) &&
                          !J.indexOf("+=") &&
                          (~J.indexOf(" ")
                            ? (J = (Os(it) ? it.split(" ")[0] : "") + J)
                            : ((Y = va(J.substr(2), W)),
                              (J = Os(it)
                                ? it
                                : (ct
                                    ? Ur.utils.mapRange(
                                        0,
                                        ct.duration(),
                                        ct.scrollTrigger.start,
                                        ct.scrollTrigger.end,
                                        l
                                      )
                                    : l) + Y),
                              (nt = $))),
                        J = Es(J, "end", Mt),
                        c =
                          Math.max(
                            l,
                            Ya(
                              J || (nt ? "100% 0" : q),
                              nt,
                              W,
                              dt,
                              At() + Y,
                              h,
                              p,
                              Mt,
                              X,
                              St,
                              vt,
                              q,
                              ct,
                              Mt._endClamp && "_endClamp"
                            )
                          ) || -0.001,
                        Y = 0,
                        at = st;
                      at--;

                    )
                      (I = (L = ya[at]).pin) &&
                        L.start - L._pinPush <= l &&
                        !ct &&
                        L.end > 0 &&
                        ((E =
                          L.end -
                          (Mt._startClamp ? Math.max(0, L.start) : L.start)),
                        ((I === $ && L.start - L._pinPush < l) || I === rt) &&
                          isNaN(it) &&
                          (Y += E * (1 - L.progress)),
                        I === Q && (K += E));
                    if (
                      ((l += Y),
                      (c += Y),
                      Mt._startClamp && (Mt._startClamp += Y),
                      Mt._endClamp &&
                        !ms &&
                        ((Mt._endClamp = c || -0.001),
                        (c = Math.min(c, Ns(ft, dt)))),
                      (g = c - l || ((l -= 0.01) && 0.001)),
                      j &&
                        (Ct = Ur.utils.clamp(
                          0,
                          1,
                          Ur.utils.normalize(l, c, B)
                        )),
                      (Mt._pinPush = K),
                      u &&
                        Y &&
                        (((E = {})[dt.a] = "+=" + Y),
                        rt && (E[dt.p] = "-=" + At()),
                        Ur.set([u, h], E)),
                      !Q || (ds && Mt.end >= Ns(ft, dt)))
                    ) {
                      if ($ && At() && !ct)
                        for (D = $.parentNode; D && D !== zr; )
                          D._pinOffset &&
                            ((l -= D._pinOffset), (c -= D._pinOffset)),
                            (D = D.parentNode);
                    } else
                      (E = ra(Q)),
                        (R = dt === br),
                        (C = At()),
                        (T = parseFloat(M(dt.a)) + K),
                        !q &&
                          c > 1 &&
                          ((V = {
                            style: (V = (gt ? Or.scrollingElement || Br : ft)
                              .style),
                            value: V["overflow" + dt.a.toUpperCase()],
                          }),
                          gt &&
                            "scroll" !==
                              ra(zr)["overflow" + dt.a.toUpperCase()] &&
                            (V.style["overflow" + dt.a.toUpperCase()] =
                              "scroll")),
                        Ga(Q, y, E),
                        (x = qa(Q)),
                        (D = aa(Q, !0)),
                        (N = vt && wr(ft, R ? Tr : br)()),
                        tt
                          ? (((w = [tt + dt.os2, g + K + ia]).t = y),
                            (at = tt === Qs ? oa(Q, dt) + g + K : 0) &&
                              (w.push(dt.d, at + ia),
                              "auto" !== y.style.flexBasis &&
                                (y.style.flexBasis = at + ia)),
                            Xa(w),
                            rt &&
                              ya.forEach(function (t) {
                                t.pin === rt &&
                                  !1 !== t.vars.pinSpacing &&
                                  (t._subPinOffset = !0);
                              }),
                            vt && At(B))
                          : (at = oa(Q, dt)) &&
                            "auto" !== y.style.flexBasis &&
                            (y.style.flexBasis = at + ia),
                        vt &&
                          (((P = {
                            top: D.top + (R ? C - l : N) + ia,
                            left: D.left + (R ? N : C - l) + ia,
                            boxSizing: "border-box",
                            position: "fixed",
                          })[js] = P["max" + ea] =
                            Math.ceil(D.width) + ia),
                          (P[Ys] = P["max" + na] = Math.ceil(D.height) + ia),
                          (P[ta] =
                            P[ta + Js] =
                            P[ta + Ks] =
                            P[ta + $s] =
                            P[ta + Zs] =
                              "0"),
                          (P[Qs] = E[Qs]),
                          (P[Qs + Js] = E[Qs + Js]),
                          (P[Qs + Ks] = E[Qs + Ks]),
                          (P[Qs + $s] = E[Qs + $s]),
                          (P[Qs + Zs] = E[Qs + Zs]),
                          (_ = (function (t, e, n) {
                            for (
                              var i, r = [], s = t.length, a = n ? 8 : 0;
                              a < s;
                              a += 2
                            )
                              (i = t[a]), r.push(i, i in e ? e[i] : t[a + 1]);
                            return (r.t = t.t), r;
                          })(v, P, ot)),
                          ms && At(0)),
                        n
                          ? ((F = n._initted),
                            ts(1),
                            n.render(n.duration(), !0, !0),
                            (b = M(dt.a) - T + g + K),
                            (A = Math.abs(g - b) > 1),
                            vt && A && _.splice(_.length - 2, 2),
                            n.render(0, !0, !0),
                            F || n.invalidate(!0),
                            n.parent || n.totalTime(n.totalTime()),
                            ts(0))
                          : (b = g),
                        V &&
                          (V.value
                            ? (V.style["overflow" + dt.a.toUpperCase()] =
                                V.value)
                            : V.style.removeProperty("overflow-" + dt.a));
                    k &&
                      k.forEach(function (t) {
                        return t.revert(!1, !0);
                      }),
                      (Mt.start = l),
                      (Mt.end = c),
                      (a = o = ms ? B : At()),
                      ct || ms || (a < B && At(B), (Mt.scroll.rec = 0)),
                      Mt.revert(!1, !0),
                      (wt = xs()),
                      O && ((Dt = -1), O.restart(!0)),
                      (qr = 0),
                      n &&
                        pt &&
                        (n._initted || z) &&
                        n.progress() !== z &&
                        n.progress(z || 0, !0).render(n.time(), !0, !0),
                      (j || Ct !== Mt.progress || ct || et) &&
                        (n &&
                          !pt &&
                          n.totalProgress(
                            ct && l < -0.001 && !Ct
                              ? Ur.utils.normalize(l, c, 0)
                              : Ct,
                            !0
                          ),
                        (Mt.progress = j || (a - l) / g === Ct ? 0 : Ct)),
                      Q && tt && (y._pinOffset = Math.round(Mt.progress * b)),
                      U && U.invalidate(),
                      isNaN(H) ||
                        ((H -= Ur.getProperty(d, dt.p)),
                        (G -= Ur.getProperty(p, dt.p)),
                        $a(d, dt, H),
                        $a(u, dt, H - (S || 0)),
                        $a(p, dt, G),
                        $a(h, dt, G - (S || 0))),
                      j && !ms && Mt.update(),
                      !Z || ms || m || ((m = !0), Z(Mt), (m = !1));
                  }
              }),
              (Mt.getVelocity = function () {
                return ((At() - o) / (xs() - Wr)) * 1e3 || 0;
              }),
              (Mt.endAnimation = function () {
                Vs(Mt.callbackAnimation),
                  n &&
                    (U
                      ? U.progress(1)
                      : n.paused()
                      ? pt || Vs(n, Mt.direction < 0, 1)
                      : Vs(n, n.reversed()));
              }),
              (Mt.labelToScroll = function (t) {
                return (
                  (n &&
                    n.labels &&
                    (l || Mt.refresh() || l) +
                      (n.labels[t] / n.duration()) * g) ||
                  0
                );
              }),
              (Mt.getTrailing = function (t) {
                var e = ya.indexOf(Mt),
                  n =
                    Mt.direction > 0
                      ? ya.slice(0, e).reverse()
                      : ya.slice(e + 1);
                return (
                  Os(t)
                    ? n.filter(function (e) {
                        return e.vars.preventOverlaps === t;
                      })
                    : n
                ).filter(function (t) {
                  return Mt.direction > 0 ? t.end <= l : t.start >= c;
                });
              }),
              (Mt.update = function (t, e, r) {
                if (!ct || r || t) {
                  var s,
                    u,
                    h,
                    p,
                    f,
                    m,
                    v,
                    S = !0 === ms ? B : Mt.scroll(),
                    M = t ? 0 : (S - l) / g,
                    w = M < 0 ? 0 : M > 1 ? 1 : M || 0,
                    P = Mt.progress;
                  if (
                    (e &&
                      ((o = a),
                      (a = ct ? At() : S),
                      at && ((I = L), (L = n && !pt ? n.totalProgress() : w))),
                    nt &&
                      Q &&
                      !qr &&
                      !_s &&
                      Ss &&
                      (!w && l < S + ((S - o) / (xs() - Wr)) * nt
                        ? (w = 1e-4)
                        : 1 === w &&
                          c > S + ((S - o) / (xs() - Wr)) * nt &&
                          (w = 0.9999)),
                    w !== P && Mt.enabled)
                  ) {
                    if (
                      ((p =
                        (f =
                          (s = Mt.isActive = !!w && w < 1) != (!!P && P < 1)) ||
                        !!w != !!P),
                      (Mt.direction = w > P ? 1 : -1),
                      (Mt.progress = w),
                      p &&
                        !qr &&
                        ((u = w && !P ? 0 : 1 === w ? 1 : 1 === P ? 2 : 3),
                        pt &&
                          ((h =
                            (!f && "none" !== xt[u + 1] && xt[u + 1]) || xt[u]),
                          (v =
                            n &&
                            ("complete" === h || "reset" === h || h in n)))),
                      ht &&
                        (f || v) &&
                        (v || J || !n) &&
                        (Bs(ht)
                          ? ht(Mt)
                          : Mt.getTrailing(ht).forEach(function (t) {
                              return t.endAnimation();
                            })),
                      pt ||
                        (!U || qr || _s
                          ? n && n.totalProgress(w, !(!qr || (!wt && !t)))
                          : (U._dp._time - U._start !== U._time &&
                              U.render(U._dp._time - U._start),
                            U.resetTo
                              ? U.resetTo(
                                  "totalProgress",
                                  w,
                                  n._tTime / n._tDur
                                )
                              : ((U.vars.totalProgress = w),
                                U.invalidate().restart()))),
                      Q)
                    )
                      if ((t && tt && (y.style[tt + dt.os2] = D), vt)) {
                        if (p) {
                          if (
                            ((m =
                              !t && w > P && c + 1 > S && S + 1 >= Ns(ft, dt)),
                            ot)
                          )
                            if (t || (!s && !m)) Za(Q, y);
                            else {
                              var N = aa(Q, !0),
                                F = S - l;
                              Za(
                                Q,
                                zr,
                                N.top + (dt === br ? F : 0) + ia,
                                N.left + (dt === br ? 0 : F) + ia
                              );
                            }
                          Xa(s || m ? _ : x),
                            (A && w < 1 && s) || E(T + (1 !== w || m ? 0 : b));
                        }
                      } else E(As(T + b * w));
                    at && !i.tween && !qr && !_s && O.restart(!0),
                      j &&
                        (f || (st && w && (w < 1 || !ps))) &&
                        Hr(j.targets).forEach(function (t) {
                          return t.classList[s || st ? "add" : "remove"](
                            j.className
                          );
                        }),
                      q && !pt && !t && q(Mt),
                      p && !qr
                        ? (pt &&
                            (v &&
                              ("complete" === h
                                ? n.pause().totalProgress(1)
                                : "reset" === h
                                ? n.restart(!0).pause()
                                : "restart" === h
                                ? n.restart(!0)
                                : n[h]()),
                            q && q(Mt)),
                          (!f && ps) ||
                            (K && f && Hs(Mt, K),
                            _t[u] && Hs(Mt, _t[u]),
                            st && (1 === w ? Mt.kill(!1, 1) : (_t[u] = 0)),
                            f || (_t[(u = 1 === w ? 1 : 3)] && Hs(Mt, _t[u]))),
                          ut &&
                            !s &&
                            Math.abs(Mt.getVelocity()) > (zs(ut) ? ut : 2500) &&
                            (Vs(Mt.callbackAnimation),
                            U
                              ? U.progress(1)
                              : Vs(n, "reverse" === h ? 1 : !w, 1)))
                        : pt && q && !qr && q(Mt);
                  }
                  if (R) {
                    var z = ct
                      ? (S / ct.duration()) * (ct._caScrollDist || 0)
                      : S;
                    C(z + (d._isFlipped ? 1 : 0)), R(z);
                  }
                  k && k((-S / ct.duration()) * (ct._caScrollDist || 0));
                }
              }),
              (Mt.enable = function (e, n) {
                Mt.enabled ||
                  ((Mt.enabled = !0),
                  ha(ft, "resize", ba),
                  gt || ha(ft, "scroll", Ea),
                  Et && ha(t, "refreshInit", Et),
                  !1 !== e && ((Mt.progress = Ct = 0), (a = o = Dt = At())),
                  !1 !== n && Mt.refresh());
              }),
              (Mt.getTween = function (t) {
                return t && i ? i.tween : U;
              }),
              (Mt.setPositions = function (t, e, n, i) {
                if (ct) {
                  var r = ct.scrollTrigger,
                    s = ct.duration(),
                    a = r.end - r.start;
                  (t = r.start + (a * t) / s), (e = r.start + (a * e) / s);
                }
                Mt.refresh(
                  !1,
                  !1,
                  {
                    start: Ts(t, n && !!Mt._startClamp),
                    end: Ts(e, n && !!Mt._endClamp),
                  },
                  i
                ),
                  Mt.update();
              }),
              (Mt.adjustPinSpacing = function (t) {
                if (w && t) {
                  var e = w.indexOf(dt.d) + 1;
                  (w[e] = parseFloat(w[e]) + t + ia),
                    (w[1] = parseFloat(w[1]) + t + ia),
                    Xa(w);
                }
              }),
              (Mt.disable = function (e, n) {
                if (
                  Mt.enabled &&
                  (!1 !== e && Mt.revert(!0, !0),
                  (Mt.enabled = Mt.isActive = !1),
                  n || (U && U.pause()),
                  (B = 0),
                  r && (r.uncache = 1),
                  Et && da(t, "refreshInit", Et),
                  O && (O.pause(), i.tween && i.tween.kill() && (i.tween = 0)),
                  !gt)
                ) {
                  for (var s = ya.length; s--; )
                    if (ya[s].scroller === ft && ya[s] !== Mt) return;
                  da(ft, "resize", ba), gt || da(ft, "scroll", Ea);
                }
              }),
              (Mt.kill = function (t, i) {
                Mt.disable(t, i), U && !i && U.kill(), Y && delete Sa[Y];
                var s = ya.indexOf(Mt);
                s >= 0 && ya.splice(s, 1),
                  s === Kr && za > 0 && Kr--,
                  (s = 0),
                  ya.forEach(function (t) {
                    return t.scroller === Mt.scroller && (s = 1);
                  }),
                  s || ms || (Mt.scroll.rec = 0),
                  n &&
                    ((n.scrollTrigger = null),
                    t && n.revert({ kill: !1 }),
                    i || n.kill()),
                  u &&
                    [u, h, d, p].forEach(function (t) {
                      return t.parentNode && t.parentNode.removeChild(t);
                    }),
                  vs === Mt && (vs = 0),
                  Q &&
                    (r && (r.uncache = 1),
                    (s = 0),
                    ya.forEach(function (t) {
                      return t.pin === Q && s++;
                    }),
                    s || (r.spacer = 0)),
                  e.onKill && e.onKill(Mt);
              }),
              ya.push(Mt),
              Mt.enable(!1, !1),
              V && V(Mt),
              n && n.add && !g)
            ) {
              var It = Mt.update;
              (Mt.update = function () {
                (Mt.update = It), l || c || Mt.refresh();
              }),
                Ur.delayedCall(0.01, Mt.update),
                (g = 0.01),
                (l = c = 0);
            } else Mt.refresh();
            Q &&
              (function () {
                if (gs !== Ua) {
                  var t = (gs = Ua);
                  requestAnimationFrame(function () {
                    return t === Ua && Oa(!0);
                  });
                }
              })();
          } else this.update = this.refresh = this.kill = Cs;
        }),
        (t.register = function (e) {
          return (
            Nr ||
              ((Ur = e || Ps()),
              Rs() && window.document && t.enable(),
              (Nr = Ms)),
            Nr
          );
        }),
        (t.defaults = function (t) {
          if (t) for (var e in t) ma[e] = t[e];
          return ma;
        }),
        (t.disable = function (t, e) {
          (Ms = 0),
            ya.forEach(function (n) {
              return n[e ? "kill" : "disable"](t);
            }),
            da(Fr, "wheel", Ea),
            da(Or, "scroll", Ea),
            clearInterval(Xr),
            da(Or, "touchcancel", Cs),
            da(zr, "touchstart", Cs),
            ua(da, Or, "pointerdown,touchstart,mousedown", Ds),
            ua(da, Or, "pointerup,touchend,mouseup", ws),
            Vr.kill(),
            Fs(da);
          for (var n = 0; n < dr.length; n += 3)
            pa(da, dr[n], dr[n + 1]), pa(da, dr[n], dr[n + 2]);
        }),
        (t.enable = function () {
          if (
            ((Fr = window),
            (Or = document),
            (Br = Or.documentElement),
            (zr = Or.body),
            Ur &&
              ((Hr = Ur.utils.toArray),
              (Gr = Ur.utils.clamp),
              (os = Ur.core.context || Cs),
              (ts = Ur.core.suppressOverwrites || Cs),
              (ls = Fr.history.scrollRestoration || "auto"),
              (Ba = Fr.pageYOffset),
              Ur.core.globals("ScrollTrigger", t),
              zr))
          ) {
            (Ms = 1),
              ((cs = document.createElement("div")).style.height = "100vh"),
              (cs.style.position = "absolute"),
              Na(),
              bs(),
              Ir.register(Ur),
              (t.isTouch = Ir.isTouch),
              (as =
                Ir.isTouch &&
                /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent)),
              (is = 1 === Ir.isTouch),
              ha(Fr, "wheel", Ea),
              (kr = [Fr, Or, Br, zr]),
              Ur.matchMedia
                ? ((t.matchMedia = function (t) {
                    var e,
                      n = Ur.matchMedia();
                    for (e in t) n.add(e, t[e]);
                    return n;
                  }),
                  Ur.addEventListener("matchMediaInit", function () {
                    return La();
                  }),
                  Ur.addEventListener("matchMediaRevert", function () {
                    return Pa();
                  }),
                  Ur.addEventListener("matchMedia", function () {
                    Oa(0, 1), Aa("matchMedia");
                  }),
                  Ur.matchMedia("(orientation: portrait)", function () {
                    return Ta(), Ta;
                  }))
                : console.warn("Requires GSAP 3.11.0 or later"),
              Ta(),
              ha(Or, "scroll", Ea);
            var e,
              n,
              i = zr.style,
              r = i.borderTopStyle,
              s = Ur.core.Animation.prototype;
            for (
              s.revert ||
                Object.defineProperty(s, "revert", {
                  value: function () {
                    return this.time(-0.01, !0);
                  },
                }),
                i.borderTopStyle = "solid",
                e = aa(zr),
                r
                  ? (i.borderTopStyle = r)
                  : i.removeProperty("border-top-style"),
                Xr = setInterval(Ma, 250),
                Ur.delayedCall(0.5, function () {
                  return (_s = 0);
                }),
                ha(Or, "touchcancel", Cs),
                ha(zr, "touchstart", Cs),
                ua(ha, Or, "pointerdown,touchstart,mousedown", Ds),
                ua(ha, Or, "pointerup,touchend,mouseup", ws),
                Yr = Ur.utils.checkPrefix("transform"),
                Ha.push(Yr),
                Nr = xs(),
                Vr = Ur.delayedCall(0.2, Oa).pause(),
                $r = [
                  Or,
                  "visibilitychange",
                  function () {
                    var t = Fr.innerWidth,
                      e = Fr.innerHeight;
                    Or.hidden
                      ? ((Zr = t), (Jr = e))
                      : (Zr === t && Jr === e) || ba();
                  },
                  Or,
                  "DOMContentLoaded",
                  Oa,
                  Fr,
                  "load",
                  Oa,
                  Fr,
                  "resize",
                  ba,
                ],
                Fs(ha),
                ya.forEach(function (t) {
                  return t.enable(0, 1);
                }),
                n = 0;
              n < dr.length;
              n += 3
            )
              pa(da, dr[n], dr[n + 1]), pa(da, dr[n], dr[n + 2]);
          }
        }),
        (t.config = function (e) {
          "limitCallbacks" in e && (ps = !!e.limitCallbacks);
          var n = e.syncInterval;
          (n && clearInterval(Xr)) || ((Xr = n) && setInterval(Ma, n)),
            "ignoreMobileResize" in e &&
              (is = 1 === t.isTouch && e.ignoreMobileResize),
            "autoRefreshEvents" in e &&
              (Fs(da) || Fs(ha, e.autoRefreshEvents || "none"),
              (es = -1 === (e.autoRefreshEvents + "").indexOf("resize")));
        }),
        (t.scrollerProxy = function (t, e) {
          var n = Dr(t),
            i = dr.indexOf(n),
            r = Ls(n);
          ~i && dr.splice(i, r ? 6 : 2),
            e && (r ? pr.unshift(Fr, e, zr, e, Br, e) : pr.unshift(n, e));
        }),
        (t.clearMatchMedia = function (t) {
          ya.forEach(function (e) {
            return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0);
          });
        }),
        (t.isInViewport = function (t, e, n) {
          var i = (Os(t) ? Dr(t) : t).getBoundingClientRect(),
            r = i[n ? js : Ys] * e || 0;
          return n
            ? i.right - r > 0 && i.left + r < Fr.innerWidth
            : i.bottom - r > 0 && i.top + r < Fr.innerHeight;
        }),
        (t.positionInViewport = function (t, e, n) {
          Os(t) && (t = Dr(t));
          var i = t.getBoundingClientRect(),
            r = i[n ? js : Ys],
            s =
              null == e
                ? r / 2
                : e in ga
                ? ga[e] * r
                : ~e.indexOf("%")
                ? (parseFloat(e) * r) / 100
                : parseFloat(e) || 0;
          return n
            ? (i.left + s) / Fr.innerWidth
            : (i.top + s) / Fr.innerHeight;
        }),
        (t.killAll = function (t) {
          if (
            (ya.slice(0).forEach(function (t) {
              return "ScrollSmoother" !== t.vars.id && t.kill();
            }),
            !0 !== t)
          ) {
            var e = Da.killAll || [];
            (Da = {}),
              e.forEach(function (t) {
                return t();
              });
          }
        }),
        t
      );
    })();
  (to.version = "3.12.5"),
    (to.saveStyles = function (t) {
      return t
        ? Hr(t).forEach(function (t) {
            if (t && t.style) {
              var e = Ra.indexOf(t);
              e >= 0 && Ra.splice(e, 5),
                Ra.push(
                  t,
                  t.style.cssText,
                  t.getBBox && t.getAttribute("transform"),
                  Ur.core.getCache(t),
                  os()
                );
            }
          })
        : Ra;
    }),
    (to.revert = function (t, e) {
      return La(!t, e);
    }),
    (to.create = function (t, e) {
      return new to(t, e);
    }),
    (to.refresh = function (t) {
      return t ? ba() : (Nr || to.register()) && Oa(!0);
    }),
    (to.update = function (t) {
      return ++dr.cache && ka(!0 === t ? 2 : 0);
    }),
    (to.clearScrollMemory = Ia),
    (to.maxScroll = function (t, e) {
      return Ns(t, e ? Tr : br);
    }),
    (to.getScrollFunc = function (t, e) {
      return wr(Dr(t), e ? Tr : br);
    }),
    (to.getById = function (t) {
      return Sa[t];
    }),
    (to.getAll = function () {
      return ya.filter(function (t) {
        return "ScrollSmoother" !== t.vars.id;
      });
    }),
    (to.isScrolling = function () {
      return !!Ss;
    }),
    (to.snapDirectional = ca),
    (to.addEventListener = function (t, e) {
      var n = Da[t] || (Da[t] = []);
      ~n.indexOf(e) || n.push(e);
    }),
    (to.removeEventListener = function (t, e) {
      var n = Da[t],
        i = n && n.indexOf(e);
      i >= 0 && n.splice(i, 1);
    }),
    (to.batch = function (t, e) {
      var n,
        i = [],
        r = {},
        s = e.interval || 0.016,
        a = e.batchMax || 1e9,
        o = function (t, e) {
          var n = [],
            i = [],
            r = Ur.delayedCall(s, function () {
              e(n, i), (n = []), (i = []);
            }).pause();
          return function (t) {
            n.length || r.restart(!0),
              n.push(t.trigger),
              i.push(t),
              a <= n.length && r.progress(1);
          };
        };
      for (n in e)
        r[n] =
          "on" === n.substr(0, 2) && Bs(e[n]) && "onRefreshInit" !== n
            ? o(0, e[n])
            : e[n];
      return (
        Bs(a) &&
          ((a = a()),
          ha(to, "refresh", function () {
            return (a = e.batchMax());
          })),
        Hr(t).forEach(function (t) {
          var e = {};
          for (n in r) e[n] = r[n];
          (e.trigger = t), i.push(to.create(e));
        }),
        i
      );
    });
  var eo,
    no = function (t, e, n, i) {
      return (
        e > i ? t(i) : e < 0 && t(0),
        n > i ? (i - e) / (n - e) : n < 0 ? e / (e - n) : 1
      );
    },
    io = function t(e, n) {
      !0 === n
        ? e.style.removeProperty("touch-action")
        : (e.style.touchAction =
            !0 === n
              ? "auto"
              : n
              ? "pan-" + n + (Ir.isTouch ? " pinch-zoom" : "")
              : "none"),
        e === Br && t(zr, n);
    },
    ro = { auto: 1, scroll: 1 },
    so = function (t) {
      var e,
        n = t.event,
        i = t.target,
        r = t.axis,
        s = (n.changedTouches ? n.changedTouches[0] : n).target,
        a = s._gsap || Ur.core.getCache(s),
        o = xs();
      if (!a._isScrollT || o - a._isScrollT > 2e3) {
        for (
          ;
          s &&
          s !== zr &&
          ((s.scrollHeight <= s.clientHeight &&
            s.scrollWidth <= s.clientWidth) ||
            (!ro[(e = ra(s)).overflowY] && !ro[e.overflowX]));

        )
          s = s.parentNode;
        (a._isScroll =
          s &&
          s !== i &&
          !Ls(s) &&
          (ro[(e = ra(s)).overflowY] || ro[e.overflowX])),
          (a._isScrollT = o);
      }
      (a._isScroll || "x" === r) && (n.stopPropagation(), (n._gsapAllow = !0));
    },
    ao = function (t, e, n, i) {
      return Ir.create({
        target: t,
        capture: !0,
        debounce: !1,
        lockAxis: !0,
        type: e,
        onWheel: (i = i && so),
        onPress: i,
        onDrag: i,
        onScroll: i,
        onEnable: function () {
          return n && ha(Or, Ir.eventTypes[0], lo, !1, !0);
        },
        onDisable: function () {
          return da(Or, Ir.eventTypes[0], lo, !0);
        },
      });
    },
    oo = /(input|label|select|textarea)/i,
    lo = function (t) {
      var e = oo.test(t.target.tagName);
      (e || eo) && ((t._gsapAllow = !0), (eo = e));
    };
  (to.sort = function (t) {
    return ya.sort(
      t ||
        function (t, e) {
          return (
            -1e6 * (t.vars.refreshPriority || 0) +
            t.start -
            (e.start + -1e6 * (e.vars.refreshPriority || 0))
          );
        }
    );
  }),
    (to.observe = function (t) {
      return new Ir(t);
    }),
    (to.normalizeScroll = function (t) {
      if (void 0 === t) return ns;
      if (!0 === t && ns) return ns.enable();
      if (!1 === t) return ns && ns.kill(), void (ns = t);
      var e =
        t instanceof Ir
          ? t
          : (function (t) {
              ks(t) || (t = {}),
                (t.preventDefault = t.isNormalizer = t.allowClicks = !0),
                t.type || (t.type = "wheel,touch"),
                (t.debounce = !!t.debounce),
                (t.id = t.id || "normalizer");
              var e,
                n,
                i,
                r,
                s,
                a,
                o,
                l,
                c = t,
                u = c.normalizeScrollX,
                h = c.momentum,
                d = c.allowNestedScroll,
                p = c.onRelease,
                f = Dr(t.target) || Br,
                m = Ur.core.globals().ScrollSmoother,
                g = m && m.get(),
                v =
                  as &&
                  ((t.content && Dr(t.content)) ||
                    (g && !1 !== t.content && !g.smooth() && g.content())),
                _ = wr(f, br),
                x = wr(f, Tr),
                y = 1,
                S =
                  (Ir.isTouch && Fr.visualViewport
                    ? Fr.visualViewport.scale * Fr.visualViewport.width
                    : Fr.outerWidth) / Fr.innerWidth,
                M = 0,
                E = Bs(h)
                  ? function () {
                      return h(e);
                    }
                  : function () {
                      return h || 2.8;
                    },
                T = ao(f, t.type, !0, d),
                b = function () {
                  return (r = !1);
                },
                D = Cs,
                w = Cs,
                C = function () {
                  (n = Ns(f, br)),
                    (w = Gr(as ? 1 : 0, n)),
                    u && (D = Gr(0, Ns(f, Tr))),
                    (i = Ua);
                },
                A = function () {
                  (v._gsap.y = As(parseFloat(v._gsap.y) + _.offset) + "px"),
                    (v.style.transform =
                      "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
                      parseFloat(v._gsap.y) +
                      ", 0, 1)"),
                    (_.offset = _.cacheID = 0);
                },
                R = function () {
                  C(),
                    s.isActive() &&
                      s.vars.scrollY > n &&
                      (_() > n
                        ? s.progress(1) && _(n)
                        : s.resetTo("scrollY", n));
                };
              return (
                v && Ur.set(v, { y: "+=0" }),
                (t.ignoreCheck = function (t) {
                  return (
                    (as &&
                      "touchmove" === t.type &&
                      (function () {
                        if (r) {
                          requestAnimationFrame(b);
                          var t = As(e.deltaY / 2),
                            n = w(_.v - t);
                          if (v && n !== _.v + _.offset) {
                            _.offset = n - _.v;
                            var i = As(
                              (parseFloat(v && v._gsap.y) || 0) - _.offset
                            );
                            (v.style.transform =
                              "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
                              i +
                              ", 0, 1)"),
                              (v._gsap.y = i + "px"),
                              (_.cacheID = dr.cache),
                              ka();
                          }
                          return !0;
                        }
                        _.offset && A(), (r = !0);
                      })()) ||
                    (y > 1.05 && "touchstart" !== t.type) ||
                    e.isGesturing ||
                    (t.touches && t.touches.length > 1)
                  );
                }),
                (t.onPress = function () {
                  r = !1;
                  var t = y;
                  (y = As(
                    ((Fr.visualViewport && Fr.visualViewport.scale) || 1) / S
                  )),
                    s.pause(),
                    t !== y && io(f, y > 1.01 || (!u && "x")),
                    (a = x()),
                    (o = _()),
                    C(),
                    (i = Ua);
                }),
                (t.onRelease = t.onGestureStart =
                  function (t, e) {
                    if ((_.offset && A(), e)) {
                      dr.cache++;
                      var i,
                        r,
                        a = E();
                      u &&
                        ((r = (i = x()) + (0.05 * a * -t.velocityX) / 0.227),
                        (a *= no(x, i, r, Ns(f, Tr))),
                        (s.vars.scrollX = D(r))),
                        (r = (i = _()) + (0.05 * a * -t.velocityY) / 0.227),
                        (a *= no(_, i, r, Ns(f, br))),
                        (s.vars.scrollY = w(r)),
                        s.invalidate().duration(a).play(0.01),
                        ((as && s.vars.scrollY >= n) || i >= n - 1) &&
                          Ur.to({}, { onUpdate: R, duration: a });
                    } else l.restart(!0);
                    p && p(t);
                  }),
                (t.onWheel = function () {
                  s._ts && s.pause(), xs() - M > 1e3 && ((i = 0), (M = xs()));
                }),
                (t.onChange = function (t, e, n, r, s) {
                  if (
                    (Ua !== i && C(),
                    e &&
                      u &&
                      x(D(r[2] === e ? a + (t.startX - t.x) : x() + e - r[1])),
                    n)
                  ) {
                    _.offset && A();
                    var l = s[2] === n,
                      c = l ? o + t.startY - t.y : _() + n - s[1],
                      h = w(c);
                    l && c !== h && (o += h - c), _(h);
                  }
                  (n || e) && ka();
                }),
                (t.onEnable = function () {
                  io(f, !u && "x"),
                    to.addEventListener("refresh", R),
                    ha(Fr, "resize", R),
                    _.smooth &&
                      ((_.target.style.scrollBehavior = "auto"),
                      (_.smooth = x.smooth = !1)),
                    T.enable();
                }),
                (t.onDisable = function () {
                  io(f, !0),
                    da(Fr, "resize", R),
                    to.removeEventListener("refresh", R),
                    T.kill();
                }),
                (t.lockAxis = !1 !== t.lockAxis),
                ((e = new Ir(t)).iOS = as),
                as && !_() && _(1),
                as && Ur.ticker.add(Cs),
                (l = e._dc),
                (s = Ur.to(e, {
                  ease: "power4",
                  paused: !0,
                  inherit: !1,
                  scrollX: u ? "+=0.1" : "+=0",
                  scrollY: "+=0.1",
                  modifiers: {
                    scrollY: Ja(_, _(), function () {
                      return s.pause();
                    }),
                  },
                  onUpdate: ka,
                  onComplete: l.vars.onComplete,
                })),
                e
              );
            })(t);
      return (
        ns && ns.target === e.target && ns.kill(), Ls(e.target) && (ns = e), e
      );
    }),
    (to.core = {
      _getVelocityProp: Cr,
      _inputObserver: ao,
      _scrollers: dr,
      _proxies: pr,
      bridge: {
        ss: function () {
          Ss || Aa("scrollStart"), (Ss = xs());
        },
        ref: function () {
          return qr;
        },
      },
    }),
    Ps() && Ur.registerPlugin(to);
  var co,
    uo,
    ho,
    po,
    fo,
    mo,
    go,
    vo,
    _o = function () {
      return "undefined" != typeof window;
    },
    xo = function () {
      return co || (_o() && (co = window.gsap) && co.registerPlugin && co);
    },
    yo = function (t) {
      return "string" == typeof t;
    },
    So = function (t) {
      return "function" == typeof t;
    },
    Mo = function (t, e) {
      var n = "x" === e ? "Width" : "Height",
        i = "scroll" + n,
        r = "client" + n;
      return t === ho || t === po || t === fo
        ? Math.max(po[i], fo[i]) - (ho["inner" + n] || po[r] || fo[r])
        : t[i] - t["offset" + n];
    },
    Eo = function (t, e) {
      var n = "scroll" + ("x" === e ? "Left" : "Top");
      return (
        t === ho &&
          (null != t.pageXOffset
            ? (n = "page" + e.toUpperCase() + "Offset")
            : (t = null != po[n] ? po : fo)),
        function () {
          return t[n];
        }
      );
    },
    To = function (t, e) {
      if (!(t = mo(t)[0]) || !t.getBoundingClientRect)
        return (
          console.warn("scrollTo target doesn't exist. Using 0") || {
            x: 0,
            y: 0,
          }
        );
      var n = t.getBoundingClientRect(),
        i = !e || e === ho || e === fo,
        r = i
          ? {
              top:
                po.clientTop -
                (ho.pageYOffset || po.scrollTop || fo.scrollTop || 0),
              left:
                po.clientLeft -
                (ho.pageXOffset || po.scrollLeft || fo.scrollLeft || 0),
            }
          : e.getBoundingClientRect(),
        s = { x: n.left - r.left, y: n.top - r.top };
      return !i && e && ((s.x += Eo(e, "x")()), (s.y += Eo(e, "y")())), s;
    },
    bo = function (t, e, n, i, r) {
      return isNaN(t) || "object" == typeof t
        ? yo(t) && "=" === t.charAt(1)
          ? parseFloat(t.substr(2)) * ("-" === t.charAt(0) ? -1 : 1) + i - r
          : "max" === t
          ? Mo(e, n) - r
          : Math.min(Mo(e, n), To(t, e)[n] - r)
        : parseFloat(t) - r;
    },
    Do = function () {
      (co = xo()),
        _o() &&
          co &&
          "undefined" != typeof document &&
          document.body &&
          ((ho = window),
          (fo = document.body),
          (po = document.documentElement),
          (mo = co.utils.toArray),
          co.config({ autoKillThreshold: 7 }),
          (go = co.config()),
          (uo = 1));
    },
    wo = {
      version: "3.12.5",
      name: "scrollTo",
      rawVars: 1,
      register: function (t) {
        (co = t), Do();
      },
      init: function (t, e, n, i, r) {
        uo || Do();
        var s = this,
          a = co.getProperty(t, "scrollSnapType");
        (s.isWin = t === ho),
          (s.target = t),
          (s.tween = n),
          (e = (function (t, e, n, i) {
            if ((So(t) && (t = t(e, n, i)), "object" != typeof t))
              return yo(t) && "max" !== t && "=" !== t.charAt(1)
                ? { x: t, y: t }
                : { y: t };
            if (t.nodeType) return { y: t, x: t };
            var r,
              s = {};
            for (r in t)
              s[r] = "onAutoKill" !== r && So(t[r]) ? t[r](e, n, i) : t[r];
            return s;
          })(e, i, t, r)),
          (s.vars = e),
          (s.autoKill = !!e.autoKill),
          (s.getX = Eo(t, "x")),
          (s.getY = Eo(t, "y")),
          (s.x = s.xPrev = s.getX()),
          (s.y = s.yPrev = s.getY()),
          vo || (vo = co.core.globals().ScrollTrigger),
          "smooth" === co.getProperty(t, "scrollBehavior") &&
            co.set(t, { scrollBehavior: "auto" }),
          a &&
            "none" !== a &&
            ((s.snap = 1),
            (s.snapInline = t.style.scrollSnapType),
            (t.style.scrollSnapType = "none")),
          null != e.x
            ? (s.add(s, "x", s.x, bo(e.x, t, "x", s.x, e.offsetX || 0), i, r),
              s._props.push("scrollTo_x"))
            : (s.skipX = 1),
          null != e.y
            ? (s.add(s, "y", s.y, bo(e.y, t, "y", s.y, e.offsetY || 0), i, r),
              s._props.push("scrollTo_y"))
            : (s.skipY = 1);
      },
      render: function (t, e) {
        for (
          var n,
            i,
            r,
            s,
            a,
            o = e._pt,
            l = e.target,
            c = e.tween,
            u = e.autoKill,
            h = e.xPrev,
            d = e.yPrev,
            p = e.isWin,
            f = e.snap,
            m = e.snapInline;
          o;

        )
          o.r(t, o.d), (o = o._next);
        (n = p || !e.skipX ? e.getX() : h),
          (r = (i = p || !e.skipY ? e.getY() : d) - d),
          (s = n - h),
          (a = go.autoKillThreshold),
          e.x < 0 && (e.x = 0),
          e.y < 0 && (e.y = 0),
          u &&
            (!e.skipX && (s > a || s < -a) && n < Mo(l, "x") && (e.skipX = 1),
            !e.skipY && (r > a || r < -a) && i < Mo(l, "y") && (e.skipY = 1),
            e.skipX &&
              e.skipY &&
              (c.kill(),
              e.vars.onAutoKill &&
                e.vars.onAutoKill.apply(c, e.vars.onAutoKillParams || []))),
          p
            ? ho.scrollTo(e.skipX ? n : e.x, e.skipY ? i : e.y)
            : (e.skipY || (l.scrollTop = e.y), e.skipX || (l.scrollLeft = e.x)),
          !f ||
            (1 !== t && 0 !== t) ||
            ((i = l.scrollTop),
            (n = l.scrollLeft),
            m
              ? (l.style.scrollSnapType = m)
              : l.style.removeProperty("scroll-snap-type"),
            (l.scrollTop = i + 1),
            (l.scrollLeft = n + 1),
            (l.scrollTop = i),
            (l.scrollLeft = n)),
          (e.xPrev = e.x),
          (e.yPrev = e.y),
          vo && vo.update();
      },
      kill: function (t) {
        var e = "scrollTo" === t,
          n = this._props.indexOf(t);
        return (
          (e || "scrollTo_x" === t) && (this.skipX = 1),
          (e || "scrollTo_y" === t) && (this.skipY = 1),
          n > -1 && this._props.splice(n, 1),
          !this._props.length
        );
      },
    };
  function Co(t, e, n) {
    return Math.max(t, Math.min(e, n));
  }
  (wo.max = Mo),
    (wo.getOffset = To),
    (wo.buildGetter = Eo),
    xo() && co.registerPlugin(wo);
  class Ao {
    advance(t) {
      if (!this.isRunning) return;
      let e = !1;
      if (this.lerp)
        (this.value =
          ((n = this.value),
          (i = this.to),
          (r = 60 * this.lerp),
          (s = t),
          (function (t, e, n) {
            return (1 - n) * t + n * e;
          })(n, i, 1 - Math.exp(-r * s)))),
          Math.round(this.value) === this.to &&
            ((this.value = this.to), (e = !0));
      else {
        this.currentTime += t;
        const n = Co(0, this.currentTime / this.duration, 1);
        e = n >= 1;
        const i = e ? 1 : this.easing(n);
        this.value = this.from + (this.to - this.from) * i;
      }
      var n, i, r, s;
      this.onUpdate?.(this.value, e), e && this.stop();
    }
    stop() {
      this.isRunning = !1;
    }
    fromTo(
      t,
      e,
      {
        lerp: n = 0.1,
        duration: i = 1,
        easing: r = (t) => t,
        onStart: s,
        onUpdate: a,
      }
    ) {
      (this.from = this.value = t),
        (this.to = e),
        (this.lerp = n),
        (this.duration = i),
        (this.easing = r),
        (this.currentTime = 0),
        (this.isRunning = !0),
        s?.(),
        (this.onUpdate = a);
    }
  }
  class Ro {
    constructor({
      wrapper: t,
      content: e,
      autoResize: n = !0,
      debounce: i = 250,
    } = {}) {
      (this.wrapper = t),
        (this.content = e),
        n &&
          ((this.debouncedResize = (function (t, e) {
            let n;
            return function () {
              let i = arguments,
                r = this;
              clearTimeout(n),
                (n = setTimeout(function () {
                  t.apply(r, i);
                }, e));
            };
          })(this.resize, i)),
          this.wrapper === window
            ? window.addEventListener("resize", this.debouncedResize, !1)
            : ((this.wrapperResizeObserver = new ResizeObserver(
                this.debouncedResize
              )),
              this.wrapperResizeObserver.observe(this.wrapper)),
          (this.contentResizeObserver = new ResizeObserver(
            this.debouncedResize
          )),
          this.contentResizeObserver.observe(this.content)),
        this.resize();
    }
    destroy() {
      this.wrapperResizeObserver?.disconnect(),
        this.contentResizeObserver?.disconnect(),
        window.removeEventListener("resize", this.debouncedResize, !1);
    }
    resize = () => {
      this.onWrapperResize(), this.onContentResize();
    };
    onWrapperResize = () => {
      this.wrapper === window
        ? ((this.width = window.innerWidth), (this.height = window.innerHeight))
        : ((this.width = this.wrapper.clientWidth),
          (this.height = this.wrapper.clientHeight));
    };
    onContentResize = () => {
      this.wrapper === window
        ? ((this.scrollHeight = this.content.scrollHeight),
          (this.scrollWidth = this.content.scrollWidth))
        : ((this.scrollHeight = this.wrapper.scrollHeight),
          (this.scrollWidth = this.wrapper.scrollWidth));
    };
    get limit() {
      return {
        x: this.scrollWidth - this.width,
        y: this.scrollHeight - this.height,
      };
    }
  }
  class Po {
    constructor() {
      this.events = {};
    }
    emit(t, ...e) {
      let n = this.events[t] || [];
      for (let t = 0, i = n.length; t < i; t++) n[t](...e);
    }
    on(t, e) {
      return (
        this.events[t]?.push(e) || (this.events[t] = [e]),
        () => {
          this.events[t] = this.events[t]?.filter((t) => e !== t);
        }
      );
    }
    off(t, e) {
      this.events[t] = this.events[t]?.filter((t) => e !== t);
    }
    destroy() {
      this.events = {};
    }
  }
  const Lo = 100 / 6;
  class Io {
    constructor(t, { wheelMultiplier: e = 1, touchMultiplier: n = 1 }) {
      (this.element = t),
        (this.wheelMultiplier = e),
        (this.touchMultiplier = n),
        (this.touchStart = { x: null, y: null }),
        (this.emitter = new Po()),
        window.addEventListener("resize", this.onWindowResize, !1),
        this.onWindowResize(),
        this.element.addEventListener("wheel", this.onWheel, { passive: !1 }),
        this.element.addEventListener("touchstart", this.onTouchStart, {
          passive: !1,
        }),
        this.element.addEventListener("touchmove", this.onTouchMove, {
          passive: !1,
        }),
        this.element.addEventListener("touchend", this.onTouchEnd, {
          passive: !1,
        });
    }
    on(t, e) {
      return this.emitter.on(t, e);
    }
    destroy() {
      this.emitter.destroy(),
        window.removeEventListener("resize", this.onWindowResize, !1),
        this.element.removeEventListener("wheel", this.onWheel, {
          passive: !1,
        }),
        this.element.removeEventListener("touchstart", this.onTouchStart, {
          passive: !1,
        }),
        this.element.removeEventListener("touchmove", this.onTouchMove, {
          passive: !1,
        }),
        this.element.removeEventListener("touchend", this.onTouchEnd, {
          passive: !1,
        });
    }
    onTouchStart = (t) => {
      const { clientX: e, clientY: n } = t.targetTouches
        ? t.targetTouches[0]
        : t;
      (this.touchStart.x = e),
        (this.touchStart.y = n),
        (this.lastDelta = { x: 0, y: 0 }),
        this.emitter.emit("scroll", { deltaX: 0, deltaY: 0, event: t });
    };
    onTouchMove = (t) => {
      const { clientX: e, clientY: n } = t.targetTouches
          ? t.targetTouches[0]
          : t,
        i = -(e - this.touchStart.x) * this.touchMultiplier,
        r = -(n - this.touchStart.y) * this.touchMultiplier;
      (this.touchStart.x = e),
        (this.touchStart.y = n),
        (this.lastDelta = { x: i, y: r }),
        this.emitter.emit("scroll", { deltaX: i, deltaY: r, event: t });
    };
    onTouchEnd = (t) => {
      this.emitter.emit("scroll", {
        deltaX: this.lastDelta.x,
        deltaY: this.lastDelta.y,
        event: t,
      });
    };
    onWheel = (t) => {
      let { deltaX: e, deltaY: n, deltaMode: i } = t;
      (e *= 1 === i ? Lo : 2 === i ? this.windowWidth : 1),
        (n *= 1 === i ? Lo : 2 === i ? this.windowHeight : 1),
        (e *= this.wheelMultiplier),
        (n *= this.wheelMultiplier),
        this.emitter.emit("scroll", { deltaX: e, deltaY: n, event: t });
    };
    onWindowResize = () => {
      (this.windowWidth = window.innerWidth),
        (this.windowHeight = window.innerHeight);
    };
  }
  class Uo {
    constructor({
      wrapper: t = window,
      content: e = document.documentElement,
      wheelEventsTarget: n = t,
      eventsTarget: i = n,
      smoothWheel: r = !0,
      syncTouch: s = !1,
      syncTouchLerp: a = 0.075,
      touchInertiaMultiplier: o = 35,
      duration: l,
      easing: c = (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
      lerp: u = !l && 0.1,
      infinite: h = !1,
      orientation: d = "vertical",
      gestureOrientation: p = "vertical",
      touchMultiplier: f = 1,
      wheelMultiplier: m = 1,
      autoResize: g = !0,
      __experimental__naiveDimensions: v = !1,
    } = {}) {
      (this.__isSmooth = !1),
        (this.__isScrolling = !1),
        (this.__isStopped = !1),
        (this.__isLocked = !1),
        (this.onVirtualScroll = ({ deltaX: t, deltaY: e, event: n }) => {
          if (n.ctrlKey) return;
          const i = n.type.includes("touch"),
            r = n.type.includes("wheel");
          if (
            this.options.syncTouch &&
            i &&
            "touchstart" === n.type &&
            !this.isStopped &&
            !this.isLocked
          )
            return void this.reset();
          const s = 0 === t && 0 === e,
            a =
              ("vertical" === this.options.gestureOrientation && 0 === e) ||
              ("horizontal" === this.options.gestureOrientation && 0 === t);
          if (s || a) return;
          let o = n.composedPath();
          if (
            ((o = o.slice(0, o.indexOf(this.rootElement))),
            o.find((t) => {
              var e, n, s, a, o;
              return (
                (null === (e = t.hasAttribute) || void 0 === e
                  ? void 0
                  : e.call(t, "data-lenis-prevent")) ||
                (i &&
                  (null === (n = t.hasAttribute) || void 0 === n
                    ? void 0
                    : n.call(t, "data-lenis-prevent-touch"))) ||
                (r &&
                  (null === (s = t.hasAttribute) || void 0 === s
                    ? void 0
                    : s.call(t, "data-lenis-prevent-wheel"))) ||
                ((null === (a = t.classList) || void 0 === a
                  ? void 0
                  : a.contains("lenis")) &&
                  !(null === (o = t.classList) || void 0 === o
                    ? void 0
                    : o.contains("lenis-stopped")))
              );
            }))
          )
            return;
          if (this.isStopped || this.isLocked) return void n.preventDefault();
          if (
            ((this.isSmooth =
              (this.options.syncTouch && i) || (this.options.smoothWheel && r)),
            !this.isSmooth)
          )
            return (this.isScrolling = !1), void this.animate.stop();
          n.preventDefault();
          let l = e;
          "both" === this.options.gestureOrientation
            ? (l = Math.abs(e) > Math.abs(t) ? e : t)
            : "horizontal" === this.options.gestureOrientation && (l = t);
          const c = i && this.options.syncTouch,
            u = i && "touchend" === n.type && Math.abs(l) > 5;
          u && (l = this.velocity * this.options.touchInertiaMultiplier),
            this.scrollTo(
              this.targetScroll + l,
              Object.assign(
                { programmatic: !1 },
                c
                  ? { lerp: u ? this.options.syncTouchLerp : 1 }
                  : {
                      lerp: this.options.lerp,
                      duration: this.options.duration,
                      easing: this.options.easing,
                    }
              )
            );
        }),
        (this.onNativeScroll = () => {
          if (!this.__preventNextScrollEvent && !this.isScrolling) {
            const t = this.animatedScroll;
            (this.animatedScroll = this.targetScroll = this.actualScroll),
              (this.velocity = 0),
              (this.direction = Math.sign(this.animatedScroll - t)),
              this.emit();
          }
        }),
        (window.lenisVersion = "1.0.42"),
        (this.options = {
          wrapper: t,
          content: e,
          wheelEventsTarget: n,
          eventsTarget: i,
          smoothWheel: r,
          syncTouch: s,
          syncTouchLerp: a,
          touchInertiaMultiplier: o,
          duration: l,
          easing: c,
          lerp: u,
          infinite: h,
          gestureOrientation: p,
          orientation: d,
          touchMultiplier: f,
          wheelMultiplier: m,
          autoResize: g,
          __experimental__naiveDimensions: v,
        }),
        (this.animate = new Ao()),
        (this.emitter = new Po()),
        (this.dimensions = new Ro({ wrapper: t, content: e, autoResize: g })),
        this.toggleClassName("lenis", !0),
        (this.velocity = 0),
        (this.isLocked = !1),
        (this.isStopped = !1),
        (this.isSmooth = s || r),
        (this.isScrolling = !1),
        (this.targetScroll = this.animatedScroll = this.actualScroll),
        this.options.wrapper.addEventListener(
          "scroll",
          this.onNativeScroll,
          !1
        ),
        (this.virtualScroll = new Io(i, {
          touchMultiplier: f,
          wheelMultiplier: m,
        })),
        this.virtualScroll.on("scroll", this.onVirtualScroll);
    }
    destroy() {
      this.emitter.destroy(),
        this.options.wrapper.removeEventListener(
          "scroll",
          this.onNativeScroll,
          !1
        ),
        this.virtualScroll.destroy(),
        this.dimensions.destroy(),
        this.toggleClassName("lenis", !1),
        this.toggleClassName("lenis-smooth", !1),
        this.toggleClassName("lenis-scrolling", !1),
        this.toggleClassName("lenis-stopped", !1),
        this.toggleClassName("lenis-locked", !1);
    }
    on(t, e) {
      return this.emitter.on(t, e);
    }
    off(t, e) {
      return this.emitter.off(t, e);
    }
    setScroll(t) {
      this.isHorizontal
        ? (this.rootElement.scrollLeft = t)
        : (this.rootElement.scrollTop = t);
    }
    resize() {
      this.dimensions.resize();
    }
    emit() {
      this.emitter.emit("scroll", this);
    }
    reset() {
      (this.isLocked = !1),
        (this.isScrolling = !1),
        (this.animatedScroll = this.targetScroll = this.actualScroll),
        (this.velocity = 0),
        this.animate.stop();
    }
    start() {
      this.isStopped && ((this.isStopped = !1), this.reset());
    }
    stop() {
      this.isStopped ||
        ((this.isStopped = !0), this.animate.stop(), this.reset());
    }
    raf(t) {
      const e = t - (this.time || t);
      (this.time = t), this.animate.advance(0.001 * e);
    }
    scrollTo(
      t,
      {
        offset: e = 0,
        immediate: n = !1,
        lock: i = !1,
        duration: r = this.options.duration,
        easing: s = this.options.easing,
        lerp: a = !r && this.options.lerp,
        onComplete: o,
        force: l = !1,
        programmatic: c = !0,
      } = {}
    ) {
      if ((!this.isStopped && !this.isLocked) || l) {
        if (["top", "left", "start"].includes(t)) t = 0;
        else if (["bottom", "right", "end"].includes(t)) t = this.limit;
        else {
          let n;
          if (
            ("string" == typeof t
              ? (n = document.querySelector(t))
              : (null == t ? void 0 : t.nodeType) && (n = t),
            n)
          ) {
            if (this.options.wrapper !== window) {
              const t = this.options.wrapper.getBoundingClientRect();
              e -= this.isHorizontal ? t.left : t.top;
            }
            const i = n.getBoundingClientRect();
            t = (this.isHorizontal ? i.left : i.top) + this.animatedScroll;
          }
        }
        if ("number" == typeof t) {
          if (
            ((t += e),
            (t = Math.round(t)),
            this.options.infinite
              ? c && (this.targetScroll = this.animatedScroll = this.scroll)
              : (t = Co(0, t, this.limit)),
            n)
          )
            return (
              (this.animatedScroll = this.targetScroll = t),
              this.setScroll(this.scroll),
              this.reset(),
              void (null == o || o(this))
            );
          if (!c) {
            if (t === this.targetScroll) return;
            this.targetScroll = t;
          }
          this.animate.fromTo(this.animatedScroll, t, {
            duration: r,
            easing: s,
            lerp: a,
            onStart: () => {
              i && (this.isLocked = !0), (this.isScrolling = !0);
            },
            onUpdate: (t, e) => {
              (this.isScrolling = !0),
                (this.velocity = t - this.animatedScroll),
                (this.direction = Math.sign(this.velocity)),
                (this.animatedScroll = t),
                this.setScroll(this.scroll),
                c && (this.targetScroll = t),
                e || this.emit(),
                e &&
                  (this.reset(),
                  this.emit(),
                  null == o || o(this),
                  (this.__preventNextScrollEvent = !0),
                  requestAnimationFrame(() => {
                    delete this.__preventNextScrollEvent;
                  }));
            },
          });
        }
      }
    }
    get rootElement() {
      return this.options.wrapper === window
        ? document.documentElement
        : this.options.wrapper;
    }
    get limit() {
      return this.options.__experimental__naiveDimensions
        ? this.isHorizontal
          ? this.rootElement.scrollWidth - this.rootElement.clientWidth
          : this.rootElement.scrollHeight - this.rootElement.clientHeight
        : this.dimensions.limit[this.isHorizontal ? "x" : "y"];
    }
    get isHorizontal() {
      return "horizontal" === this.options.orientation;
    }
    get actualScroll() {
      return this.isHorizontal
        ? this.rootElement.scrollLeft
        : this.rootElement.scrollTop;
    }
    get scroll() {
      return this.options.infinite
        ? ((this.animatedScroll % (t = this.limit)) + t) % t
        : this.animatedScroll;
      var t;
    }
    get progress() {
      return 0 === this.limit ? 1 : this.scroll / this.limit;
    }
    get isSmooth() {
      return this.__isSmooth;
    }
    set isSmooth(t) {
      this.__isSmooth !== t &&
        ((this.__isSmooth = t), this.toggleClassName("lenis-smooth", t));
    }
    get isScrolling() {
      return this.__isScrolling;
    }
    set isScrolling(t) {
      this.__isScrolling !== t &&
        ((this.__isScrolling = t), this.toggleClassName("lenis-scrolling", t));
    }
    get isStopped() {
      return this.__isStopped;
    }
    set isStopped(t) {
      this.__isStopped !== t &&
        ((this.__isStopped = t), this.toggleClassName("lenis-stopped", t));
    }
    get isLocked() {
      return this.__isLocked;
    }
    set isLocked(t) {
      this.__isLocked !== t &&
        ((this.__isLocked = t), this.toggleClassName("lenis-locked", t));
    }
    get className() {
      let t = "lenis";
      return (
        this.isStopped && (t += " lenis-stopped"),
        this.isLocked && (t += " lenis-locked"),
        this.isScrolling && (t += " lenis-scrolling"),
        this.isSmooth && (t += " lenis-smooth"),
        t
      );
    }
    toggleClassName(t, e) {
      this.rootElement.classList.toggle(t, e),
        this.emitter.emit("className change", this);
    }
  }
  function No() {
    return (
      (No = Object.assign
        ? Object.assign.bind()
        : function (t) {
            for (var e = 1; e < arguments.length; e++) {
              var n = arguments[e];
              for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
            }
            return t;
          }),
      No.apply(this, arguments)
    );
  }
  (history.scrollRestoration = "manual"),
    Yi.registerPlugin(to, wo),
    window.addEventListener("pagehide", () => window.scrollTo(0, 0));
  var Fo = (function () {
    function t(e) {
      void 0 === e && (e = {}),
        (this.options = Object.assign(
          {},
          {
            el: null,
            container:".cardanimation-craftwaves" ,
            className: "mf-cursor",
            innerClassName: "mf-cursor-inner",
            textClassName: "mf-cursor-text",
            mediaClassName: "mf-cursor-media",
            mediaBoxClassName: "mf-cursor-media-box",
            iconSvgClassName: "mf-svgsprite",
            iconSvgNamePrefix: "-",
            iconSvgSrc: "",
            dataAttr: "cursor",
            hiddenState: "-hidden",
            textState: "-text",
            iconState: "-icon",
            activeState: "-active",
            mediaState: "-media",
            stateDetection: { "-pointer": "a,button" },
            visible: !0,
            visibleOnState: !1,
            speed: 0.55,
            ease: "expo.out",
            overwrite: !0,
            skewing: 0,
            skewingText: 2,
            skewingIcon: 2,
            skewingMedia: 2,
            skewingDelta: 0.001,
            skewingDeltaMax: 0.15,
            stickDelta: 0.15,
            showTimeout: 0,
            hideOnLeave: !0,
            hideTimeout: 300,
            hideMediaTimeout: 300,
            initialPos: [-window.innerWidth, -window.innerHeight],
          },
          e
        )),
        this.options.visible &&
          null == e.stateDetection &&
          (this.options.stateDetection["-hidden"] = "iframe"),
        (this.gsap = t.gsap || window.gsap),
        (this.el =
          "string" == typeof this.options.el
            ? document.querySelector(this.options.el)
            : this.options.el),
        (this.container =
          "string" == typeof this.options.container
            ? document.querySelector(this.options.container)
            : this.options.container),
        (this.skewing = this.options.skewing),
        (this.pos = {
          x: this.options.initialPos[0],
          y: this.options.initialPos[1],
        }),
        (this.vel = { x: 0, y: 0 }),
        (this.event = {}),
        (this.events = []),
        this.init();
    }
    t.registerGSAP = function (e) {
      t.gsap = e;
    };
    var e = t.prototype;
    return (
      (e.init = function () {
        this.el || this.create(),
          this.createSetter(),
          this.bind(),
          this.render(!0),
          (this.ticker = this.render.bind(this, !1)),
          this.gsap.ticker.add(this.ticker);
      }),
      (e.create = function () {
        (this.el = document.createElement("div")),
          (this.el.className = this.options.className),
          this.el.classList.add(this.options.hiddenState),
          (this.inner = document.createElement("div")),
          (this.inner.className = this.options.innerClassName),
          (this.text = document.createElement("div")),
          (this.text.className = this.options.textClassName),
          (this.media = document.createElement("div")),
          (this.media.className = this.options.mediaClassName),
          (this.mediaBox = document.createElement("div")),
          (this.mediaBox.className = this.options.mediaBoxClassName),
          this.media.appendChild(this.mediaBox),
          this.inner.appendChild(this.media),
          this.inner.appendChild(this.text),
          this.el.appendChild(this.inner),
          this.container.appendChild(this.el);
      }),
      (e.createSetter = function () {
        this.setter = {
          x: this.gsap.quickSetter(this.el, "x", "px"),
          y: this.gsap.quickSetter(this.el, "y", "px"),
          rotation: this.gsap.quickSetter(this.el, "rotation", "deg"),
          scaleX: this.gsap.quickSetter(this.el, "scaleX"),
          scaleY: this.gsap.quickSetter(this.el, "scaleY"),
          wc: this.gsap.quickSetter(this.el, "willChange"),
          inner: {
            rotation: this.gsap.quickSetter(this.inner, "rotation", "deg"),
          },
        };
      }),
      (e.bind = function () {
        var t = this;
        (this.event.mouseleave = function () {
          return t.hide();
        }),
          (this.event.mouseenter = function () {
            return t.show();
          }),
          (this.event.mousedown = function () {
            return t.addState(t.options.activeState);
          }),
          (this.event.mouseup = function () {
            return t.removeState(t.options.activeState);
          }),
          (this.event.mousemoveOnce = function () {
            return t.show();
          }),
          (this.event.mousemove = function (e) {
            t.gsap.to(t.pos, {
              x: t.stick
                ? t.stick.x - (t.stick.x - e.clientX) * t.options.stickDelta
                : e.clientX,
              y: t.stick
                ? t.stick.y - (t.stick.y - e.clientY) * t.options.stickDelta
                : e.clientY,
              overwrite: t.options.overwrite,
              ease: t.options.ease,
              duration: t.visible ? t.options.speed : 0,
              onUpdate: function () {
                return (t.vel = {
                  x: e.clientX - t.pos.x,
                  y: e.clientY - t.pos.y,
                });
              },
            });
          }),
          (this.event.mouseover = function (e) {
            for (
              var n = e.target;
              n &&
              n !== t.container &&
              (!e.relatedTarget || !n.contains(e.relatedTarget));
              n = n.parentNode
            ) {
              for (var i in t.options.stateDetection)
                n.matches(t.options.stateDetection[i]) && t.addState(i);
              if (t.options.dataAttr) {
                var r = t.getFromDataset(n);
                r.state && t.addState(r.state),
                  r.text && t.setText(r.text),
                  r.icon && t.setIcon(r.icon),
                  r.img && t.setImg(r.img),
                  r.video && t.setVideo(r.video),
                  void 0 !== r.show && t.show(),
                  void 0 !== r.stick && t.setStick(r.stick || n);
              }
            }
          }),
          (this.event.mouseout = function (e) {
            for (
              var n = e.target;
              n &&
              n !== t.container &&
              (!e.relatedTarget || !n.contains(e.relatedTarget));
              n = n.parentNode
            ) {
              for (var i in t.options.stateDetection)
                n.matches(t.options.stateDetection[i]) && t.removeState(i);
              if (t.options.dataAttr) {
                var r = t.getFromDataset(n);
                r.state && t.removeState(r.state),
                  r.text && t.removeText(),
                  r.icon && t.removeIcon(),
                  r.img && t.removeImg(),
                  r.video && t.removeVideo(),
                  void 0 !== r.show && t.hide(),
                  void 0 !== r.stick && t.removeStick();
              }
            }
          }),
          this.options.hideOnLeave &&
            this.container.addEventListener(
              "mouseleave",
              this.event.mouseleave,
              { passive: !0 }
            ),
          this.options.visible &&
            this.container.addEventListener(
              "mouseenter",
              this.event.mouseenter,
              { passive: !0 }
            ),
          this.options.activeState &&
            (this.container.addEventListener(
              "mousedown",
              this.event.mousedown,
              { passive: !0 }
            ),
            this.container.addEventListener("mouseup", this.event.mouseup, {
              passive: !0,
            })),
          this.container.addEventListener("mousemove", this.event.mousemove, {
            passive: !0,
          }),
          this.options.visible &&
            this.container.addEventListener(
              "mousemove",
              this.event.mousemoveOnce,
              { passive: !0, once: !0 }
            ),
          (this.options.stateDetection || this.options.dataAttr) &&
            (this.container.addEventListener(
              "mouseover",
              this.event.mouseover,
              { passive: !0 }
            ),
            this.container.addEventListener("mouseout", this.event.mouseout, {
              passive: !0,
            }));
      }),
      (e.render = function (t) {
        if (!0 === t || (0 !== this.vel.y && 0 !== this.vel.x)) {
          if (
            (this.trigger("render"),
            this.setter.wc("transform"),
            this.setter.x(this.pos.x),
            this.setter.y(this.pos.y),
            this.skewing)
          ) {
            var e = Math.sqrt(
                Math.pow(this.vel.x, 2) + Math.pow(this.vel.y, 2)
              ),
              n =
                Math.min(
                  e * this.options.skewingDelta,
                  this.options.skewingDeltaMax
                ) * this.skewing,
              i = (180 * Math.atan2(this.vel.y, this.vel.x)) / Math.PI;
            this.setter.rotation(i),
              this.setter.scaleX(1 + n),
              this.setter.scaleY(1 - n),
              this.setter.inner.rotation(-i);
          }
        } else this.setter.wc("auto");
      }),
      (e.show = function () {
        var t = this;
        this.trigger("show"),
          clearInterval(this.visibleInt),
          (this.visibleInt = setTimeout(function () {
            t.el.classList.remove(t.options.hiddenState),
              (t.visible = !0),
              t.render(!0);
          }, this.options.showTimeout));
      }),
      (e.hide = function () {
        var t = this;
        this.trigger("hide"),
          clearInterval(this.visibleInt),
          this.el.classList.add(this.options.hiddenState),
          (this.visibleInt = setTimeout(function () {
            return (t.visible = !1);
          }, this.options.hideTimeout));
      }),
      (e.toggle = function (t) {
        !0 === t || (!1 !== t && !this.visible) ? this.show() : this.hide();
      }),
      (e.addState = function (t) {
        var e;
        if ((this.trigger("addState", t), t === this.options.hiddenState))
          return this.hide();
        (e = this.el.classList).add.apply(e, t.split(" ")),
          this.options.visibleOnState && this.show();
      }),
      (e.removeState = function (t) {
        var e;
        if ((this.trigger("removeState", t), t === this.options.hiddenState))
          return this.show();
        (e = this.el.classList).remove.apply(e, t.split(" ")),
          this.options.visibleOnState &&
            this.el.className === this.options.className &&
            this.hide();
      }),
      (e.toggleState = function (t, e) {
        !0 === e || (!1 !== e && !this.el.classList.contains(t))
          ? this.addState(t)
          : this.removeState(t);
      }),
      (e.setSkewing = function (t) {
        this.gsap.to(this, { skewing: t });
      }),
      (e.removeSkewing = function () {
        this.gsap.to(this, { skewing: this.options.skewing });
      }),
      (e.setStick = function (t) {
        var e = (
          "string" == typeof t ? document.querySelector(t) : t
        ).getBoundingClientRect();
        this.stick = { y: e.top + e.height / 2, x: e.left + e.width / 2 };
      }),
      (e.removeStick = function () {
        this.stick = !1;
      }),
      (e.setText = function (t) {
        (this.text.innerHTML = t),
          this.addState(this.options.textState),
          this.setSkewing(this.options.skewingText);
      }),
      (e.removeText = function () {
        this.removeState(this.options.textState), this.removeSkewing();
      }),
      (e.setIcon = function (t, e) {
        void 0 === e && (e = ""),
          (this.text.innerHTML =
            "<svg class='" +
            this.options.iconSvgClassName +
            " " +
            this.options.iconSvgNamePrefix +
            t +
            "' style='" +
            e +
            "'><use xlink:href='" +
            this.options.iconSvgSrc +
            "#" +
            t +
            "'></use></svg>"),
          this.addState(this.options.iconState),
          this.setSkewing(this.options.skewingIcon);
      }),
      (e.removeIcon = function () {
        this.removeState(this.options.iconState), this.removeSkewing();
      }),
      (e.setMedia = function (t) {
        var e = this;
        clearTimeout(this.mediaInt),
          t && ((this.mediaBox.innerHTML = ""), this.mediaBox.appendChild(t)),
          (this.mediaInt = setTimeout(function () {
            return e.addState(e.options.mediaState);
          }, 20)),
          this.setSkewing(this.options.skewingMedia);
      }),
      (e.removeMedia = function () {
        var t = this;
        clearTimeout(this.mediaInt),
          this.removeState(this.options.mediaState),
          (this.mediaInt = setTimeout(function () {
            return (t.mediaBox.innerHTML = "");
          }, this.options.hideMediaTimeout)),
          this.removeSkewing();
      }),
      (e.setImg = function (t) {
        this.mediaImg || (this.mediaImg = new Image()),
          this.mediaImg.src !== t && (this.mediaImg.src = t),
          this.setMedia(this.mediaImg);
      }),
      (e.removeImg = function () {
        this.removeMedia();
      }),
      (e.setVideo = function (t) {
        this.mediaVideo ||
          ((this.mediaVideo = document.createElement("video")),
          (this.mediaVideo.muted = !0),
          (this.mediaVideo.loop = !0),
          (this.mediaVideo.autoplay = !0)),
          this.mediaVideo.src !== t &&
            ((this.mediaVideo.src = t), this.mediaVideo.load()),
          this.mediaVideo.play(),
          this.setMedia(this.mediaVideo);
      }),
      (e.removeVideo = function () {
        this.mediaVideo &&
          this.mediaVideo.readyState > 2 &&
          this.mediaVideo.pause(),
          this.removeMedia();
      }),
      (e.on = function (t, e) {
        this.events[t] instanceof Array || this.off(t), this.events[t].push(e);
      }),
      (e.off = function (t, e) {
        this.events[t] = e
          ? this.events[t].filter(function (t) {
              return t !== e;
            })
          : [];
      }),
      (e.trigger = function (t) {
        var e = arguments,
          n = this;
        this.events[t] &&
          this.events[t].forEach(function (t) {
            return t.call.apply(t, [n, n].concat([].slice.call(e, 1)));
          });
      }),
      (e.getFromDataset = function (t) {
        var e = t.dataset;
        return {
          state: e[this.options.dataAttr],
          show: e[this.options.dataAttr + "Show"],
          text: e[this.options.dataAttr + "Text"],
          icon: e[this.options.dataAttr + "Icon"],
          img: e[this.options.dataAttr + "Img"],
          video: e[this.options.dataAttr + "Video"],
          stick: e[this.options.dataAttr + "Stick"],
        };
      }),
      (e.destroy = function () {
        this.trigger("destroy"),
          this.gsap.ticker.remove(this.ticker),
          this.container.removeEventListener(
            "mouseleave",
            this.event.mouseleave
          ),
          this.container.removeEventListener(
            "mouseenter",
            this.event.mouseenter
          ),
          this.container.removeEventListener("mousedown", this.event.mousedown),
          this.container.removeEventListener("mouseup", this.event.mouseup),
          this.container.removeEventListener("mousemove", this.event.mousemove),
          this.container.removeEventListener(
            "mousemove",
            this.event.mousemoveOnce
          ),
          this.container.removeEventListener("mouseover", this.event.mouseover),
          this.container.removeEventListener("mouseout", this.event.mouseout),
          this.el &&
            (this.container.removeChild(this.el),
            (this.el = null),
            (this.mediaImg = null),
            (this.mediaVideo = null));
      }),
      t
    );
  })();
  Fo.registerGSAP(Yi);
  const Oo = function (t) {
      var e = typeof t;
      return null != t && ("object" == e || "function" == e);
    },
    Bo =
      "object" == typeof global && global && global.Object === Object && global;
  var zo = "object" == typeof self && self && self.Object === Object && self;
  const ko = Bo || zo || Function("return this")(),
    Vo = function () {
      return ko.Date.now();
    };
  var Ho = /\s/;
  var Go = /^\s+/;
  const Wo = function (t) {
      return t
        ? t
            .slice(
              0,
              (function (t) {
                for (var e = t.length; e-- && Ho.test(t.charAt(e)); );
                return e;
              })(t) + 1
            )
            .replace(Go, "")
        : t;
    },
    Xo = ko.Symbol;
  var qo = Object.prototype,
    jo = qo.hasOwnProperty,
    Yo = qo.toString,
    Ko = Xo ? Xo.toStringTag : void 0;
  var Zo = Object.prototype.toString;
  var Jo = Xo ? Xo.toStringTag : void 0;
  const $o = function (t) {
    return null == t
      ? void 0 === t
        ? "[object Undefined]"
        : "[object Null]"
      : Jo && Jo in Object(t)
      ? (function (t) {
          var e = jo.call(t, Ko),
            n = t[Ko];
          try {
            t[Ko] = void 0;
            var i = !0;
          } catch (t) {}
          var r = Yo.call(t);
          return i && (e ? (t[Ko] = n) : delete t[Ko]), r;
        })(t)
      : (function (t) {
          return Zo.call(t);
        })(t);
  };
  var Qo = /^[-+]0x[0-9a-f]+$/i,
    tl = /^0b[01]+$/i,
    el = /^0o[0-7]+$/i,
    nl = parseInt;
  const il = function (t) {
    if ("number" == typeof t) return t;
    if (
      (function (t) {
        return (
          "symbol" == typeof t ||
          ((function (t) {
            return null != t && "object" == typeof t;
          })(t) &&
            "[object Symbol]" == $o(t))
        );
      })(t)
    )
      return NaN;
    if (Oo(t)) {
      var e = "function" == typeof t.valueOf ? t.valueOf() : t;
      t = Oo(e) ? e + "" : e;
    }
    if ("string" != typeof t) return 0 === t ? t : +t;
    t = Wo(t);
    var n = tl.test(t);
    return n || el.test(t) ? nl(t.slice(2), n ? 2 : 8) : Qo.test(t) ? NaN : +t;
  };
  var rl = Math.max,
    sl = Math.min;
  var al =
    /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
  function ol(t) {
    var e = t.nodeType,
      n = "";
    if (1 === e || 9 === e || 11 === e) {
      if ("string" == typeof t.textContent) return t.textContent;
      for (t = t.firstChild; t; t = t.nextSibling) n += ol(t);
    } else if (3 === e || 4 === e) return t.nodeValue;
    return n;
  }
  var ll,
    cl,
    ul,
    hl = /(?:\r|\n|\t\t)/g,
    dl = /(?:\s\s+)/g,
    pl = function (t) {
      return cl.getComputedStyle(t);
    },
    fl = Array.isArray,
    ml = [].slice,
    gl = function (t, e) {
      var n;
      return fl(t)
        ? t
        : "string" == (n = typeof t) && !e && t
        ? ml.call(ll.querySelectorAll(t), 0)
        : t && "object" === n && "length" in t
        ? ml.call(t, 0)
        : t
        ? [t]
        : [];
    },
    vl = function (t) {
      return "absolute" === t.position || !0 === t.absolute;
    },
    _l = function (t, e) {
      for (var n, i = e.length; --i > -1; )
        if (((n = e[i]), t.substr(0, n.length) === n)) return n.length;
    },
    xl = function (t, e) {
      void 0 === t && (t = "");
      var n = ~t.indexOf("++"),
        i = 1;
      return (
        n && (t = t.split("++").join("")),
        function () {
          return (
            "<" +
            e +
            " style='position:relative;display:inline-block;'" +
            (t ? " class='" + t + (n ? i++ : "") + "'>" : ">")
          );
        }
      );
    },
    yl = function t(e, n, i) {
      var r = e.nodeType;
      if (1 === r || 9 === r || 11 === r)
        for (e = e.firstChild; e; e = e.nextSibling) t(e, n, i);
      else (3 !== r && 4 !== r) || (e.nodeValue = e.nodeValue.split(n).join(i));
    },
    Sl = function (t, e) {
      for (var n = e.length; --n > -1; ) t.push(e[n]);
    },
    Ml = function (t, e, n) {
      for (var i; t && t !== e; ) {
        if ((i = t._next || t.nextSibling))
          return i.textContent.charAt(0) === n;
        t = t.parentNode || t._parent;
      }
    },
    El = function t(e) {
      var n,
        i,
        r = gl(e.childNodes),
        s = r.length;
      for (n = 0; n < s; n++)
        (i = r[n])._isSplit
          ? t(i)
          : n && i.previousSibling && 3 === i.previousSibling.nodeType
          ? ((i.previousSibling.nodeValue +=
              3 === i.nodeType ? i.nodeValue : i.firstChild.nodeValue),
            e.removeChild(i))
          : 3 !== i.nodeType &&
            (e.insertBefore(i.firstChild, i), e.removeChild(i));
    },
    Tl = function (t, e) {
      return parseFloat(e[t]) || 0;
    },
    bl = function (t, e, n, i, r, s, a) {
      var o,
        l,
        c,
        u,
        h,
        d,
        p,
        f,
        m,
        g,
        v,
        _,
        x = pl(t),
        y = Tl("paddingLeft", x),
        S = -999,
        M = Tl("borderBottomWidth", x) + Tl("borderTopWidth", x),
        E = Tl("borderLeftWidth", x) + Tl("borderRightWidth", x),
        T = Tl("paddingTop", x) + Tl("paddingBottom", x),
        b = Tl("paddingLeft", x) + Tl("paddingRight", x),
        D = Tl("fontSize", x) * (e.lineThreshold || 0.2),
        w = x.textAlign,
        C = [],
        A = [],
        R = [],
        P = e.wordDelimiter || " ",
        L = e.tag ? e.tag : e.span ? "span" : "div",
        I = e.type || e.split || "chars,words,lines",
        U = r && ~I.indexOf("lines") ? [] : null,
        N = ~I.indexOf("words"),
        F = ~I.indexOf("chars"),
        O = vl(e),
        B = e.linesClass,
        z = ~(B || "").indexOf("++"),
        k = [],
        V = "flex" === x.display,
        H = t.style.display;
      for (
        z && (B = B.split("++").join("")),
          V && (t.style.display = "block"),
          c = (l = t.getElementsByTagName("*")).length,
          h = [],
          o = 0;
        o < c;
        o++
      )
        h[o] = l[o];
      if (U || O)
        for (o = 0; o < c; o++)
          ((d = (u = h[o]).parentNode === t) || O || (F && !N)) &&
            ((_ = u.offsetTop),
            U &&
              d &&
              Math.abs(_ - S) > D &&
              ("BR" !== u.nodeName || 0 === o) &&
              ((p = []), U.push(p), (S = _)),
            O &&
              ((u._x = u.offsetLeft),
              (u._y = _),
              (u._w = u.offsetWidth),
              (u._h = u.offsetHeight)),
            U &&
              (((u._isSplit && d) ||
                (!F && d) ||
                (N && d) ||
                (!N &&
                  u.parentNode.parentNode === t &&
                  !u.parentNode._isSplit)) &&
                (p.push(u), (u._x -= y), Ml(u, t, P) && (u._wordEnd = !0)),
              "BR" === u.nodeName &&
                ((u.nextSibling && "BR" === u.nextSibling.nodeName) ||
                  0 === o) &&
                U.push([])));
      for (o = 0; o < c; o++)
        if (((d = (u = h[o]).parentNode === t), "BR" !== u.nodeName))
          if (
            (O &&
              ((m = u.style),
              N || d || ((u._x += u.parentNode._x), (u._y += u.parentNode._y)),
              (m.left = u._x + "px"),
              (m.top = u._y + "px"),
              (m.position = "absolute"),
              (m.display = "block"),
              (m.width = u._w + 1 + "px"),
              (m.height = u._h + "px")),
            !N && F)
          )
            if (u._isSplit)
              for (
                u._next = l = u.nextSibling, u.parentNode.appendChild(u);
                l && 3 === l.nodeType && " " === l.textContent;

              )
                (u._next = l.nextSibling),
                  u.parentNode.appendChild(l),
                  (l = l.nextSibling);
            else
              u.parentNode._isSplit
                ? ((u._parent = u.parentNode),
                  !u.previousSibling &&
                    u.firstChild &&
                    (u.firstChild._isFirst = !0),
                  u.nextSibling &&
                    " " === u.nextSibling.textContent &&
                    !u.nextSibling.nextSibling &&
                    k.push(u.nextSibling),
                  (u._next =
                    u.nextSibling && u.nextSibling._isFirst
                      ? null
                      : u.nextSibling),
                  u.parentNode.removeChild(u),
                  h.splice(o--, 1),
                  c--)
                : d ||
                  ((_ = !u.nextSibling && Ml(u.parentNode, t, P)),
                  u.parentNode._parent && u.parentNode._parent.appendChild(u),
                  _ && u.parentNode.appendChild(ll.createTextNode(" ")),
                  "span" === L && (u.style.display = "inline"),
                  C.push(u));
          else
            u.parentNode._isSplit && !u._isSplit && "" !== u.innerHTML
              ? A.push(u)
              : F &&
                !u._isSplit &&
                ("span" === L && (u.style.display = "inline"), C.push(u));
        else
          U || O
            ? (u.parentNode && u.parentNode.removeChild(u),
              h.splice(o--, 1),
              c--)
            : N || t.appendChild(u);
      for (o = k.length; --o > -1; ) k[o].parentNode.removeChild(k[o]);
      if (U) {
        for (
          O &&
            ((g = ll.createElement(L)),
            t.appendChild(g),
            (v = g.offsetWidth + "px"),
            (_ = g.offsetParent === t ? 0 : t.offsetLeft),
            t.removeChild(g)),
            m = t.style.cssText,
            t.style.cssText = "display:none;";
          t.firstChild;

        )
          t.removeChild(t.firstChild);
        for (f = " " === P && (!O || (!N && !F)), o = 0; o < U.length; o++) {
          for (
            p = U[o],
              (g = ll.createElement(L)).style.cssText =
                "display:block;text-align:" +
                w +
                ";position:" +
                (O ? "absolute;" : "relative;"),
              B && (g.className = B + (z ? o + 1 : "")),
              R.push(g),
              c = p.length,
              l = 0;
            l < c;
            l++
          )
            "BR" !== p[l].nodeName &&
              ((u = p[l]),
              g.appendChild(u),
              f && u._wordEnd && g.appendChild(ll.createTextNode(" ")),
              O &&
                (0 === l &&
                  ((g.style.top = u._y + "px"), (g.style.left = y + _ + "px")),
                (u.style.top = "0px"),
                _ && (u.style.left = u._x - _ + "px")));
          0 === c
            ? (g.innerHTML = "&nbsp;")
            : N || F || (El(g), yl(g, String.fromCharCode(160), " ")),
            O && ((g.style.width = v), (g.style.height = u._h + "px")),
            t.appendChild(g);
        }
        t.style.cssText = m;
      }
      O &&
        (a > t.clientHeight &&
          ((t.style.height = a - T + "px"),
          t.clientHeight < a && (t.style.height = a + M + "px")),
        s > t.clientWidth &&
          ((t.style.width = s - b + "px"),
          t.clientWidth < s && (t.style.width = s + E + "px"))),
        V && (H ? (t.style.display = H) : t.style.removeProperty("display")),
        Sl(n, C),
        N && Sl(i, A),
        Sl(r, R);
    },
    Dl = function (t, e, n, i) {
      var r,
        s,
        a,
        o,
        l,
        c,
        u,
        h,
        d = e.tag ? e.tag : e.span ? "span" : "div",
        p = ~(e.type || e.split || "chars,words,lines").indexOf("chars"),
        f = vl(e),
        m = e.wordDelimiter || " ",
        g = " " !== m ? "" : f ? "&#173; " : " ",
        v = "</" + d + ">",
        _ = 1,
        x = e.specialChars
          ? "function" == typeof e.specialChars
            ? e.specialChars
            : _l
          : null,
        y = ll.createElement("div"),
        S = t.parentNode;
      for (
        S.insertBefore(y, t),
          y.textContent = t.nodeValue,
          S.removeChild(t),
          u = -1 !== (r = ol((t = y))).indexOf("<"),
          !1 !== e.reduceWhiteSpace && (r = r.replace(dl, " ").replace(hl, "")),
          u && (r = r.split("<").join("{{LT}}")),
          l = r.length,
          s = (" " === r.charAt(0) ? g : "") + n(),
          a = 0;
        a < l;
        a++
      )
        if (((c = r.charAt(a)), x && (h = x(r.substr(a), e.specialChars))))
          (c = r.substr(a, h || 1)),
            (s += p && " " !== c ? i() + c + "</" + d + ">" : c),
            (a += h - 1);
        else if (c === m && r.charAt(a - 1) !== m && a) {
          for (s += _ ? v : "", _ = 0; r.charAt(a + 1) === m; ) (s += g), a++;
          a === l - 1
            ? (s += g)
            : ")" !== r.charAt(a + 1) && ((s += g + n()), (_ = 1));
        } else
          "{" === c && "{{LT}}" === r.substr(a, 6)
            ? ((s += p ? i() + "{{LT}}</" + d + ">" : "{{LT}}"), (a += 5))
            : (c.charCodeAt(0) >= 55296 && c.charCodeAt(0) <= 56319) ||
              (r.charCodeAt(a + 1) >= 65024 && r.charCodeAt(a + 1) <= 65039)
            ? ((o = ((r.substr(a, 12).split(al) || [])[1] || "").length || 2),
              (s +=
                p && " " !== c
                  ? i() + r.substr(a, o) + "</" + d + ">"
                  : r.substr(a, o)),
              (a += o - 1))
            : (s += p && " " !== c ? i() + c + "</" + d + ">" : c);
      (t.outerHTML = s + (_ ? v : "")), u && yl(S, "{{LT}}", "<");
    },
    wl = function t(e, n, i, r) {
      var s,
        a,
        o = gl(e.childNodes),
        l = o.length,
        c = vl(n);
      if (3 !== e.nodeType || l > 1) {
        for (n.absolute = !1, s = 0; s < l; s++)
          ((a = o[s])._next = a._isFirst = a._parent = a._wordEnd = null),
            (3 !== a.nodeType || /\S+/.test(a.nodeValue)) &&
              (c &&
                3 !== a.nodeType &&
                "inline" === pl(a).display &&
                ((a.style.display = "inline-block"),
                (a.style.position = "relative")),
              (a._isSplit = !0),
              t(a, n, i, r));
        return (n.absolute = c), void (e._isSplit = !0);
      }
      Dl(e, n, i, r);
    },
    Cl = (function () {
      function t(t, e) {
        ul || ((ll = document), (cl = window), (ul = 1)),
          (this.elements = gl(t)),
          (this.chars = []),
          (this.words = []),
          (this.lines = []),
          (this._originals = []),
          (this.vars = e || {}),
          this.split(e);
      }
      var e = t.prototype;
      return (
        (e.split = function (t) {
          this.isSplit && this.revert(),
            (this.vars = t = t || this.vars),
            (this._originals.length =
              this.chars.length =
              this.words.length =
              this.lines.length =
                0);
          for (
            var e,
              n,
              i,
              r = this.elements.length,
              s = t.tag ? t.tag : t.span ? "span" : "div",
              a = xl(t.wordsClass, s),
              o = xl(t.charsClass, s);
            --r > -1;

          )
            (i = this.elements[r]),
              (this._originals[r] = i.innerHTML),
              (e = i.clientHeight),
              (n = i.clientWidth),
              wl(i, t, a, o),
              bl(i, t, this.chars, this.words, this.lines, n, e);
          return (
            this.chars.reverse(),
            this.words.reverse(),
            this.lines.reverse(),
            (this.isSplit = !0),
            this
          );
        }),
        (e.revert = function () {
          var t = this._originals;
          if (!t) throw "revert() call wasn't scoped properly.";
          return (
            this.elements.forEach(function (e, n) {
              return (e.innerHTML = t[n]);
            }),
            (this.chars = []),
            (this.words = []),
            (this.lines = []),
            (this.isSplit = !1),
            this
          );
        }),
        (t.create = function (e, n) {
          return new t(e, n);
        }),
        t
      );
    })();
  function Al() {
    return (
      (Al = Object.assign
        ? Object.assign.bind()
        : function (t) {
            for (var e = 1; e < arguments.length; e++) {
              var n = arguments[e];
              for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
            }
            return t;
          }),
      Al.apply(this, arguments)
    );
  }
  Cl.version = "3.11.1";
  const Rl = (t, e) => {
      const n = Al(
        {
          box: t,
          xDelta: 0.1,
          yDelta: 0.1,
          moveSpeed: 0.3,
          leaveSpeed: 0.3,
          moveEase: "power1.out",
          leaveEase: "power1.out",
          overwrite: !0,
        },
        e
      );
      let i;
      const r = (e, i, r) => {
        Yi.to(
          t,
          Al(
            {
              x: e,
              y: i,
              overwrite: n.overwrite,
              onStart: () => Yi.set(t, { willChange: "transform" }),
              onComplete: () => Yi.set(t, { willChange: "auto" }),
            },
            r
          )
        );
      };
      n.box.addEventListener("mouseenter", () => {
        i = t.getBoundingClientRect();
      }),
        n.box.addEventListener("mousemove", (t) => {
          const e = (t.clientY - i.top - i.height / 2) * n.yDelta,
            s = (t.clientX - i.left - i.width / 2) * n.xDelta;
          r(s, e, { duration: n.moveSpeed, ease: n.moveEase });
        }),
        n.box.addEventListener("mouseleave", () => {
          r(0, 0, { duration: n.leaveSpeed, ease: n.leaveEase });
        });
    },
    Pl = function (t, e) {
      void 0 === e && (e = {});
      const n = Al(
          {
            type: "words",
            duration: 1.7,
            stagger: { amount: 0.6 },
            ease: "expo.out",
          },
          e
        ),
        i = new Yi.timeline(),
        r = t.querySelectorAll(".cw-coin-craftwaves, video"),
        s = new Cl(t, { type: n.type }),
        a = new Cl(s[n.type], { type: n.type });
      return (
        Yi.set(s[n.type], {
          overflow: "hidden",
          verticalAlign: "top",
          padding: "0.10em 0",
          margin: "-0.10em 0",
        }),
        Yi.set(a[n.type], { y: "110%" }),
        i.set(a[n.type], { willChange: "transform" }, 0),
        i.fromTo(
          a[n.type],
          { y: "110%" },
          { y: "0%", duration: n.duration, stagger: n.stagger, ease: n.ease },
          0
        ),
        r.length &&
          (Yi.set(r, { scale: 0 }),
          i.fromTo(
            r,
            { scale: 0 },
            {
              scale: 1,
              duration: n.duration,
              stagger: n.stagger,
              ease: n.ease,
            },
            0.2
          )),
        i.set(a[n.type], { willChange: "auto" }),
        i
      );
    },
    Ll = function (t, e) {
      return (
        void 0 === e && (e = {}),
        to.create({ trigger: t, animation: Pl(t, e), once: !0 })
      );
    },
    Il = function (t, e) {
      void 0 === e && (e = {});
      const n = Al(
        { from: 0, to: 1, duration: 2, stagger: 0.1, ease: "expo.out" },
        e
      );
      return (
        Yi.set(t, { scale: n.from }),
        Yi.fromTo(
          t,
          { scale: n.from },
          {
            scale: n.to,
            duration: n.duration,
            stagger: n.stagger,
            ease: n.ease,
          }
        )
      );
    },
    Ul = function (t, e) {
      return (
        void 0 === e && (e = {}),
        to.create({ trigger: t, animation: Il(t, e), once: !0 })
      );
    },
    Nl = function (t, e, n) {
      void 0 === n && (n = {});
      const i = Al(
          {
            from: 0.5,
            innerFrom: 2,
            to: 1,
            innerTo: 1,
            duration: 3,
            innerDuration: 3,
            opacityDuration: 0.5,
            ease: "expo.out",
          },
          n
        ),
        r = new Yi.timeline();
      return (
        Yi.set(t, { opacity: 0, scale: i.from }),
        Yi.set(e, { scale: i.innerFrom }),
        r.fromTo(
          t,
          { opacity: 0 },
          { opacity: 1, duration: i.opacityDuration },
          0
        ),
        r.fromTo(
          t,
          { scale: i.from },
          { scale: i.to, duration: i.duration, ease: i.ease },
          0
        ),
        r.fromTo(
          e,
          { scale: i.innerFrom },
          { scale: i.innerTo, duration: i.innerDuration, ease: i.ease },
          0
        ),
        r
      );
    },
    Fl = function (t, e, n) {
      return (
        void 0 === n && (n = {}),
        to.create({ trigger: t, animation: Nl(t, e, n), once: !0 })
      );
    },
    Ol = function (t, e) {
      void 0 === e && (e = {});
      const n = Al(
          {
            from: 40,
            to: 0,
            duration: 2,
            opacityDuration: 0.15,
            stagger: 0.1,
            ease: "expo.out",
          },
          e
        ),
        i = new Yi.timeline();
      return (
        Yi.set(t, { opacity: 0 }),
        i.set(t, { willChange: "transform" }),
        i.fromTo(
          t,
          { opacity: 0 },
          { opacity: 1, duration: n.opacityDuration, stagger: n.stagger },
          0
        ),
        i.fromTo(
          t,
          { y: n.from, opacity: 0 },
          {
            y: n.to,
            opacity: 1,
            duration: n.duration,
            stagger: n.stagger,
            ease: n.ease,
          },
          0
        ),
        i.set(t, { willChange: "auto" }),
        i
      );
    },
    Bl = function (t, e) {
      void 0 === e && (e = {});
      const n = Al(
          { from: 0, to: 1, duration: 2, stagger: 0.1, ease: "expo.out" },
          e
        ),
        i = new Yi.timeline();
      return (
        Yi.set(t, { opacity: 0 }),
        i.fromTo(
          t,
          { opacity: n.from },
          { opacity: n.to, duration: n.duration, stagger: n.stagger },
          0
        ),
        i
      );
    },
    zl = function (t, e) {
      void 0 === e && (e = {}),
        Al({ from: 0, to: 1, duration: 2, stagger: 0.1, ease: "expo.out" }, e);
      const n = new Yi.timeline(),
        i = t.querySelector(".cw-btn_cta-border-craftwaves"),
        r = t.querySelector(".cw-btn_cta-title-craftwaves");
      return (
        Yi.set(t, { pointerEvents: "none" }),
        n.set([i, r], { willChange: "transform" }),
        n.fromTo(
          i,
          { scaleY: 0.5, scaleX: 0 },
          { scaleY: 1, scaleX: 1, duration: 1.5, ease: "expo.out" },
          0
        ),
        n.fromTo(
          r,
          { scaleY: 0.5, scaleX: 0.5 },
          { scaleY: 1, scaleX: 1, duration: 1.5, ease: "expo.out" },
          0
        ),
        n.from(r, { y: "110%", duration: 1.2, ease: "expo.out" }, 0.1),
        n.fromTo(i, { opacity: 0 }, { opacity: 1, duration: 0.4 }, 0.2),
        n.set(t, { pointerEvents: "auto" }, 0.6),
        n.set([i, r], { willChange: "auto" }),
        n
      );
    };
  function kl() {
    return (
      (kl =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var i in n)
              Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
          }
          return t;
        }),
      kl.apply(this, arguments)
    );
  }
  function Vl(t, e) {
    (t.prototype = Object.create(e.prototype)),
      (t.prototype.constructor = t),
      Hl(t, e);
  }
  function Hl(t, e) {
    return (
      (Hl =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        }),
      Hl(t, e)
    );
  }
  var Gl = (function () {
      function t() {
        this.events = {};
      }
      var e = t.prototype;
      return (
        (e.on = function (t, e) {
          this.events[t] instanceof Array || (this.events[t] = []),
            this.events[t].push(e);
        }),
        (e.off = function (t, e) {
          this.events[t] = e
            ? this.events[t].filter(function (t) {
                return t !== e;
              })
            : [];
        }),
        (e.trigger = function (t) {
          var e = arguments,
            n = this;
          this.events[t] &&
            this.events[t].forEach(function (t) {
              return t.call.apply(t, [n, n].concat([].slice.call(e, 1)));
            });
        }),
        t
      );
    })(),
    Wl = (function (t) {
      function e(n) {
        var i;
        return (
          ((i = t.call(this) || this).options = kl({}, e.defaultOptions, n)),
          (i.container =
            "string" == typeof i.options.container
              ? document.querySelector(i.options.container)
              : i.options.container),
          (i.wrapper =
            "string" == typeof i.options.wrapper
              ? i.container.querySelector(i.options.wrapper)
              : i.options.wrapper || i.options.container),
          (i.item = []),
          i.refresh(!1),
          i.options.autoUpdate ? i.bindResizeObserver() : i.update(),
          i
        );
      }
      Vl(e, t);
      var n = e.prototype;
      return (
        (n.bindResizeObserver = function () {
          var t = this;
          (this.resizeObserver = new ResizeObserver(function () {
            t.update();
          })),
            this.resizeObserver.observe(this.container);
        }),
        (n.addClones = function (t, e) {
          var n;
          void 0 === e && (e = 0);
          for (var i = [], r = 0; r < t; r++) {
            var s = this.item[(e + r) % this.item.length].cloneNode(!0);
            s.classList.add(this.options.cloneClassName), i.push(s);
          }
          (n = this.wrapper).append.apply(n, i);
        }),
        (n.removeClones = function (t) {
          void 0 === t && (t = 0),
            Array.from(
              this.wrapper.getElementsByClassName(this.options.cloneClassName)
            )
              .slice(-t)
              .forEach(function (t) {
                return t.remove();
              });
        }),
        (n.setClonesCount = function (t) {
          this.clonesCount !== t &&
            (this.clonesCount < t &&
              this.addClones(t - this.clonesCount, this.clonesCount),
            this.clonesCount > t && this.removeClones(this.clonesCount - t),
            (this.clonesCount = t));
        }),
        (n.getCalcData = function () {
          var t = {
            clonesCount: 0,
            clonesWidth: 0,
            containerWidth: this.container.offsetWidth,
            fullWidth: 0,
            itemWidth: [],
            itemsWidth: 0,
            lastIndex: 0,
          };
          this.item.map(function (e) {
            var n = window.getComputedStyle(e),
              i =
                e.offsetWidth +
                parseInt(n.marginLeft) +
                parseInt(n.marginRight);
            t.itemWidth.push(i), (t.itemsWidth += i);
          });
          for (
            var e = t.itemWidth.length,
              n = this.options.clonesOverflow
                ? t.containerWidth
                : t.containerWidth - t.itemsWidth;
            n > t.clonesWidth ||
            t.clonesCount < this.options.clonesMin ||
            (this.options.clonesFinish && t.clonesCount % e > 0);

          )
            (t.lastIndex = t.clonesCount % e),
              (t.clonesWidth += t.itemWidth[t.lastIndex]),
              t.clonesCount++;
          return (t.fullWidth = t.clonesWidth + t.itemsWidth), t;
        }),
        (n.update = function () {
          (this.calcData = this.getCalcData()),
            this.setClonesCount(this.calcData.clonesCount),
            this.trigger("update", this.calcData);
        }),
        (n.refresh = function (t) {
          void 0 === t && (t = !0),
            this.removeClones(),
            (this.item = Array.from(
              this.container.querySelectorAll(this.options.itemSelector)
            )),
            (this.calcData = {}),
            (this.clonesCount = 0),
            this.trigger("refresh"),
            t && this.update();
        }),
        (n.destroy = function (t) {
          void 0 === t && (t = !1),
            t && this.removeClones(),
            this.resizeObserver && this.resizeObserver.disconnect(),
            this.trigger("destroy");
        }),
        e
      );
    })(Gl);
  Wl.defaultOptions = {
    container: null,
    wrapper: null,
    itemSelector: null,
    cloneClassName: "-clone",
    autoUpdate: !0,
    clonesOverflow: !1,
    clonesFinish: !1,
    clonesMin: 0,
  };
  var Xl = (function (t) {
    function e(n) {
      var i;
      return (
        ((i = t.call(this) || this).options = kl({}, e.defaultOptions, n)),
        (i.gsap = e.gsap || window.gsap),
        (i.paused = i.options.paused),
        i.createFiller(),
        i.createTimeline(),
        i.options.autoStop && i.bindIntersectionObserver(),
        i.options.plugins && i.initPlugins(),
        i
      );
    }
    Vl(e, t),
      (e.registerGSAP = function (t) {
        e.gsap = t;
      }),
      (e.use = function () {
        [].slice.call(arguments).forEach(function (t) {
          var n = t.pluginName;
          if ("string" != typeof n)
            throw new TypeError("Invalid plugin. Name is required.");
          e.plugins[n] = t;
        });
      });
    var n = e.prototype;
    return (
      (n.createFiller = function () {
        var t = this;
        (this.filler = new Wl(this.options)),
          this.filler.on("update", function (e, n) {
            t.invalidate(), t.trigger("update", n);
          }),
          this.filler.on("refresh", function () {
            t.trigger("refresh");
          });
      }),
      (n.createTimeline = function () {
        var t = this;
        return (
          (this.tl = new this.gsap.timeline({
            paused: this.options.paused,
            reversed: this.options.reversed,
            repeat: -1,
            yoyo: !this.options.loop,
            onReverseComplete: function () {
              this.progress(1);
            },
          })),
          this.gsap.set(this.filler.container, { overflow: "hidden" }),
          this.tl.fromTo(
            this.filler.wrapper,
            {
              x: function () {
                return t.options.clonesOverflow
                  ? -t.filler.calcData.itemsWidth
                  : -(
                      t.filler.calcData.fullWidth -
                      t.filler.calcData.containerWidth
                    );
              },
            },
            { x: 0, duration: this.options.speed, ease: this.options.ease }
          ),
          this.tl.seek(this.options.seek),
          this.tl
        );
      }),
      (n.bindIntersectionObserver = function () {
        var t = this;
        (this.intersectionObserver = new IntersectionObserver(function (e) {
          e[0].isIntersecting ? t.resume() : t.pause();
        })),
          this.intersectionObserver.observe(this.filler.container);
      }),
      (n.initPlugins = function () {
        this.plugin = {};
        for (
          var t = 0, n = Object.entries(this.options.plugins);
          t < n.length;
          t++
        ) {
          var i = n[t],
            r = i[0],
            s = i[1],
            a = e.plugins[r];
          a
            ? (this.plugin[r] = new a(this, s))
            : console.error(
                "Plugin " +
                  r +
                  " not found. Make sure you register it with Reeller.use()"
              );
        }
      }),
      (n.destroyPlugins = function () {
        for (var t = 0, e = Object.values(this.plugin); t < e.length; t++) {
          var n = e[t];
          n.destroy && n.destroy();
        }
      }),
      (n.resume = function () {
        this.gsap.set(this.filler.container, { z: "0" }),
          this.gsap.set(this.filler.wrapper, { willChange: "transform" }),
          (this.paused = !1),
          this.tl.resume(),
          this.trigger("resume");
      }),
      (n.reverse = function (t) {
        void 0 === t && (t = !0),
          this.tl.reversed(t),
          this.resume(),
          this.trigger("reverse", t);
      }),
      (n.pause = function () {
        this.gsap.set(this.filler.container, { clearProps: "z" }),
          this.gsap.set(this.filler.wrapper, { willChange: "auto" }),
          (this.paused = !0),
          this.tl.pause(),
          this.trigger("pause");
      }),
      (n.invalidate = function () {
        this.tl.invalidate(), this.trigger("invalidate");
      }),
      (n.update = function () {
        this.filler.update();
      }),
      (n.refresh = function (t) {
        void 0 === t && (t = !0), this.filler.refresh(t);
      }),
      (n.destroy = function (t, e) {
        void 0 === t && (t = !1),
          void 0 === e && (e = !1),
          this.intersectionObserver && this.intersectionObserver.disconnect(),
          this.options.plugins && this.destroyPlugins(),
          this.tl.kill(),
          this.filler.destroy(t),
          e &&
            (this.gsap.set(this.filler.container, { clearProps: "overflow" }),
            this.gsap.set(this.filler.wrapper, { clearProps: "x,willChange" })),
          this.trigger("destroy");
      }),
      e
    );
  })(Gl);
  (Xl.defaultOptions = {
    container: null,
    wrapper: null,
    itemSelector: null,
    cloneClassName: "-clone",
    speed: 10,
    ease: "none",
    initialSeek: 10,
    loop: !0,
    paused: !0,
    reversed: !1,
    autoStop: !0,
    autoUpdate: !0,
    clonesOverflow: !0,
    clonesFinish: !1,
    clonesMin: 0,
    plugins: null,
  }),
    (Xl.plugins = {});
  var ql = (function () {
    function t(e, n) {
      (this.options = kl({}, t.defaultOptions, n)),
        (this.reeller = e),
        (this.gsap = this.reeller.gsap),
        (this.tl = this.reeller.tl),
        this.init();
    }
    var e = t.prototype;
    return (
      (e.getScrollPos = function () {
        return this.options.scrollProxy
          ? this.options.scrollProxy()
          : window.pageYOffset;
      }),
      (e.init = function () {
        var t = this,
          e = this.getScrollPos(),
          n = 1,
          i = !0;
        (this.tickerFn = function () {
          var r = t.getScrollPos(),
            s = r - e;
          if (
            (t.options.bothDirection || (s = Math.abs(s)),
            t.options.reversed && (s *= -1),
            t.reeller.paused)
          )
            return (
              (n = Math.sign(s)),
              (e = r),
              i || (t.gsap.killTweensOf(t.tl), (i = !0)),
              void t.tl.timeScale(n * t.options.threshold)
            );
          if (s) {
            var a = s * t.options.multiplier,
              o =
                a > 0
                  ? Math.max(t.options.threshold, a)
                  : Math.min(-t.options.threshold, a);
            (t.tween = t.gsap.to(t.tl, {
              timeScale: o,
              duration: t.options.speed,
              ease: t.options.ease,
              overwrite: t.options.overwrite,
            })),
              (i = !1);
          } else if (!i) {
            var l = t.options.stopOnEnd ? 0 : n * t.options.threshold;
            t.gsap.killTweensOf(t.tl),
              (t.tween = t.gsap.to(t.tl, {
                timeScale: l,
                duration: t.options.speed,
                overwrite: t.options.overwrite,
                ease: t.options.ease,
              })),
              (i = !0);
          }
          (n = Math.sign(s)), (e = r);
        }),
          this.gsap.ticker.add(this.tickerFn);
      }),
      (e.destroy = function () {
        this.tickerFn &&
          (this.gsap.ticker.remove(this.tickerFn), (this.tickerFn = null)),
          this.tween && this.tween.kill();
      }),
      t
    );
  })();
  (ql.pluginName = "scroller"),
    (ql.defaultOptions = {
      speed: 1,
      multiplier: 0.5,
      threshold: 1,
      ease: "expo.out",
      overwrite: !0,
      bothDirection: !0,
      reversed: !1,
      stopOnEnd: !1,
      scrollProxy: null,
    }),
    Xl.registerGSAP(Yi),
    Xl.use(ql);
  const jl = "164",
    Yl = 1,
    Kl = 2,
    Zl = 3,
    Jl = 0,
    $l = 1,
    Ql = 2,
    tc = 100,
    ec = 101,
    nc = 102,
    ic = 200,
    rc = 201,
    sc = 202,
    ac = 203,
    oc = 204,
    lc = 205,
    cc = 206,
    uc = 207,
    hc = 208,
    dc = 209,
    pc = 210,
    fc = 211,
    mc = 212,
    gc = 213,
    vc = 214,
    _c = 0,
    xc = 1,
    yc = 2,
    Sc = 0,
    Mc = 1,
    Ec = 2,
    Tc = 3,
    bc = 4,
    Dc = 5,
    wc = 6,
    Cc = 7,
    Ac = 301,
    Rc = 302,
    Pc = 306,
    Lc = 1e3,
    Ic = 1001,
    Uc = 1002,
    Nc = 1003,
    Fc = 1004,
    Oc = 1005,
    Bc = 1006,
    zc = 1007,
    kc = 1008,
    Vc = 1009,
    Hc = 1014,
    Gc = 1015,
    Wc = 1016,
    Xc = 1020,
    qc = 1023,
    jc = 1026,
    Yc = 1027,
    Kc = 33776,
    Zc = 33777,
    Jc = 33778,
    $c = 33779,
    Qc = 36492,
    tu = 2300,
    eu = 2301,
    nu = 2302,
    iu = "",
    ru = "srgb",
    su = "srgb-linear",
    au = "display-p3",
    ou = "display-p3-linear",
    lu = "linear",
    cu = "srgb",
    uu = "rec709",
    hu = "p3",
    du = 7680,
    pu = 512,
    fu = 513,
    mu = 514,
    gu = 515,
    vu = 516,
    _u = 517,
    xu = 518,
    yu = 519,
    Su = "300 es",
    Mu = 2e3,
    Eu = 2001;
  class Tu {
    addEventListener(t, e) {
      void 0 === this._listeners && (this._listeners = {});
      const n = this._listeners;
      void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
    }
    hasEventListener(t, e) {
      if (void 0 === this._listeners) return !1;
      const n = this._listeners;
      return void 0 !== n[t] && -1 !== n[t].indexOf(e);
    }
    removeEventListener(t, e) {
      if (void 0 === this._listeners) return;
      const n = this._listeners[t];
      if (void 0 !== n) {
        const t = n.indexOf(e);
        -1 !== t && n.splice(t, 1);
      }
    }
    dispatchEvent(t) {
      if (void 0 === this._listeners) return;
      const e = this._listeners[t.type];
      if (void 0 !== e) {
        t.target = this;
        const n = e.slice(0);
        for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
        t.target = null;
      }
    }
  }
  const bu = [
      "00",
      "01",
      "02",
      "03",
      "04",
      "05",
      "06",
      "07",
      "08",
      "09",
      "0a",
      "0b",
      "0c",
      "0d",
      "0e",
      "0f",
      "10",
      "11",
      "12",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "1a",
      "1b",
      "1c",
      "1d",
      "1e",
      "1f",
      "20",
      "21",
      "22",
      "23",
      "24",
      "25",
      "26",
      "27",
      "28",
      "29",
      "2a",
      "2b",
      "2c",
      "2d",
      "2e",
      "2f",
      "30",
      "31",
      "32",
      "33",
      "34",
      "35",
      "36",
      "37",
      "38",
      "39",
      "3a",
      "3b",
      "3c",
      "3d",
      "3e",
      "3f",
      "40",
      "41",
      "42",
      "43",
      "44",
      "45",
      "46",
      "47",
      "48",
      "49",
      "4a",
      "4b",
      "4c",
      "4d",
      "4e",
      "4f",
      "50",
      "51",
      "52",
      "53",
      "54",
      "55",
      "56",
      "57",
      "58",
      "59",
      "5a",
      "5b",
      "5c",
      "5d",
      "5e",
      "5f",
      "60",
      "61",
      "62",
      "63",
      "64",
      "65",
      "66",
      "67",
      "68",
      "69",
      "6a",
      "6b",
      "6c",
      "6d",
      "6e",
      "6f",
      "70",
      "71",
      "72",
      "73",
      "74",
      "75",
      "76",
      "77",
      "78",
      "79",
      "7a",
      "7b",
      "7c",
      "7d",
      "7e",
      "7f",
      "80",
      "81",
      "82",
      "83",
      "84",
      "85",
      "86",
      "87",
      "88",
      "89",
      "8a",
      "8b",
      "8c",
      "8d",
      "8e",
      "8f",
      "90",
      "91",
      "92",
      "93",
      "94",
      "95",
      "96",
      "97",
      "98",
      "99",
      "9a",
      "9b",
      "9c",
      "9d",
      "9e",
      "9f",
      "a0",
      "a1",
      "a2",
      "a3",
      "a4",
      "a5",
      "a6",
      "a7",
      "a8",
      "a9",
      "aa",
      "ab",
      "ac",
      "ad",
      "ae",
      "af",
      "b0",
      "b1",
      "b2",
      "b3",
      "b4",
      "b5",
      "b6",
      "b7",
      "b8",
      "b9",
      "ba",
      "bb",
      "bc",
      "bd",
      "be",
      "bf",
      "c0",
      "c1",
      "c2",
      "c3",
      "c4",
      "c5",
      "c6",
      "c7",
      "c8",
      "c9",
      "ca",
      "cw",
      "cc",
      "cd",
      "ce",
      "cf",
      "d0",
      "d1",
      "d2",
      "d3",
      "d4",
      "d5",
      "d6",
      "d7",
      "d8",
      "d9",
      "da",
      "db",
      "dc",
      "dd",
      "de",
      "df",
      "e0",
      "e1",
      "e2",
      "e3",
      "e4",
      "e5",
      "e6",
      "e7",
      "e8",
      "e9",
      "ea",
      "eb",
      "ec",
      "ed",
      "ee",
      "ef",
      "f0",
      "f1",
      "f2",
      "f3",
      "f4",
      "f5",
      "f6",
      "f7",
      "f8",
      "f9",
      "fa",
      "fb",
      "fc",
      "fd",
      "fe",
      "ff",
    ],
    Du = Math.PI / 180,
    wu = 180 / Math.PI;
  function Cu() {
    const t = (4294967295 * Math.random()) | 0,
      e = (4294967295 * Math.random()) | 0,
      n = (4294967295 * Math.random()) | 0,
      i = (4294967295 * Math.random()) | 0;
    return (
      bu[255 & t] +
      bu[(t >> 8) & 255] +
      bu[(t >> 16) & 255] +
      bu[(t >> 24) & 255] +
      "-" +
      bu[255 & e] +
      bu[(e >> 8) & 255] +
      "-" +
      bu[((e >> 16) & 15) | 64] +
      bu[(e >> 24) & 255] +
      "-" +
      bu[(63 & n) | 128] +
      bu[(n >> 8) & 255] +
      "-" +
      bu[(n >> 16) & 255] +
      bu[(n >> 24) & 255] +
      bu[255 & i] +
      bu[(i >> 8) & 255] +
      bu[(i >> 16) & 255] +
      bu[(i >> 24) & 255]
    ).toLowerCase();
  }
  function Au(t, e, n) {
    return Math.max(e, Math.min(n, t));
  }
  function Ru(t, e, n) {
    return (1 - n) * t + n * e;
  }
  function Pu(t, e) {
    switch (e.constructor) {
      case Float32Array:
        return t;
      case Uint32Array:
        return t / 4294967295;
      case Uint16Array:
        return t / 65535;
      case Uint8Array:
        return t / 255;
      case Int32Array:
        return Math.max(t / 2147483647, -1);
      case Int16Array:
        return Math.max(t / 32767, -1);
      case Int8Array:
        return Math.max(t / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function Lu(t, e) {
    switch (e.constructor) {
      case Float32Array:
        return t;
      case Uint32Array:
        return Math.round(4294967295 * t);
      case Uint16Array:
        return Math.round(65535 * t);
      case Uint8Array:
        return Math.round(255 * t);
      case Int32Array:
        return Math.round(2147483647 * t);
      case Int16Array:
        return Math.round(32767 * t);
      case Int8Array:
        return Math.round(127 * t);
      default:
        throw new Error("Invalid component type.");
    }
  }
  class Iu {
    constructor(t = 0, e = 0) {
      (Iu.prototype.isVector2 = !0), (this.x = t), (this.y = e);
    }
    get width() {
      return this.x;
    }
    set width(t) {
      this.x = t;
    }
    get height() {
      return this.y;
    }
    set height(t) {
      this.y = t;
    }
    set(t, e) {
      return (this.x = t), (this.y = e), this;
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(t) {
      return (this.x = t.x), (this.y = t.y), this;
    }
    add(t) {
      return (this.x += t.x), (this.y += t.y), this;
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), this;
    }
    addVectors(t, e) {
      return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
    }
    addScaledVector(t, e) {
      return (this.x += t.x * e), (this.y += t.y * e), this;
    }
    sub(t) {
      return (this.x -= t.x), (this.y -= t.y), this;
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), this;
    }
    subVectors(t, e) {
      return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
    }
    multiply(t) {
      return (this.x *= t.x), (this.y *= t.y), this;
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), this;
    }
    divide(t) {
      return (this.x /= t.x), (this.y /= t.y), this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    applyMatrix3(t) {
      const e = this.x,
        n = this.y,
        i = t.elements;
      return (
        (this.x = i[0] * e + i[3] * n + i[6]),
        (this.y = i[1] * e + i[4] * n + i[7]),
        this
      );
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        this
      );
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(t, Math.min(e, n))
      );
    }
    floor() {
      return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
    }
    ceil() {
      return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
    }
    round() {
      return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
    }
    roundToZero() {
      return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y;
    }
    cross(t) {
      return this.x * t.y - this.y * t.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    angleTo(t) {
      const e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e) return Math.PI / 2;
      const n = this.dot(t) / e;
      return Math.acos(Au(n, -1, 1));
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      const e = this.x - t.x,
        n = this.y - t.y;
      return e * e + n * n;
    }
    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
      );
    }
    lerpVectors(t, e, n) {
      return (
        (this.x = t.x + (e.x - t.x) * n), (this.y = t.y + (e.y - t.y) * n), this
      );
    }
    equals(t) {
      return t.x === this.x && t.y === this.y;
    }
    fromArray(t, e = 0) {
      return (this.x = t[e]), (this.y = t[e + 1]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.x), (t[e + 1] = this.y), t;
    }
    fromBufferAttribute(t, e) {
      return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
    }
    rotateAround(t, e) {
      const n = Math.cos(e),
        i = Math.sin(e),
        r = this.x - t.x,
        s = this.y - t.y;
      return (
        (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this
      );
    }
    random() {
      return (this.x = Math.random()), (this.y = Math.random()), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  class Uu {
    constructor(t, e, n, i, r, s, a, o, l) {
      (Uu.prototype.isMatrix3 = !0),
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        void 0 !== t && this.set(t, e, n, i, r, s, a, o, l);
    }
    set(t, e, n, i, r, s, a, o, l) {
      const c = this.elements;
      return (
        (c[0] = t),
        (c[1] = i),
        (c[2] = a),
        (c[3] = e),
        (c[4] = r),
        (c[5] = o),
        (c[6] = n),
        (c[7] = s),
        (c[8] = l),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(t) {
      const e = this.elements,
        n = t.elements;
      return (
        (e[0] = n[0]),
        (e[1] = n[1]),
        (e[2] = n[2]),
        (e[3] = n[3]),
        (e[4] = n[4]),
        (e[5] = n[5]),
        (e[6] = n[6]),
        (e[7] = n[7]),
        (e[8] = n[8]),
        this
      );
    }
    extractBasis(t, e, n) {
      return (
        t.setFromMatrix3Column(this, 0),
        e.setFromMatrix3Column(this, 1),
        n.setFromMatrix3Column(this, 2),
        this
      );
    }
    setFromMatrix4(t) {
      const e = t.elements;
      return (
        this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
      );
    }
    multiply(t) {
      return this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      const n = t.elements,
        i = e.elements,
        r = this.elements,
        s = n[0],
        a = n[3],
        o = n[6],
        l = n[1],
        c = n[4],
        u = n[7],
        h = n[2],
        d = n[5],
        p = n[8],
        f = i[0],
        m = i[3],
        g = i[6],
        v = i[1],
        _ = i[4],
        x = i[7],
        y = i[2],
        S = i[5],
        M = i[8];
      return (
        (r[0] = s * f + a * v + o * y),
        (r[3] = s * m + a * _ + o * S),
        (r[6] = s * g + a * x + o * M),
        (r[1] = l * f + c * v + u * y),
        (r[4] = l * m + c * _ + u * S),
        (r[7] = l * g + c * x + u * M),
        (r[2] = h * f + d * v + p * y),
        (r[5] = h * m + d * _ + p * S),
        (r[8] = h * g + d * x + p * M),
        this
      );
    }
    multiplyScalar(t) {
      const e = this.elements;
      return (
        (e[0] *= t),
        (e[3] *= t),
        (e[6] *= t),
        (e[1] *= t),
        (e[4] *= t),
        (e[7] *= t),
        (e[2] *= t),
        (e[5] *= t),
        (e[8] *= t),
        this
      );
    }
    determinant() {
      const t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        c = t[8];
      return (
        e * s * c - e * a * l - n * r * c + n * a * o + i * r * l - i * s * o
      );
    }
    invert() {
      const t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        c = t[8],
        u = c * s - a * l,
        h = a * o - c * r,
        d = l * r - s * o,
        p = e * u + n * h + i * d;
      if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f = 1 / p;
      return (
        (t[0] = u * f),
        (t[1] = (i * l - c * n) * f),
        (t[2] = (a * n - i * s) * f),
        (t[3] = h * f),
        (t[4] = (c * e - i * o) * f),
        (t[5] = (i * r - a * e) * f),
        (t[6] = d * f),
        (t[7] = (n * o - l * e) * f),
        (t[8] = (s * e - n * r) * f),
        this
      );
    }
    transpose() {
      let t;
      const e = this.elements;
      return (
        (t = e[1]),
        (e[1] = e[3]),
        (e[3] = t),
        (t = e[2]),
        (e[2] = e[6]),
        (e[6] = t),
        (t = e[5]),
        (e[5] = e[7]),
        (e[7] = t),
        this
      );
    }
    getNormalMatrix(t) {
      return this.setFromMatrix4(t).invert().transpose();
    }
    transposeIntoArray(t) {
      const e = this.elements;
      return (
        (t[0] = e[0]),
        (t[1] = e[3]),
        (t[2] = e[6]),
        (t[3] = e[1]),
        (t[4] = e[4]),
        (t[5] = e[7]),
        (t[6] = e[2]),
        (t[7] = e[5]),
        (t[8] = e[8]),
        this
      );
    }
    setUvTransform(t, e, n, i, r, s, a) {
      const o = Math.cos(r),
        l = Math.sin(r);
      return (
        this.set(
          n * o,
          n * l,
          -n * (o * s + l * a) + s + t,
          -i * l,
          i * o,
          -i * (-l * s + o * a) + a + e,
          0,
          0,
          1
        ),
        this
      );
    }
    scale(t, e) {
      return this.premultiply(Nu.makeScale(t, e)), this;
    }
    rotate(t) {
      return this.premultiply(Nu.makeRotation(-t)), this;
    }
    translate(t, e) {
      return this.premultiply(Nu.makeTranslation(t, e)), this;
    }
    makeTranslation(t, e) {
      return (
        t.isVector2
          ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
          : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
        this
      );
    }
    makeRotation(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
    }
    makeScale(t, e) {
      return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
    }
    equals(t) {
      const e = this.elements,
        n = t.elements;
      for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
      return !0;
    }
    fromArray(t, e = 0) {
      for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
      return this;
    }
    toArray(t = [], e = 0) {
      const n = this.elements;
      return (
        (t[e] = n[0]),
        (t[e + 1] = n[1]),
        (t[e + 2] = n[2]),
        (t[e + 3] = n[3]),
        (t[e + 4] = n[4]),
        (t[e + 5] = n[5]),
        (t[e + 6] = n[6]),
        (t[e + 7] = n[7]),
        (t[e + 8] = n[8]),
        t
      );
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  const Nu = new Uu();
  function Fu(t) {
    for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
    return !1;
  }
  function Ou(t) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", t);
  }
  function Bu() {
    const t = Ou("canvas");
    return (t.style.display = "block"), t;
  }
  Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array;
  const zu = {};
  const ku = new Uu().set(
      0.8224621,
      0.177538,
      0,
      0.0331941,
      0.9668058,
      0,
      0.0170827,
      0.0723974,
      0.9105199
    ),
    Vu = new Uu().set(
      1.2249401,
      -0.2249404,
      0,
      -0.0420569,
      1.0420571,
      0,
      -0.0196376,
      -0.0786361,
      1.0982735
    ),
    Hu = {
      [su]: {
        transfer: lu,
        primaries: uu,
        toReference: (t) => t,
        fromReference: (t) => t,
      },
      [ru]: {
        transfer: cu,
        primaries: uu,
        toReference: (t) => t.convertSRGBToLinear(),
        fromReference: (t) => t.convertLinearToSRGB(),
      },
      [ou]: {
        transfer: lu,
        primaries: hu,
        toReference: (t) => t.applyMatrix3(Vu),
        fromReference: (t) => t.applyMatrix3(ku),
      },
      [au]: {
        transfer: cu,
        primaries: hu,
        toReference: (t) => t.convertSRGBToLinear().applyMatrix3(Vu),
        fromReference: (t) => t.applyMatrix3(ku).convertLinearToSRGB(),
      },
    },
    Gu = new Set([su, ou]),
    Wu = {
      enabled: !0,
      _workingColorSpace: su,
      get workingColorSpace() {
        return this._workingColorSpace;
      },
      set workingColorSpace(t) {
        if (!Gu.has(t))
          throw new Error(`Unsupported working color space, "${t}".`);
        this._workingColorSpace = t;
      },
      convert: function (t, e, n) {
        if (!1 === this.enabled || e === n || !e || !n) return t;
        const i = Hu[e].toReference;
        return (0, Hu[n].fromReference)(i(t));
      },
      fromWorkingColorSpace: function (t, e) {
        return this.convert(t, this._workingColorSpace, e);
      },
      toWorkingColorSpace: function (t, e) {
        return this.convert(t, e, this._workingColorSpace);
      },
      getPrimaries: function (t) {
        return Hu[t].primaries;
      },
      getTransfer: function (t) {
        return t === iu ? lu : Hu[t].transfer;
      },
    };
  function Xu(t) {
    return t < 0.04045
      ? 0.0773993808 * t
      : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
  }
  function qu(t) {
    return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
  }
  let ju;
  class Yu {
    static getDataURL(t) {
      if (/^data:/i.test(t.src)) return t.src;
      if ("undefined" == typeof HTMLCanvasElement) return t.src;
      let e;
      if (t instanceof HTMLCanvasElement) e = t;
      else {
        void 0 === ju && (ju = Ou("canvas")),
          (ju.width = t.width),
          (ju.height = t.height);
        const n = ju.getContext("2d");
        t instanceof ImageData
          ? n.putImageData(t, 0, 0)
          : n.drawImage(t, 0, 0, t.width, t.height),
          (e = ju);
      }
      return e.width > 2048 || e.height > 2048
        ? (console.warn(
            "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
            t
          ),
          e.toDataURL("image/jpeg", 0.6))
        : e.toDataURL("image/png");
    }
    static sRGBToLinear(t) {
      if (
        ("undefined" != typeof HTMLImageElement &&
          t instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          t instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
      ) {
        const e = Ou("canvas");
        (e.width = t.width), (e.height = t.height);
        const n = e.getContext("2d");
        n.drawImage(t, 0, 0, t.width, t.height);
        const i = n.getImageData(0, 0, t.width, t.height),
          r = i.data;
        for (let t = 0; t < r.length; t++) r[t] = 255 * Xu(r[t] / 255);
        return n.putImageData(i, 0, 0), e;
      }
      if (t.data) {
        const e = t.data.slice(0);
        for (let t = 0; t < e.length; t++)
          e instanceof Uint8Array || e instanceof Uint8ClampedArray
            ? (e[t] = Math.floor(255 * Xu(e[t] / 255)))
            : (e[t] = Xu(e[t]));
        return { data: e, width: t.width, height: t.height };
      }
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        t
      );
    }
  }
  let Ku = 0;
  class Zu {
    constructor(t = null) {
      (this.isSource = !0),
        Object.defineProperty(this, "id", { value: Ku++ }),
        (this.uuid = Cu()),
        (this.data = t),
        (this.dataReady = !0),
        (this.version = 0);
    }
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
      const n = { uuid: this.uuid, url: "" },
        i = this.data;
      if (null !== i) {
        let t;
        if (Array.isArray(i)) {
          t = [];
          for (let e = 0, n = i.length; e < n; e++)
            i[e].isDataTexture ? t.push(Ju(i[e].image)) : t.push(Ju(i[e]));
        } else t = Ju(i);
        n.url = t;
      }
      return e || (t.images[this.uuid] = n), n;
    }
  }
  function Ju(t) {
    return ("undefined" != typeof HTMLImageElement &&
      t instanceof HTMLImageElement) ||
      ("undefined" != typeof HTMLCanvasElement &&
        t instanceof HTMLCanvasElement) ||
      ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
      ? Yu.getDataURL(t)
      : t.data
      ? {
          data: Array.from(t.data),
          width: t.width,
          height: t.height,
          type: t.data.constructor.name,
        }
      : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  let $u = 0;
  class Qu extends Tu {
    constructor(
      t = Qu.DEFAULT_IMAGE,
      e = Qu.DEFAULT_MAPPING,
      n = 1001,
      i = 1001,
      r = 1006,
      s = 1008,
      a = 1023,
      o = 1009,
      l = Qu.DEFAULT_ANISOTROPY,
      c = ""
    ) {
      super(),
        (this.isTexture = !0),
        Object.defineProperty(this, "id", { value: $u++ }),
        (this.uuid = Cu()),
        (this.name = ""),
        (this.source = new Zu(t)),
        (this.mipmaps = []),
        (this.mapping = e),
        (this.channel = 0),
        (this.wrapS = n),
        (this.wrapT = i),
        (this.magFilter = r),
        (this.minFilter = s),
        (this.anisotropy = l),
        (this.format = a),
        (this.internalFormat = null),
        (this.type = o),
        (this.offset = new Iu(0, 0)),
        (this.repeat = new Iu(1, 1)),
        (this.center = new Iu(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new Uu()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        (this.colorSpace = c),
        (this.userData = {}),
        (this.version = 0),
        (this.onUpdate = null),
        (this.isRenderTargetTexture = !1),
        (this.pmremVersion = 0);
    }
    get image() {
      return this.source.data;
    }
    set image(t = null) {
      this.source.data = t;
    }
    updateMatrix() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return (
        (this.name = t.name),
        (this.source = t.source),
        (this.mipmaps = t.mipmaps.slice(0)),
        (this.mapping = t.mapping),
        (this.channel = t.channel),
        (this.wrapS = t.wrapS),
        (this.wrapT = t.wrapT),
        (this.magFilter = t.magFilter),
        (this.minFilter = t.minFilter),
        (this.anisotropy = t.anisotropy),
        (this.format = t.format),
        (this.internalFormat = t.internalFormat),
        (this.type = t.type),
        this.offset.copy(t.offset),
        this.repeat.copy(t.repeat),
        this.center.copy(t.center),
        (this.rotation = t.rotation),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        this.matrix.copy(t.matrix),
        (this.generateMipmaps = t.generateMipmaps),
        (this.premultiplyAlpha = t.premultiplyAlpha),
        (this.flipY = t.flipY),
        (this.unpackAlignment = t.unpackAlignment),
        (this.colorSpace = t.colorSpace),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        (this.needsUpdate = !0),
        this
      );
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
      const n = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON",
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(t).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment,
      };
      return (
        Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        e || (t.textures[this.uuid] = n),
        n
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(t) {
      if (300 !== this.mapping) return t;
      if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
        switch (this.wrapS) {
          case Lc:
            t.x = t.x - Math.floor(t.x);
            break;
          case Ic:
            t.x = t.x < 0 ? 0 : 1;
            break;
          case Uc:
            1 === Math.abs(Math.floor(t.x) % 2)
              ? (t.x = Math.ceil(t.x) - t.x)
              : (t.x = t.x - Math.floor(t.x));
        }
      if (t.y < 0 || t.y > 1)
        switch (this.wrapT) {
          case Lc:
            t.y = t.y - Math.floor(t.y);
            break;
          case Ic:
            t.y = t.y < 0 ? 0 : 1;
            break;
          case Uc:
            1 === Math.abs(Math.floor(t.y) % 2)
              ? (t.y = Math.ceil(t.y) - t.y)
              : (t.y = t.y - Math.floor(t.y));
        }
      return this.flipY && (t.y = 1 - t.y), t;
    }
    set needsUpdate(t) {
      !0 === t && (this.version++, (this.source.needsUpdate = !0));
    }
    set needsPMREMUpdate(t) {
      !0 === t && this.pmremVersion++;
    }
  }
  (Qu.DEFAULT_IMAGE = null),
    (Qu.DEFAULT_MAPPING = 300),
    (Qu.DEFAULT_ANISOTROPY = 1);
  class th {
    constructor(t = 0, e = 0, n = 0, i = 1) {
      (th.prototype.isVector4 = !0),
        (this.x = t),
        (this.y = e),
        (this.z = n),
        (this.w = i);
    }
    get width() {
      return this.z;
    }
    set width(t) {
      this.z = t;
    }
    get height() {
      return this.w;
    }
    set height(t) {
      this.w = t;
    }
    set(t, e, n, i) {
      return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setZ(t) {
      return (this.z = t), this;
    }
    setW(t) {
      return (this.w = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(t) {
      return (
        (this.x = t.x),
        (this.y = t.y),
        (this.z = t.z),
        (this.w = void 0 !== t.w ? t.w : 1),
        this
      );
    }
    add(t) {
      return (
        (this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this
      );
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
    }
    addVectors(t, e) {
      return (
        (this.x = t.x + e.x),
        (this.y = t.y + e.y),
        (this.z = t.z + e.z),
        (this.w = t.w + e.w),
        this
      );
    }
    addScaledVector(t, e) {
      return (
        (this.x += t.x * e),
        (this.y += t.y * e),
        (this.z += t.z * e),
        (this.w += t.w * e),
        this
      );
    }
    sub(t) {
      return (
        (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this
      );
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
    }
    subVectors(t, e) {
      return (
        (this.x = t.x - e.x),
        (this.y = t.y - e.y),
        (this.z = t.z - e.z),
        (this.w = t.w - e.w),
        this
      );
    }
    multiply(t) {
      return (
        (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this
      );
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
    }
    applyMatrix4(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = this.w,
        s = t.elements;
      return (
        (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
        (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
        (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
        (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
        this
      );
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    setAxisAngleFromQuaternion(t) {
      this.w = 2 * Math.acos(t.w);
      const e = Math.sqrt(1 - t.w * t.w);
      return (
        e < 1e-4
          ? ((this.x = 1), (this.y = 0), (this.z = 0))
          : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
        this
      );
    }
    setAxisAngleFromRotationMatrix(t) {
      let e, n, i, r;
      const s = 0.01,
        a = 0.1,
        o = t.elements,
        l = o[0],
        c = o[4],
        u = o[8],
        h = o[1],
        d = o[5],
        p = o[9],
        f = o[2],
        m = o[6],
        g = o[10];
      if (Math.abs(c - h) < s && Math.abs(u - f) < s && Math.abs(p - m) < s) {
        if (
          Math.abs(c + h) < a &&
          Math.abs(u + f) < a &&
          Math.abs(p + m) < a &&
          Math.abs(l + d + g - 3) < a
        )
          return this.set(1, 0, 0, 0), this;
        e = Math.PI;
        const t = (l + 1) / 2,
          o = (d + 1) / 2,
          v = (g + 1) / 2,
          _ = (c + h) / 4,
          x = (u + f) / 4,
          y = (p + m) / 4;
        return (
          t > o && t > v
            ? t < s
              ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
              : ((n = Math.sqrt(t)), (i = _ / n), (r = x / n))
            : o > v
            ? o < s
              ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
              : ((i = Math.sqrt(o)), (n = _ / i), (r = y / i))
            : v < s
            ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
            : ((r = Math.sqrt(v)), (n = x / r), (i = y / r)),
          this.set(n, i, r, e),
          this
        );
      }
      let v = Math.sqrt(
        (m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c)
      );
      return (
        Math.abs(v) < 0.001 && (v = 1),
        (this.x = (m - p) / v),
        (this.y = (u - f) / v),
        (this.z = (h - c) / v),
        (this.w = Math.acos((l + d + g - 1) / 2)),
        this
      );
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)),
        (this.y = Math.min(this.y, t.y)),
        (this.z = Math.min(this.z, t.z)),
        (this.w = Math.min(this.w, t.w)),
        this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)),
        (this.y = Math.max(this.y, t.y)),
        (this.z = Math.max(this.z, t.z)),
        (this.w = Math.max(this.w, t.w)),
        this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        (this.z = Math.max(t.z, Math.min(e.z, this.z))),
        (this.w = Math.max(t.w, Math.min(e.w, this.w))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        (this.z = Math.max(t, Math.min(e, this.z))),
        (this.w = Math.max(t, Math.min(e, this.w))),
        this
      );
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(t, Math.min(e, n))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        (this.w = Math.floor(this.w)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        (this.w = Math.ceil(this.w)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        (this.w = Math.round(this.w)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = Math.trunc(this.x)),
        (this.y = Math.trunc(this.y)),
        (this.z = Math.trunc(this.z)),
        (this.w = Math.trunc(this.w)),
        this
      );
    }
    negate() {
      return (
        (this.x = -this.x),
        (this.y = -this.y),
        (this.z = -this.z),
        (this.w = -this.w),
        this
      );
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    }
    lengthSq() {
      return (
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    length() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    manhattanLength() {
      return (
        Math.abs(this.x) +
        Math.abs(this.y) +
        Math.abs(this.z) +
        Math.abs(this.w)
      );
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e),
        (this.y += (t.y - this.y) * e),
        (this.z += (t.z - this.z) * e),
        (this.w += (t.w - this.w) * e),
        this
      );
    }
    lerpVectors(t, e, n) {
      return (
        (this.x = t.x + (e.x - t.x) * n),
        (this.y = t.y + (e.y - t.y) * n),
        (this.z = t.z + (e.z - t.z) * n),
        (this.w = t.w + (e.w - t.w) * n),
        this
      );
    }
    equals(t) {
      return (
        t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
      );
    }
    fromArray(t, e = 0) {
      return (
        (this.x = t[e]),
        (this.y = t[e + 1]),
        (this.z = t[e + 2]),
        (this.w = t[e + 3]),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this.x),
        (t[e + 1] = this.y),
        (t[e + 2] = this.z),
        (t[e + 3] = this.w),
        t
      );
    }
    fromBufferAttribute(t, e) {
      return (
        (this.x = t.getX(e)),
        (this.y = t.getY(e)),
        (this.z = t.getZ(e)),
        (this.w = t.getW(e)),
        this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        (this.w = Math.random()),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  }
  class eh extends Tu {
    constructor(t = 1, e = 1, n = {}) {
      super(),
        (this.isRenderTarget = !0),
        (this.width = t),
        (this.height = e),
        (this.depth = 1),
        (this.scissor = new th(0, 0, t, e)),
        (this.scissorTest = !1),
        (this.viewport = new th(0, 0, t, e));
      const i = { width: t, height: e, depth: 1 };
      n = Object.assign(
        {
          generateMipmaps: !1,
          internalFormat: null,
          minFilter: Bc,
          depthBuffer: !0,
          stencilBuffer: !1,
          resolveDepthBuffer: !0,
          resolveStencilBuffer: !0,
          depthTexture: null,
          samples: 0,
          count: 1,
        },
        n
      );
      const r = new Qu(
        i,
        n.mapping,
        n.wrapS,
        n.wrapT,
        n.magFilter,
        n.minFilter,
        n.format,
        n.type,
        n.anisotropy,
        n.colorSpace
      );
      (r.flipY = !1),
        (r.generateMipmaps = n.generateMipmaps),
        (r.internalFormat = n.internalFormat),
        (this.textures = []);
      const s = n.count;
      for (let t = 0; t < s; t++)
        (this.textures[t] = r.clone()),
          (this.textures[t].isRenderTargetTexture = !0);
      (this.depthBuffer = n.depthBuffer),
        (this.stencilBuffer = n.stencilBuffer),
        (this.resolveDepthBuffer = n.resolveDepthBuffer),
        (this.resolveStencilBuffer = n.resolveStencilBuffer),
        (this.depthTexture = n.depthTexture),
        (this.samples = n.samples);
    }
    get texture() {
      return this.textures[0];
    }
    set texture(t) {
      this.textures[0] = t;
    }
    setSize(t, e, n = 1) {
      if (this.width !== t || this.height !== e || this.depth !== n) {
        (this.width = t), (this.height = e), (this.depth = n);
        for (let i = 0, r = this.textures.length; i < r; i++)
          (this.textures[i].image.width = t),
            (this.textures[i].image.height = e),
            (this.textures[i].image.depth = n);
        this.dispose();
      }
      this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.width = t.width),
        (this.height = t.height),
        (this.depth = t.depth),
        this.scissor.copy(t.scissor),
        (this.scissorTest = t.scissorTest),
        this.viewport.copy(t.viewport),
        (this.textures.length = 0);
      for (let e = 0, n = t.textures.length; e < n; e++)
        (this.textures[e] = t.textures[e].clone()),
          (this.textures[e].isRenderTargetTexture = !0);
      const e = Object.assign({}, t.texture.image);
      return (
        (this.texture.source = new Zu(e)),
        (this.depthBuffer = t.depthBuffer),
        (this.stencilBuffer = t.stencilBuffer),
        (this.resolveDepthBuffer = t.resolveDepthBuffer),
        (this.resolveStencilBuffer = t.resolveStencilBuffer),
        null !== t.depthTexture && (this.depthTexture = t.depthTexture.clone()),
        (this.samples = t.samples),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  class nh extends eh {
    constructor(t = 1, e = 1, n = {}) {
      super(t, e, n), (this.isWebGLRenderTarget = !0);
    }
  }
  class ih extends Qu {
    constructor(t = null, e = 1, n = 1, i = 1) {
      super(null),
        (this.isDataArrayTexture = !0),
        (this.image = { data: t, width: e, height: n, depth: i }),
        (this.magFilter = Nc),
        (this.minFilter = Nc),
        (this.wrapR = Ic),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  class rh extends Qu {
    constructor(t = null, e = 1, n = 1, i = 1) {
      super(null),
        (this.isData3DTexture = !0),
        (this.image = { data: t, width: e, height: n, depth: i }),
        (this.magFilter = Nc),
        (this.minFilter = Nc),
        (this.wrapR = Ic),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  class sh {
    constructor(t = 0, e = 0, n = 0, i = 1) {
      (this.isQuaternion = !0),
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._w = i);
    }
    static slerpFlat(t, e, n, i, r, s, a) {
      let o = n[i + 0],
        l = n[i + 1],
        c = n[i + 2],
        u = n[i + 3];
      const h = r[s + 0],
        d = r[s + 1],
        p = r[s + 2],
        f = r[s + 3];
      if (0 === a)
        return (
          (t[e + 0] = o), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = u)
        );
      if (1 === a)
        return (
          (t[e + 0] = h), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = f)
        );
      if (u !== f || o !== h || l !== d || c !== p) {
        let t = 1 - a;
        const e = o * h + l * d + c * p + u * f,
          n = e >= 0 ? 1 : -1,
          i = 1 - e * e;
        if (i > Number.EPSILON) {
          const r = Math.sqrt(i),
            s = Math.atan2(r, e * n);
          (t = Math.sin(t * s) / r), (a = Math.sin(a * s) / r);
        }
        const r = a * n;
        if (
          ((o = o * t + h * r),
          (l = l * t + d * r),
          (c = c * t + p * r),
          (u = u * t + f * r),
          t === 1 - a)
        ) {
          const t = 1 / Math.sqrt(o * o + l * l + c * c + u * u);
          (o *= t), (l *= t), (c *= t), (u *= t);
        }
      }
      (t[e] = o), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = u);
    }
    static multiplyQuaternionsFlat(t, e, n, i, r, s) {
      const a = n[i],
        o = n[i + 1],
        l = n[i + 2],
        c = n[i + 3],
        u = r[s],
        h = r[s + 1],
        d = r[s + 2],
        p = r[s + 3];
      return (
        (t[e] = a * p + c * u + o * d - l * h),
        (t[e + 1] = o * p + c * h + l * u - a * d),
        (t[e + 2] = l * p + c * d + a * h - o * u),
        (t[e + 3] = c * p - a * u - o * h - l * d),
        t
      );
    }
    get x() {
      return this._x;
    }
    set x(t) {
      (this._x = t), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      (this._y = t), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      (this._z = t), this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(t) {
      (this._w = t), this._onChangeCallback();
    }
    set(t, e, n, i) {
      return (
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._w = i),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(t) {
      return (
        (this._x = t.x),
        (this._y = t.y),
        (this._z = t.z),
        (this._w = t.w),
        this._onChangeCallback(),
        this
      );
    }
    setFromEuler(t, e = !0) {
      const n = t._x,
        i = t._y,
        r = t._z,
        s = t._order,
        a = Math.cos,
        o = Math.sin,
        l = a(n / 2),
        c = a(i / 2),
        u = a(r / 2),
        h = o(n / 2),
        d = o(i / 2),
        p = o(r / 2);
      switch (s) {
        case "XYZ":
          (this._x = h * c * u + l * d * p),
            (this._y = l * d * u - h * c * p),
            (this._z = l * c * p + h * d * u),
            (this._w = l * c * u - h * d * p);
          break;
        case "YXZ":
          (this._x = h * c * u + l * d * p),
            (this._y = l * d * u - h * c * p),
            (this._z = l * c * p - h * d * u),
            (this._w = l * c * u + h * d * p);
          break;
        case "ZXY":
          (this._x = h * c * u - l * d * p),
            (this._y = l * d * u + h * c * p),
            (this._z = l * c * p + h * d * u),
            (this._w = l * c * u - h * d * p);
          break;
        case "ZYX":
          (this._x = h * c * u - l * d * p),
            (this._y = l * d * u + h * c * p),
            (this._z = l * c * p - h * d * u),
            (this._w = l * c * u + h * d * p);
          break;
        case "YZX":
          (this._x = h * c * u + l * d * p),
            (this._y = l * d * u + h * c * p),
            (this._z = l * c * p - h * d * u),
            (this._w = l * c * u - h * d * p);
          break;
        case "XZY":
          (this._x = h * c * u - l * d * p),
            (this._y = l * d * u - h * c * p),
            (this._z = l * c * p + h * d * u),
            (this._w = l * c * u + h * d * p);
          break;
        default:
          console.warn(
            "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
              s
          );
      }
      return !0 === e && this._onChangeCallback(), this;
    }
    setFromAxisAngle(t, e) {
      const n = e / 2,
        i = Math.sin(n);
      return (
        (this._x = t.x * i),
        (this._y = t.y * i),
        (this._z = t.z * i),
        (this._w = Math.cos(n)),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(t) {
      const e = t.elements,
        n = e[0],
        i = e[4],
        r = e[8],
        s = e[1],
        a = e[5],
        o = e[9],
        l = e[2],
        c = e[6],
        u = e[10],
        h = n + a + u;
      if (h > 0) {
        const t = 0.5 / Math.sqrt(h + 1);
        (this._w = 0.25 / t),
          (this._x = (c - o) * t),
          (this._y = (r - l) * t),
          (this._z = (s - i) * t);
      } else if (n > a && n > u) {
        const t = 2 * Math.sqrt(1 + n - a - u);
        (this._w = (c - o) / t),
          (this._x = 0.25 * t),
          (this._y = (i + s) / t),
          (this._z = (r + l) / t);
      } else if (a > u) {
        const t = 2 * Math.sqrt(1 + a - n - u);
        (this._w = (r - l) / t),
          (this._x = (i + s) / t),
          (this._y = 0.25 * t),
          (this._z = (o + c) / t);
      } else {
        const t = 2 * Math.sqrt(1 + u - n - a);
        (this._w = (s - i) / t),
          (this._x = (r + l) / t),
          (this._y = (o + c) / t),
          (this._z = 0.25 * t);
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(t, e) {
      let n = t.dot(e) + 1;
      return (
        n < Number.EPSILON
          ? ((n = 0),
            Math.abs(t.x) > Math.abs(t.z)
              ? ((this._x = -t.y),
                (this._y = t.x),
                (this._z = 0),
                (this._w = n))
              : ((this._x = 0),
                (this._y = -t.z),
                (this._z = t.y),
                (this._w = n)))
          : ((this._x = t.y * e.z - t.z * e.y),
            (this._y = t.z * e.x - t.x * e.z),
            (this._z = t.x * e.y - t.y * e.x),
            (this._w = n)),
        this.normalize()
      );
    }
    angleTo(t) {
      return 2 * Math.acos(Math.abs(Au(this.dot(t), -1, 1)));
    }
    rotateTowards(t, e) {
      const n = this.angleTo(t);
      if (0 === n) return this;
      const i = Math.min(1, e / n);
      return this.slerp(t, i), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return (
        (this._x *= -1),
        (this._y *= -1),
        (this._z *= -1),
        this._onChangeCallback(),
        this
      );
    }
    dot(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    }
    lengthSq() {
      return (
        this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
      );
    }
    length() {
      return Math.sqrt(
        this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
      );
    }
    normalize() {
      let t = this.length();
      return (
        0 === t
          ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
          : ((t = 1 / t),
            (this._x = this._x * t),
            (this._y = this._y * t),
            (this._z = this._z * t),
            (this._w = this._w * t)),
        this._onChangeCallback(),
        this
      );
    }
    multiply(t) {
      return this.multiplyQuaternions(this, t);
    }
    premultiply(t) {
      return this.multiplyQuaternions(t, this);
    }
    multiplyQuaternions(t, e) {
      const n = t._x,
        i = t._y,
        r = t._z,
        s = t._w,
        a = e._x,
        o = e._y,
        l = e._z,
        c = e._w;
      return (
        (this._x = n * c + s * a + i * l - r * o),
        (this._y = i * c + s * o + r * a - n * l),
        (this._z = r * c + s * l + n * o - i * a),
        (this._w = s * c - n * a - i * o - r * l),
        this._onChangeCallback(),
        this
      );
    }
    slerp(t, e) {
      if (0 === e) return this;
      if (1 === e) return this.copy(t);
      const n = this._x,
        i = this._y,
        r = this._z,
        s = this._w;
      let a = s * t._w + n * t._x + i * t._y + r * t._z;
      if (
        (a < 0
          ? ((this._w = -t._w),
            (this._x = -t._x),
            (this._y = -t._y),
            (this._z = -t._z),
            (a = -a))
          : this.copy(t),
        a >= 1)
      )
        return (this._w = s), (this._x = n), (this._y = i), (this._z = r), this;
      const o = 1 - a * a;
      if (o <= Number.EPSILON) {
        const t = 1 - e;
        return (
          (this._w = t * s + e * this._w),
          (this._x = t * n + e * this._x),
          (this._y = t * i + e * this._y),
          (this._z = t * r + e * this._z),
          this.normalize(),
          this
        );
      }
      const l = Math.sqrt(o),
        c = Math.atan2(l, a),
        u = Math.sin((1 - e) * c) / l,
        h = Math.sin(e * c) / l;
      return (
        (this._w = s * u + this._w * h),
        (this._x = n * u + this._x * h),
        (this._y = i * u + this._y * h),
        (this._z = r * u + this._z * h),
        this._onChangeCallback(),
        this
      );
    }
    slerpQuaternions(t, e, n) {
      return this.copy(t).slerp(e, n);
    }
    random() {
      const t = 2 * Math.PI * Math.random(),
        e = 2 * Math.PI * Math.random(),
        n = Math.random(),
        i = Math.sqrt(1 - n),
        r = Math.sqrt(n);
      return this.set(
        i * Math.sin(t),
        i * Math.cos(t),
        r * Math.sin(e),
        r * Math.cos(e)
      );
    }
    equals(t) {
      return (
        t._x === this._x &&
        t._y === this._y &&
        t._z === this._z &&
        t._w === this._w
      );
    }
    fromArray(t, e = 0) {
      return (
        (this._x = t[e]),
        (this._y = t[e + 1]),
        (this._z = t[e + 2]),
        (this._w = t[e + 3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this._x),
        (t[e + 1] = this._y),
        (t[e + 2] = this._z),
        (t[e + 3] = this._w),
        t
      );
    }
    fromBufferAttribute(t, e) {
      return (
        (this._x = t.getX(e)),
        (this._y = t.getY(e)),
        (this._z = t.getZ(e)),
        (this._w = t.getW(e)),
        this._onChangeCallback(),
        this
      );
    }
    toJSON() {
      return this.toArray();
    }
    _onChange(t) {
      return (this._onChangeCallback = t), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w;
    }
  }
  class ah {
    constructor(t = 0, e = 0, n = 0) {
      (ah.prototype.isVector3 = !0), (this.x = t), (this.y = e), (this.z = n);
    }
    set(t, e, n) {
      return (
        void 0 === n && (n = this.z),
        (this.x = t),
        (this.y = e),
        (this.z = n),
        this
      );
    }
    setScalar(t) {
      return (this.x = t), (this.y = t), (this.z = t), this;
    }
    setX(t) {
      return (this.x = t), this;
    }
    setY(t) {
      return (this.y = t), this;
    }
    setZ(t) {
      return (this.z = t), this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(t) {
      return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
    }
    add(t) {
      return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
    }
    addScalar(t) {
      return (this.x += t), (this.y += t), (this.z += t), this;
    }
    addVectors(t, e) {
      return (
        (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
      );
    }
    addScaledVector(t, e) {
      return (
        (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
      );
    }
    sub(t) {
      return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
    }
    subScalar(t) {
      return (this.x -= t), (this.y -= t), (this.z -= t), this;
    }
    subVectors(t, e) {
      return (
        (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
      );
    }
    multiply(t) {
      return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
    }
    multiplyScalar(t) {
      return (this.x *= t), (this.y *= t), (this.z *= t), this;
    }
    multiplyVectors(t, e) {
      return (
        (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
      );
    }
    applyEuler(t) {
      return this.applyQuaternion(lh.setFromEuler(t));
    }
    applyAxisAngle(t, e) {
      return this.applyQuaternion(lh.setFromAxisAngle(t, e));
    }
    applyMatrix3(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements;
      return (
        (this.x = r[0] * e + r[3] * n + r[6] * i),
        (this.y = r[1] * e + r[4] * n + r[7] * i),
        (this.z = r[2] * e + r[5] * n + r[8] * i),
        this
      );
    }
    applyNormalMatrix(t) {
      return this.applyMatrix3(t).normalize();
    }
    applyMatrix4(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements,
        s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
      return (
        (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
        (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
        (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
        this
      );
    }
    applyQuaternion(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.x,
        s = t.y,
        a = t.z,
        o = t.w,
        l = 2 * (s * i - a * n),
        c = 2 * (a * e - r * i),
        u = 2 * (r * n - s * e);
      return (
        (this.x = e + o * l + s * u - a * c),
        (this.y = n + o * c + a * l - r * u),
        (this.z = i + o * u + r * c - s * l),
        this
      );
    }
    project(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
        t.projectionMatrix
      );
    }
    unproject(t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
        t.matrixWorld
      );
    }
    transformDirection(t) {
      const e = this.x,
        n = this.y,
        i = this.z,
        r = t.elements;
      return (
        (this.x = r[0] * e + r[4] * n + r[8] * i),
        (this.y = r[1] * e + r[5] * n + r[9] * i),
        (this.z = r[2] * e + r[6] * n + r[10] * i),
        this.normalize()
      );
    }
    divide(t) {
      return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    min(t) {
      return (
        (this.x = Math.min(this.x, t.x)),
        (this.y = Math.min(this.y, t.y)),
        (this.z = Math.min(this.z, t.z)),
        this
      );
    }
    max(t) {
      return (
        (this.x = Math.max(this.x, t.x)),
        (this.y = Math.max(this.y, t.y)),
        (this.z = Math.max(this.z, t.z)),
        this
      );
    }
    clamp(t, e) {
      return (
        (this.x = Math.max(t.x, Math.min(e.x, this.x))),
        (this.y = Math.max(t.y, Math.min(e.y, this.y))),
        (this.z = Math.max(t.z, Math.min(e.z, this.z))),
        this
      );
    }
    clampScalar(t, e) {
      return (
        (this.x = Math.max(t, Math.min(e, this.x))),
        (this.y = Math.max(t, Math.min(e, this.y))),
        (this.z = Math.max(t, Math.min(e, this.z))),
        this
      );
    }
    clampLength(t, e) {
      const n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(
        Math.max(t, Math.min(e, n))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = Math.trunc(this.x)),
        (this.y = Math.trunc(this.y)),
        (this.z = Math.trunc(this.z)),
        this
      );
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return (
        (this.x += (t.x - this.x) * e),
        (this.y += (t.y - this.y) * e),
        (this.z += (t.z - this.z) * e),
        this
      );
    }
    lerpVectors(t, e, n) {
      return (
        (this.x = t.x + (e.x - t.x) * n),
        (this.y = t.y + (e.y - t.y) * n),
        (this.z = t.z + (e.z - t.z) * n),
        this
      );
    }
    cross(t) {
      return this.crossVectors(this, t);
    }
    crossVectors(t, e) {
      const n = t.x,
        i = t.y,
        r = t.z,
        s = e.x,
        a = e.y,
        o = e.z;
      return (
        (this.x = i * o - r * a),
        (this.y = r * s - n * o),
        (this.z = n * a - i * s),
        this
      );
    }
    projectOnVector(t) {
      const e = t.lengthSq();
      if (0 === e) return this.set(0, 0, 0);
      const n = t.dot(this) / e;
      return this.copy(t).multiplyScalar(n);
    }
    projectOnPlane(t) {
      return oh.copy(this).projectOnVector(t), this.sub(oh);
    }
    reflect(t) {
      return this.sub(oh.copy(t).multiplyScalar(2 * this.dot(t)));
    }
    angleTo(t) {
      const e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (0 === e) return Math.PI / 2;
      const n = this.dot(t) / e;
      return Math.acos(Au(n, -1, 1));
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      const e = this.x - t.x,
        n = this.y - t.y,
        i = this.z - t.z;
      return e * e + n * n + i * i;
    }
    manhattanDistanceTo(t) {
      return (
        Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
      );
    }
    setFromSpherical(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    }
    setFromSphericalCoords(t, e, n) {
      const i = Math.sin(e) * t;
      return (
        (this.x = i * Math.sin(n)),
        (this.y = Math.cos(e) * t),
        (this.z = i * Math.cos(n)),
        this
      );
    }
    setFromCylindrical(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    }
    setFromCylindricalCoords(t, e, n) {
      return (
        (this.x = t * Math.sin(e)),
        (this.y = n),
        (this.z = t * Math.cos(e)),
        this
      );
    }
    setFromMatrixPosition(t) {
      const e = t.elements;
      return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
    }
    setFromMatrixScale(t) {
      const e = this.setFromMatrixColumn(t, 0).length(),
        n = this.setFromMatrixColumn(t, 1).length(),
        i = this.setFromMatrixColumn(t, 2).length();
      return (this.x = e), (this.y = n), (this.z = i), this;
    }
    setFromMatrixColumn(t, e) {
      return this.fromArray(t.elements, 4 * e);
    }
    setFromMatrix3Column(t, e) {
      return this.fromArray(t.elements, 3 * e);
    }
    setFromEuler(t) {
      return (this.x = t._x), (this.y = t._y), (this.z = t._z), this;
    }
    setFromColor(t) {
      return (this.x = t.r), (this.y = t.g), (this.z = t.b), this;
    }
    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    }
    fromArray(t, e = 0) {
      return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
    }
    fromBufferAttribute(t, e) {
      return (
        (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        this
      );
    }
    randomDirection() {
      const t = Math.random() * Math.PI * 2,
        e = 2 * Math.random() - 1,
        n = Math.sqrt(1 - e * e);
      return (
        (this.x = n * Math.cos(t)),
        (this.y = e),
        (this.z = n * Math.sin(t)),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  }
  const oh = new ah(),
    lh = new sh();
  class ch {
    constructor(
      t = new ah(1 / 0, 1 / 0, 1 / 0),
      e = new ah(-1 / 0, -1 / 0, -1 / 0)
    ) {
      (this.isBox3 = !0), (this.min = t), (this.max = e);
    }
    set(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    }
    setFromArray(t) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e += 3)
        this.expandByPoint(hh.fromArray(t, e));
      return this;
    }
    setFromBufferAttribute(t) {
      this.makeEmpty();
      for (let e = 0, n = t.count; e < n; e++)
        this.expandByPoint(hh.fromBufferAttribute(t, e));
      return this;
    }
    setFromPoints(t) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
      return this;
    }
    setFromCenterAndSize(t, e) {
      const n = hh.copy(e).multiplyScalar(0.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    }
    setFromObject(t, e = !1) {
      return this.makeEmpty(), this.expandByObject(t, e);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    }
    makeEmpty() {
      return (
        (this.min.x = this.min.y = this.min.z = 1 / 0),
        (this.max.x = this.max.y = this.max.z = -1 / 0),
        this
      );
    }
    isEmpty() {
      return (
        this.max.x < this.min.x ||
        this.max.y < this.min.y ||
        this.max.z < this.min.z
      );
    }
    getCenter(t) {
      return this.isEmpty()
        ? t.set(0, 0, 0)
        : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    }
    expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this;
    }
    expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this;
    }
    expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    }
    expandByObject(t, e = !1) {
      t.updateWorldMatrix(!1, !1);
      const n = t.geometry;
      if (void 0 !== n) {
        const i = n.getAttribute("position");
        if (!0 === e && void 0 !== i && !0 !== t.isInstancedMesh)
          for (let e = 0, n = i.count; e < n; e++)
            !0 === t.isMesh
              ? t.getVertexPosition(e, hh)
              : hh.fromBufferAttribute(i, e),
              hh.applyMatrix4(t.matrixWorld),
              this.expandByPoint(hh);
        else
          void 0 !== t.boundingBox
            ? (null === t.boundingBox && t.computeBoundingBox(),
              dh.copy(t.boundingBox))
            : (null === n.boundingBox && n.computeBoundingBox(),
              dh.copy(n.boundingBox)),
            dh.applyMatrix4(t.matrixWorld),
            this.union(dh);
      }
      const i = t.children;
      for (let t = 0, n = i.length; t < n; t++) this.expandByObject(i[t], e);
      return this;
    }
    containsPoint(t) {
      return !(
        t.x < this.min.x ||
        t.x > this.max.x ||
        t.y < this.min.y ||
        t.y > this.max.y ||
        t.z < this.min.z ||
        t.z > this.max.z
      );
    }
    containsBox(t) {
      return (
        this.min.x <= t.min.x &&
        t.max.x <= this.max.x &&
        this.min.y <= t.min.y &&
        t.max.y <= this.max.y &&
        this.min.z <= t.min.z &&
        t.max.z <= this.max.z
      );
    }
    getParameter(t, e) {
      return e.set(
        (t.x - this.min.x) / (this.max.x - this.min.x),
        (t.y - this.min.y) / (this.max.y - this.min.y),
        (t.z - this.min.z) / (this.max.z - this.min.z)
      );
    }
    intersectsBox(t) {
      return !(
        t.max.x < this.min.x ||
        t.min.x > this.max.x ||
        t.max.y < this.min.y ||
        t.min.y > this.max.y ||
        t.max.z < this.min.z ||
        t.min.z > this.max.z
      );
    }
    intersectsSphere(t) {
      return (
        this.clampPoint(t.center, hh),
        hh.distanceToSquared(t.center) <= t.radius * t.radius
      );
    }
    intersectsPlane(t) {
      let e, n;
      return (
        t.normal.x > 0
          ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
          : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
        t.normal.y > 0
          ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
          : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
        t.normal.z > 0
          ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
          : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
        e <= -t.constant && n >= -t.constant
      );
    }
    intersectsTriangle(t) {
      if (this.isEmpty()) return !1;
      this.getCenter(xh),
        yh.subVectors(this.max, xh),
        ph.subVectors(t.a, xh),
        fh.subVectors(t.b, xh),
        mh.subVectors(t.c, xh),
        gh.subVectors(fh, ph),
        vh.subVectors(mh, fh),
        _h.subVectors(ph, mh);
      let e = [
        0,
        -gh.z,
        gh.y,
        0,
        -vh.z,
        vh.y,
        0,
        -_h.z,
        _h.y,
        gh.z,
        0,
        -gh.x,
        vh.z,
        0,
        -vh.x,
        _h.z,
        0,
        -_h.x,
        -gh.y,
        gh.x,
        0,
        -vh.y,
        vh.x,
        0,
        -_h.y,
        _h.x,
        0,
      ];
      return (
        !!Eh(e, ph, fh, mh, yh) &&
        ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        !!Eh(e, ph, fh, mh, yh) &&
          (Sh.crossVectors(gh, vh),
          (e = [Sh.x, Sh.y, Sh.z]),
          Eh(e, ph, fh, mh, yh)))
      );
    }
    clampPoint(t, e) {
      return e.copy(t).clamp(this.min, this.max);
    }
    distanceToPoint(t) {
      return this.clampPoint(t, hh).distanceTo(t);
    }
    getBoundingSphere(t) {
      return (
        this.isEmpty()
          ? t.makeEmpty()
          : (this.getCenter(t.center),
            (t.radius = 0.5 * this.getSize(hh).length())),
        t
      );
    }
    intersect(t) {
      return (
        this.min.max(t.min),
        this.max.min(t.max),
        this.isEmpty() && this.makeEmpty(),
        this
      );
    }
    union(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    }
    applyMatrix4(t) {
      return (
        this.isEmpty() ||
          (uh[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
          uh[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
          uh[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
          uh[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
          uh[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
          uh[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
          uh[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
          uh[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
          this.setFromPoints(uh)),
        this
      );
    }
    translate(t) {
      return this.min.add(t), this.max.add(t), this;
    }
    equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  }
  const uh = [
      new ah(),
      new ah(),
      new ah(),
      new ah(),
      new ah(),
      new ah(),
      new ah(),
      new ah(),
    ],
    hh = new ah(),
    dh = new ch(),
    ph = new ah(),
    fh = new ah(),
    mh = new ah(),
    gh = new ah(),
    vh = new ah(),
    _h = new ah(),
    xh = new ah(),
    yh = new ah(),
    Sh = new ah(),
    Mh = new ah();
  function Eh(t, e, n, i, r) {
    for (let s = 0, a = t.length - 3; s <= a; s += 3) {
      Mh.fromArray(t, s);
      const a =
          r.x * Math.abs(Mh.x) + r.y * Math.abs(Mh.y) + r.z * Math.abs(Mh.z),
        o = e.dot(Mh),
        l = n.dot(Mh),
        c = i.dot(Mh);
      if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;
    }
    return !0;
  }
  const Th = new ch(),
    bh = new ah(),
    Dh = new ah();
  class wh {
    constructor(t = new ah(), e = -1) {
      (this.isSphere = !0), (this.center = t), (this.radius = e);
    }
    set(t, e) {
      return this.center.copy(t), (this.radius = e), this;
    }
    setFromPoints(t, e) {
      const n = this.center;
      void 0 !== e ? n.copy(e) : Th.setFromPoints(t).getCenter(n);
      let i = 0;
      for (let e = 0, r = t.length; e < r; e++)
        i = Math.max(i, n.distanceToSquared(t[e]));
      return (this.radius = Math.sqrt(i)), this;
    }
    copy(t) {
      return this.center.copy(t.center), (this.radius = t.radius), this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), (this.radius = -1), this;
    }
    containsPoint(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(t) {
      return t.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(t) {
      const e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    }
    intersectsBox(t) {
      return t.intersectsSphere(this);
    }
    intersectsPlane(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(t, e) {
      const n = this.center.distanceToSquared(t);
      return (
        e.copy(t),
        n > this.radius * this.radius &&
          (e.sub(this.center).normalize(),
          e.multiplyScalar(this.radius).add(this.center)),
        e
      );
    }
    getBoundingBox(t) {
      return this.isEmpty()
        ? (t.makeEmpty(), t)
        : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
    }
    applyMatrix4(t) {
      return (
        this.center.applyMatrix4(t),
        (this.radius = this.radius * t.getMaxScaleOnAxis()),
        this
      );
    }
    translate(t) {
      return this.center.add(t), this;
    }
    expandByPoint(t) {
      if (this.isEmpty()) return this.center.copy(t), (this.radius = 0), this;
      bh.subVectors(t, this.center);
      const e = bh.lengthSq();
      if (e > this.radius * this.radius) {
        const t = Math.sqrt(e),
          n = 0.5 * (t - this.radius);
        this.center.addScaledVector(bh, n / t), (this.radius += n);
      }
      return this;
    }
    union(t) {
      return t.isEmpty()
        ? this
        : this.isEmpty()
        ? (this.copy(t), this)
        : (!0 === this.center.equals(t.center)
            ? (this.radius = Math.max(this.radius, t.radius))
            : (Dh.subVectors(t.center, this.center).setLength(t.radius),
              this.expandByPoint(bh.copy(t.center).add(Dh)),
              this.expandByPoint(bh.copy(t.center).sub(Dh))),
          this);
    }
    equals(t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Ch = new ah(),
    Ah = new ah(),
    Rh = new ah(),
    Ph = new ah(),
    Lh = new ah(),
    Ih = new ah(),
    Uh = new ah();
  class Nh {
    constructor(t = new ah(), e = new ah(0, 0, -1)) {
      (this.origin = t), (this.direction = e);
    }
    set(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    }
    copy(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    }
    at(t, e) {
      return e.copy(this.origin).addScaledVector(this.direction, t);
    }
    lookAt(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    }
    recast(t) {
      return this.origin.copy(this.at(t, Ch)), this;
    }
    closestPointToPoint(t, e) {
      e.subVectors(t, this.origin);
      const n = e.dot(this.direction);
      return n < 0
        ? e.copy(this.origin)
        : e.copy(this.origin).addScaledVector(this.direction, n);
    }
    distanceToPoint(t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    }
    distanceSqToPoint(t) {
      const e = Ch.subVectors(t, this.origin).dot(this.direction);
      return e < 0
        ? this.origin.distanceToSquared(t)
        : (Ch.copy(this.origin).addScaledVector(this.direction, e),
          Ch.distanceToSquared(t));
    }
    distanceSqToSegment(t, e, n, i) {
      Ah.copy(t).add(e).multiplyScalar(0.5),
        Rh.copy(e).sub(t).normalize(),
        Ph.copy(this.origin).sub(Ah);
      const r = 0.5 * t.distanceTo(e),
        s = -this.direction.dot(Rh),
        a = Ph.dot(this.direction),
        o = -Ph.dot(Rh),
        l = Ph.lengthSq(),
        c = Math.abs(1 - s * s);
      let u, h, d, p;
      if (c > 0)
        if (((u = s * o - a), (h = s * a - o), (p = r * c), u >= 0))
          if (h >= -p)
            if (h <= p) {
              const t = 1 / c;
              (u *= t),
                (h *= t),
                (d = u * (u + s * h + 2 * a) + h * (s * u + h + 2 * o) + l);
            } else
              (h = r),
                (u = Math.max(0, -(s * h + a))),
                (d = -u * u + h * (h + 2 * o) + l);
          else
            (h = -r),
              (u = Math.max(0, -(s * h + a))),
              (d = -u * u + h * (h + 2 * o) + l);
        else
          h <= -p
            ? ((u = Math.max(0, -(-s * r + a))),
              (h = u > 0 ? -r : Math.min(Math.max(-r, -o), r)),
              (d = -u * u + h * (h + 2 * o) + l))
            : h <= p
            ? ((u = 0),
              (h = Math.min(Math.max(-r, -o), r)),
              (d = h * (h + 2 * o) + l))
            : ((u = Math.max(0, -(s * r + a))),
              (h = u > 0 ? r : Math.min(Math.max(-r, -o), r)),
              (d = -u * u + h * (h + 2 * o) + l));
      else
        (h = s > 0 ? -r : r),
          (u = Math.max(0, -(s * h + a))),
          (d = -u * u + h * (h + 2 * o) + l);
      return (
        n && n.copy(this.origin).addScaledVector(this.direction, u),
        i && i.copy(Ah).addScaledVector(Rh, h),
        d
      );
    }
    intersectSphere(t, e) {
      Ch.subVectors(t.center, this.origin);
      const n = Ch.dot(this.direction),
        i = Ch.dot(Ch) - n * n,
        r = t.radius * t.radius;
      if (i > r) return null;
      const s = Math.sqrt(r - i),
        a = n - s,
        o = n + s;
      return o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);
    }
    intersectsSphere(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    }
    distanceToPlane(t) {
      const e = t.normal.dot(this.direction);
      if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
      const n = -(this.origin.dot(t.normal) + t.constant) / e;
      return n >= 0 ? n : null;
    }
    intersectPlane(t, e) {
      const n = this.distanceToPlane(t);
      return null === n ? null : this.at(n, e);
    }
    intersectsPlane(t) {
      const e = t.distanceToPoint(this.origin);
      return 0 === e || t.normal.dot(this.direction) * e < 0;
    }
    intersectBox(t, e) {
      let n, i, r, s, a, o;
      const l = 1 / this.direction.x,
        c = 1 / this.direction.y,
        u = 1 / this.direction.z,
        h = this.origin;
      return (
        l >= 0
          ? ((n = (t.min.x - h.x) * l), (i = (t.max.x - h.x) * l))
          : ((n = (t.max.x - h.x) * l), (i = (t.min.x - h.x) * l)),
        c >= 0
          ? ((r = (t.min.y - h.y) * c), (s = (t.max.y - h.y) * c))
          : ((r = (t.max.y - h.y) * c), (s = (t.min.y - h.y) * c)),
        n > s || r > i
          ? null
          : ((r > n || isNaN(n)) && (n = r),
            (s < i || isNaN(i)) && (i = s),
            u >= 0
              ? ((a = (t.min.z - h.z) * u), (o = (t.max.z - h.z) * u))
              : ((a = (t.max.z - h.z) * u), (o = (t.min.z - h.z) * u)),
            n > o || a > i
              ? null
              : ((a > n || n != n) && (n = a),
                (o < i || i != i) && (i = o),
                i < 0 ? null : this.at(n >= 0 ? n : i, e)))
      );
    }
    intersectsBox(t) {
      return null !== this.intersectBox(t, Ch);
    }
    intersectTriangle(t, e, n, i, r) {
      Lh.subVectors(e, t), Ih.subVectors(n, t), Uh.crossVectors(Lh, Ih);
      let s,
        a = this.direction.dot(Uh);
      if (a > 0) {
        if (i) return null;
        s = 1;
      } else {
        if (!(a < 0)) return null;
        (s = -1), (a = -a);
      }
      Ph.subVectors(this.origin, t);
      const o = s * this.direction.dot(Ih.crossVectors(Ph, Ih));
      if (o < 0) return null;
      const l = s * this.direction.dot(Lh.cross(Ph));
      if (l < 0) return null;
      if (o + l > a) return null;
      const c = -s * Ph.dot(Uh);
      return c < 0 ? null : this.at(c / a, r);
    }
    applyMatrix4(t) {
      return (
        this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
      );
    }
    equals(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Fh {
    constructor(t, e, n, i, r, s, a, o, l, c, u, h, d, p, f, m) {
      (Fh.prototype.isMatrix4 = !0),
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        void 0 !== t &&
          this.set(t, e, n, i, r, s, a, o, l, c, u, h, d, p, f, m);
    }
    set(t, e, n, i, r, s, a, o, l, c, u, h, d, p, f, m) {
      const g = this.elements;
      return (
        (g[0] = t),
        (g[4] = e),
        (g[8] = n),
        (g[12] = i),
        (g[1] = r),
        (g[5] = s),
        (g[9] = a),
        (g[13] = o),
        (g[2] = l),
        (g[6] = c),
        (g[10] = u),
        (g[14] = h),
        (g[3] = d),
        (g[7] = p),
        (g[11] = f),
        (g[15] = m),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new Fh().fromArray(this.elements);
    }
    copy(t) {
      const e = this.elements,
        n = t.elements;
      return (
        (e[0] = n[0]),
        (e[1] = n[1]),
        (e[2] = n[2]),
        (e[3] = n[3]),
        (e[4] = n[4]),
        (e[5] = n[5]),
        (e[6] = n[6]),
        (e[7] = n[7]),
        (e[8] = n[8]),
        (e[9] = n[9]),
        (e[10] = n[10]),
        (e[11] = n[11]),
        (e[12] = n[12]),
        (e[13] = n[13]),
        (e[14] = n[14]),
        (e[15] = n[15]),
        this
      );
    }
    copyPosition(t) {
      const e = this.elements,
        n = t.elements;
      return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
    }
    setFromMatrix3(t) {
      const e = t.elements;
      return (
        this.set(
          e[0],
          e[3],
          e[6],
          0,
          e[1],
          e[4],
          e[7],
          0,
          e[2],
          e[5],
          e[8],
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    extractBasis(t, e, n) {
      return (
        t.setFromMatrixColumn(this, 0),
        e.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
      );
    }
    makeBasis(t, e, n) {
      return (
        this.set(
          t.x,
          e.x,
          n.x,
          0,
          t.y,
          e.y,
          n.y,
          0,
          t.z,
          e.z,
          n.z,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    extractRotation(t) {
      const e = this.elements,
        n = t.elements,
        i = 1 / Oh.setFromMatrixColumn(t, 0).length(),
        r = 1 / Oh.setFromMatrixColumn(t, 1).length(),
        s = 1 / Oh.setFromMatrixColumn(t, 2).length();
      return (
        (e[0] = n[0] * i),
        (e[1] = n[1] * i),
        (e[2] = n[2] * i),
        (e[3] = 0),
        (e[4] = n[4] * r),
        (e[5] = n[5] * r),
        (e[6] = n[6] * r),
        (e[7] = 0),
        (e[8] = n[8] * s),
        (e[9] = n[9] * s),
        (e[10] = n[10] * s),
        (e[11] = 0),
        (e[12] = 0),
        (e[13] = 0),
        (e[14] = 0),
        (e[15] = 1),
        this
      );
    }
    makeRotationFromEuler(t) {
      const e = this.elements,
        n = t.x,
        i = t.y,
        r = t.z,
        s = Math.cos(n),
        a = Math.sin(n),
        o = Math.cos(i),
        l = Math.sin(i),
        c = Math.cos(r),
        u = Math.sin(r);
      if ("XYZ" === t.order) {
        const t = s * c,
          n = s * u,
          i = a * c,
          r = a * u;
        (e[0] = o * c),
          (e[4] = -o * u),
          (e[8] = l),
          (e[1] = n + i * l),
          (e[5] = t - r * l),
          (e[9] = -a * o),
          (e[2] = r - t * l),
          (e[6] = i + n * l),
          (e[10] = s * o);
      } else if ("YXZ" === t.order) {
        const t = o * c,
          n = o * u,
          i = l * c,
          r = l * u;
        (e[0] = t + r * a),
          (e[4] = i * a - n),
          (e[8] = s * l),
          (e[1] = s * u),
          (e[5] = s * c),
          (e[9] = -a),
          (e[2] = n * a - i),
          (e[6] = r + t * a),
          (e[10] = s * o);
      } else if ("ZXY" === t.order) {
        const t = o * c,
          n = o * u,
          i = l * c,
          r = l * u;
        (e[0] = t - r * a),
          (e[4] = -s * u),
          (e[8] = i + n * a),
          (e[1] = n + i * a),
          (e[5] = s * c),
          (e[9] = r - t * a),
          (e[2] = -s * l),
          (e[6] = a),
          (e[10] = s * o);
      } else if ("ZYX" === t.order) {
        const t = s * c,
          n = s * u,
          i = a * c,
          r = a * u;
        (e[0] = o * c),
          (e[4] = i * l - n),
          (e[8] = t * l + r),
          (e[1] = o * u),
          (e[5] = r * l + t),
          (e[9] = n * l - i),
          (e[2] = -l),
          (e[6] = a * o),
          (e[10] = s * o);
      } else if ("YZX" === t.order) {
        const t = s * o,
          n = s * l,
          i = a * o,
          r = a * l;
        (e[0] = o * c),
          (e[4] = r - t * u),
          (e[8] = i * u + n),
          (e[1] = u),
          (e[5] = s * c),
          (e[9] = -a * c),
          (e[2] = -l * c),
          (e[6] = n * u + i),
          (e[10] = t - r * u);
      } else if ("XZY" === t.order) {
        const t = s * o,
          n = s * l,
          i = a * o,
          r = a * l;
        (e[0] = o * c),
          (e[4] = -u),
          (e[8] = l * c),
          (e[1] = t * u + r),
          (e[5] = s * c),
          (e[9] = n * u - i),
          (e[2] = i * u - n),
          (e[6] = a * c),
          (e[10] = r * u + t);
      }
      return (
        (e[3] = 0),
        (e[7] = 0),
        (e[11] = 0),
        (e[12] = 0),
        (e[13] = 0),
        (e[14] = 0),
        (e[15] = 1),
        this
      );
    }
    makeRotationFromQuaternion(t) {
      return this.compose(zh, t, kh);
    }
    lookAt(t, e, n) {
      const i = this.elements;
      return (
        Gh.subVectors(t, e),
        0 === Gh.lengthSq() && (Gh.z = 1),
        Gh.normalize(),
        Vh.crossVectors(n, Gh),
        0 === Vh.lengthSq() &&
          (1 === Math.abs(n.z) ? (Gh.x += 1e-4) : (Gh.z += 1e-4),
          Gh.normalize(),
          Vh.crossVectors(n, Gh)),
        Vh.normalize(),
        Hh.crossVectors(Gh, Vh),
        (i[0] = Vh.x),
        (i[4] = Hh.x),
        (i[8] = Gh.x),
        (i[1] = Vh.y),
        (i[5] = Hh.y),
        (i[9] = Gh.y),
        (i[2] = Vh.z),
        (i[6] = Hh.z),
        (i[10] = Gh.z),
        this
      );
    }
    multiply(t) {
      return this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      const n = t.elements,
        i = e.elements,
        r = this.elements,
        s = n[0],
        a = n[4],
        o = n[8],
        l = n[12],
        c = n[1],
        u = n[5],
        h = n[9],
        d = n[13],
        p = n[2],
        f = n[6],
        m = n[10],
        g = n[14],
        v = n[3],
        _ = n[7],
        x = n[11],
        y = n[15],
        S = i[0],
        M = i[4],
        E = i[8],
        T = i[12],
        b = i[1],
        D = i[5],
        w = i[9],
        C = i[13],
        A = i[2],
        R = i[6],
        P = i[10],
        L = i[14],
        I = i[3],
        U = i[7],
        N = i[11],
        F = i[15];
      return (
        (r[0] = s * S + a * b + o * A + l * I),
        (r[4] = s * M + a * D + o * R + l * U),
        (r[8] = s * E + a * w + o * P + l * N),
        (r[12] = s * T + a * C + o * L + l * F),
        (r[1] = c * S + u * b + h * A + d * I),
        (r[5] = c * M + u * D + h * R + d * U),
        (r[9] = c * E + u * w + h * P + d * N),
        (r[13] = c * T + u * C + h * L + d * F),
        (r[2] = p * S + f * b + m * A + g * I),
        (r[6] = p * M + f * D + m * R + g * U),
        (r[10] = p * E + f * w + m * P + g * N),
        (r[14] = p * T + f * C + m * L + g * F),
        (r[3] = v * S + _ * b + x * A + y * I),
        (r[7] = v * M + _ * D + x * R + y * U),
        (r[11] = v * E + _ * w + x * P + y * N),
        (r[15] = v * T + _ * C + x * L + y * F),
        this
      );
    }
    multiplyScalar(t) {
      const e = this.elements;
      return (
        (e[0] *= t),
        (e[4] *= t),
        (e[8] *= t),
        (e[12] *= t),
        (e[1] *= t),
        (e[5] *= t),
        (e[9] *= t),
        (e[13] *= t),
        (e[2] *= t),
        (e[6] *= t),
        (e[10] *= t),
        (e[14] *= t),
        (e[3] *= t),
        (e[7] *= t),
        (e[11] *= t),
        (e[15] *= t),
        this
      );
    }
    determinant() {
      const t = this.elements,
        e = t[0],
        n = t[4],
        i = t[8],
        r = t[12],
        s = t[1],
        a = t[5],
        o = t[9],
        l = t[13],
        c = t[2],
        u = t[6],
        h = t[10],
        d = t[14];
      return (
        t[3] *
          (+r * o * u -
            i * l * u -
            r * a * h +
            n * l * h +
            i * a * d -
            n * o * d) +
        t[7] *
          (+e * o * d -
            e * l * h +
            r * s * h -
            i * s * d +
            i * l * c -
            r * o * c) +
        t[11] *
          (+e * l * u -
            e * a * d -
            r * s * u +
            n * s * d +
            r * a * c -
            n * l * c) +
        t[15] *
          (-i * a * c -
            e * o * u +
            e * a * h +
            i * s * u -
            n * s * h +
            n * o * c)
      );
    }
    transpose() {
      const t = this.elements;
      let e;
      return (
        (e = t[1]),
        (t[1] = t[4]),
        (t[4] = e),
        (e = t[2]),
        (t[2] = t[8]),
        (t[8] = e),
        (e = t[6]),
        (t[6] = t[9]),
        (t[9] = e),
        (e = t[3]),
        (t[3] = t[12]),
        (t[12] = e),
        (e = t[7]),
        (t[7] = t[13]),
        (t[13] = e),
        (e = t[11]),
        (t[11] = t[14]),
        (t[14] = e),
        this
      );
    }
    setPosition(t, e, n) {
      const i = this.elements;
      return (
        t.isVector3
          ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
          : ((i[12] = t), (i[13] = e), (i[14] = n)),
        this
      );
    }
    invert() {
      const t = this.elements,
        e = t[0],
        n = t[1],
        i = t[2],
        r = t[3],
        s = t[4],
        a = t[5],
        o = t[6],
        l = t[7],
        c = t[8],
        u = t[9],
        h = t[10],
        d = t[11],
        p = t[12],
        f = t[13],
        m = t[14],
        g = t[15],
        v =
          u * m * l - f * h * l + f * o * d - a * m * d - u * o * g + a * h * g,
        _ =
          p * h * l - c * m * l - p * o * d + s * m * d + c * o * g - s * h * g,
        x =
          c * f * l - p * u * l + p * a * d - s * f * d - c * a * g + s * u * g,
        y =
          p * u * o - c * f * o - p * a * h + s * f * h + c * a * m - s * u * m,
        S = e * v + n * _ + i * x + r * y;
      if (0 === S)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const M = 1 / S;
      return (
        (t[0] = v * M),
        (t[1] =
          (f * h * r -
            u * m * r -
            f * i * d +
            n * m * d +
            u * i * g -
            n * h * g) *
          M),
        (t[2] =
          (a * m * r -
            f * o * r +
            f * i * l -
            n * m * l -
            a * i * g +
            n * o * g) *
          M),
        (t[3] =
          (u * o * r -
            a * h * r -
            u * i * l +
            n * h * l +
            a * i * d -
            n * o * d) *
          M),
        (t[4] = _ * M),
        (t[5] =
          (c * m * r -
            p * h * r +
            p * i * d -
            e * m * d -
            c * i * g +
            e * h * g) *
          M),
        (t[6] =
          (p * o * r -
            s * m * r -
            p * i * l +
            e * m * l +
            s * i * g -
            e * o * g) *
          M),
        (t[7] =
          (s * h * r -
            c * o * r +
            c * i * l -
            e * h * l -
            s * i * d +
            e * o * d) *
          M),
        (t[8] = x * M),
        (t[9] =
          (p * u * r -
            c * f * r -
            p * n * d +
            e * f * d +
            c * n * g -
            e * u * g) *
          M),
        (t[10] =
          (s * f * r -
            p * a * r +
            p * n * l -
            e * f * l -
            s * n * g +
            e * a * g) *
          M),
        (t[11] =
          (c * a * r -
            s * u * r -
            c * n * l +
            e * u * l +
            s * n * d -
            e * a * d) *
          M),
        (t[12] = y * M),
        (t[13] =
          (c * f * i -
            p * u * i +
            p * n * h -
            e * f * h -
            c * n * m +
            e * u * m) *
          M),
        (t[14] =
          (p * a * i -
            s * f * i -
            p * n * o +
            e * f * o +
            s * n * m -
            e * a * m) *
          M),
        (t[15] =
          (s * u * i -
            c * a * i +
            c * n * o -
            e * u * o -
            s * n * h +
            e * a * h) *
          M),
        this
      );
    }
    scale(t) {
      const e = this.elements,
        n = t.x,
        i = t.y,
        r = t.z;
      return (
        (e[0] *= n),
        (e[4] *= i),
        (e[8] *= r),
        (e[1] *= n),
        (e[5] *= i),
        (e[9] *= r),
        (e[2] *= n),
        (e[6] *= i),
        (e[10] *= r),
        (e[3] *= n),
        (e[7] *= i),
        (e[11] *= r),
        this
      );
    }
    getMaxScaleOnAxis() {
      const t = this.elements,
        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
      return Math.sqrt(Math.max(e, n, i));
    }
    makeTranslation(t, e, n) {
      return (
        t.isVector3
          ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
          : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
        this
      );
    }
    makeRotationX(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(t) {
      const e = Math.cos(t),
        n = Math.sin(t);
      return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(t, e) {
      const n = Math.cos(e),
        i = Math.sin(e),
        r = 1 - n,
        s = t.x,
        a = t.y,
        o = t.z,
        l = r * s,
        c = r * a;
      return (
        this.set(
          l * s + n,
          l * a - i * o,
          l * o + i * a,
          0,
          l * a + i * o,
          c * a + n,
          c * o - i * s,
          0,
          l * o - i * a,
          c * o + i * s,
          r * o * o + n,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    makeScale(t, e, n) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }
    makeShear(t, e, n, i, r, s) {
      return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this;
    }
    compose(t, e, n) {
      const i = this.elements,
        r = e._x,
        s = e._y,
        a = e._z,
        o = e._w,
        l = r + r,
        c = s + s,
        u = a + a,
        h = r * l,
        d = r * c,
        p = r * u,
        f = s * c,
        m = s * u,
        g = a * u,
        v = o * l,
        _ = o * c,
        x = o * u,
        y = n.x,
        S = n.y,
        M = n.z;
      return (
        (i[0] = (1 - (f + g)) * y),
        (i[1] = (d + x) * y),
        (i[2] = (p - _) * y),
        (i[3] = 0),
        (i[4] = (d - x) * S),
        (i[5] = (1 - (h + g)) * S),
        (i[6] = (m + v) * S),
        (i[7] = 0),
        (i[8] = (p + _) * M),
        (i[9] = (m - v) * M),
        (i[10] = (1 - (h + f)) * M),
        (i[11] = 0),
        (i[12] = t.x),
        (i[13] = t.y),
        (i[14] = t.z),
        (i[15] = 1),
        this
      );
    }
    decompose(t, e, n) {
      const i = this.elements;
      let r = Oh.set(i[0], i[1], i[2]).length();
      const s = Oh.set(i[4], i[5], i[6]).length(),
        a = Oh.set(i[8], i[9], i[10]).length();
      this.determinant() < 0 && (r = -r),
        (t.x = i[12]),
        (t.y = i[13]),
        (t.z = i[14]),
        Bh.copy(this);
      const o = 1 / r,
        l = 1 / s,
        c = 1 / a;
      return (
        (Bh.elements[0] *= o),
        (Bh.elements[1] *= o),
        (Bh.elements[2] *= o),
        (Bh.elements[4] *= l),
        (Bh.elements[5] *= l),
        (Bh.elements[6] *= l),
        (Bh.elements[8] *= c),
        (Bh.elements[9] *= c),
        (Bh.elements[10] *= c),
        e.setFromRotationMatrix(Bh),
        (n.x = r),
        (n.y = s),
        (n.z = a),
        this
      );
    }
    makePerspective(t, e, n, i, r, s, a = 2e3) {
      const o = this.elements,
        l = (2 * r) / (e - t),
        c = (2 * r) / (n - i),
        u = (e + t) / (e - t),
        h = (n + i) / (n - i);
      let d, p;
      if (a === Mu) (d = -(s + r) / (s - r)), (p = (-2 * s * r) / (s - r));
      else {
        if (a !== Eu)
          throw new Error(
            "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
          );
        (d = -s / (s - r)), (p = (-s * r) / (s - r));
      }
      return (
        (o[0] = l),
        (o[4] = 0),
        (o[8] = u),
        (o[12] = 0),
        (o[1] = 0),
        (o[5] = c),
        (o[9] = h),
        (o[13] = 0),
        (o[2] = 0),
        (o[6] = 0),
        (o[10] = d),
        (o[14] = p),
        (o[3] = 0),
        (o[7] = 0),
        (o[11] = -1),
        (o[15] = 0),
        this
      );
    }
    makeOrthographic(t, e, n, i, r, s, a = 2e3) {
      const o = this.elements,
        l = 1 / (e - t),
        c = 1 / (n - i),
        u = 1 / (s - r),
        h = (e + t) * l,
        d = (n + i) * c;
      let p, f;
      if (a === Mu) (p = (s + r) * u), (f = -2 * u);
      else {
        if (a !== Eu)
          throw new Error(
            "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
          );
        (p = r * u), (f = -1 * u);
      }
      return (
        (o[0] = 2 * l),
        (o[4] = 0),
        (o[8] = 0),
        (o[12] = -h),
        (o[1] = 0),
        (o[5] = 2 * c),
        (o[9] = 0),
        (o[13] = -d),
        (o[2] = 0),
        (o[6] = 0),
        (o[10] = f),
        (o[14] = -p),
        (o[3] = 0),
        (o[7] = 0),
        (o[11] = 0),
        (o[15] = 1),
        this
      );
    }
    equals(t) {
      const e = this.elements,
        n = t.elements;
      for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
      return !0;
    }
    fromArray(t, e = 0) {
      for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
      return this;
    }
    toArray(t = [], e = 0) {
      const n = this.elements;
      return (
        (t[e] = n[0]),
        (t[e + 1] = n[1]),
        (t[e + 2] = n[2]),
        (t[e + 3] = n[3]),
        (t[e + 4] = n[4]),
        (t[e + 5] = n[5]),
        (t[e + 6] = n[6]),
        (t[e + 7] = n[7]),
        (t[e + 8] = n[8]),
        (t[e + 9] = n[9]),
        (t[e + 10] = n[10]),
        (t[e + 11] = n[11]),
        (t[e + 12] = n[12]),
        (t[e + 13] = n[13]),
        (t[e + 14] = n[14]),
        (t[e + 15] = n[15]),
        t
      );
    }
  }
  const Oh = new ah(),
    Bh = new Fh(),
    zh = new ah(0, 0, 0),
    kh = new ah(1, 1, 1),
    Vh = new ah(),
    Hh = new ah(),
    Gh = new ah(),
    Wh = new Fh(),
    Xh = new sh();
  class qh {
    constructor(t = 0, e = 0, n = 0, i = qh.DEFAULT_ORDER) {
      (this.isEuler = !0),
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._order = i);
    }
    get x() {
      return this._x;
    }
    set x(t) {
      (this._x = t), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      (this._y = t), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      (this._z = t), this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(t) {
      (this._order = t), this._onChangeCallback();
    }
    set(t, e, n, i = this._order) {
      return (
        (this._x = t),
        (this._y = e),
        (this._z = n),
        (this._order = i),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(t) {
      return (
        (this._x = t._x),
        (this._y = t._y),
        (this._z = t._z),
        (this._order = t._order),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(t, e = this._order, n = !0) {
      const i = t.elements,
        r = i[0],
        s = i[4],
        a = i[8],
        o = i[1],
        l = i[5],
        c = i[9],
        u = i[2],
        h = i[6],
        d = i[10];
      switch (e) {
        case "XYZ":
          (this._y = Math.asin(Au(a, -1, 1))),
            Math.abs(a) < 0.9999999
              ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-s, r)))
              : ((this._x = Math.atan2(h, l)), (this._z = 0));
          break;
        case "YXZ":
          (this._x = Math.asin(-Au(c, -1, 1))),
            Math.abs(c) < 0.9999999
              ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
              : ((this._y = Math.atan2(-u, r)), (this._z = 0));
          break;
        case "ZXY":
          (this._x = Math.asin(Au(h, -1, 1))),
            Math.abs(h) < 0.9999999
              ? ((this._y = Math.atan2(-u, d)), (this._z = Math.atan2(-s, l)))
              : ((this._y = 0), (this._z = Math.atan2(o, r)));
          break;
        case "ZYX":
          (this._y = Math.asin(-Au(u, -1, 1))),
            Math.abs(u) < 0.9999999
              ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(o, r)))
              : ((this._x = 0), (this._z = Math.atan2(-s, l)));
          break;
        case "YZX":
          (this._z = Math.asin(Au(o, -1, 1))),
            Math.abs(o) < 0.9999999
              ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-u, r)))
              : ((this._x = 0), (this._y = Math.atan2(a, d)));
          break;
        case "XZY":
          (this._z = Math.asin(-Au(s, -1, 1))),
            Math.abs(s) < 0.9999999
              ? ((this._x = Math.atan2(h, l)), (this._y = Math.atan2(a, r)))
              : ((this._x = Math.atan2(-c, d)), (this._y = 0));
          break;
        default:
          console.warn(
            "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
              e
          );
      }
      return (this._order = e), !0 === n && this._onChangeCallback(), this;
    }
    setFromQuaternion(t, e, n) {
      return (
        Wh.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Wh, e, n)
      );
    }
    setFromVector3(t, e = this._order) {
      return this.set(t.x, t.y, t.z, e);
    }
    reorder(t) {
      return Xh.setFromEuler(this), this.setFromQuaternion(Xh, t);
    }
    equals(t) {
      return (
        t._x === this._x &&
        t._y === this._y &&
        t._z === this._z &&
        t._order === this._order
      );
    }
    fromArray(t) {
      return (
        (this._x = t[0]),
        (this._y = t[1]),
        (this._z = t[2]),
        void 0 !== t[3] && (this._order = t[3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(t = [], e = 0) {
      return (
        (t[e] = this._x),
        (t[e + 1] = this._y),
        (t[e + 2] = this._z),
        (t[e + 3] = this._order),
        t
      );
    }
    _onChange(t) {
      return (this._onChangeCallback = t), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order;
    }
  }
  qh.DEFAULT_ORDER = "XYZ";
  class jh {
    constructor() {
      this.mask = 1;
    }
    set(t) {
      this.mask = (1 << t) >>> 0;
    }
    enable(t) {
      this.mask |= 1 << t;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(t) {
      this.mask ^= 1 << t;
    }
    disable(t) {
      this.mask &= ~(1 << t);
    }
    disableAll() {
      this.mask = 0;
    }
    test(t) {
      return !!(this.mask & t.mask);
    }
    isEnabled(t) {
      return !!(this.mask & (1 << t));
    }
  }
  let Yh = 0;
  const Kh = new ah(),
    Zh = new sh(),
    Jh = new Fh(),
    $h = new ah(),
    Qh = new ah(),
    td = new ah(),
    ed = new sh(),
    nd = new ah(1, 0, 0),
    id = new ah(0, 1, 0),
    rd = new ah(0, 0, 1),
    sd = { type: "added" },
    ad = { type: "removed" },
    od = { type: "childadded", child: null },
    ld = { type: "childremoved", child: null };
  class cd extends Tu {
    constructor() {
      super(),
        (this.isObject3D = !0),
        Object.defineProperty(this, "id", { value: Yh++ }),
        (this.uuid = Cu()),
        (this.name = ""),
        (this.type = "Object3D"),
        (this.parent = null),
        (this.children = []),
        (this.up = cd.DEFAULT_UP.clone());
      const t = new ah(),
        e = new qh(),
        n = new sh(),
        i = new ah(1, 1, 1);
      e._onChange(function () {
        n.setFromEuler(e, !1);
      }),
        n._onChange(function () {
          e.setFromQuaternion(n, void 0, !1);
        }),
        Object.defineProperties(this, {
          position: { configurable: !0, enumerable: !0, value: t },
          rotation: { configurable: !0, enumerable: !0, value: e },
          quaternion: { configurable: !0, enumerable: !0, value: n },
          scale: { configurable: !0, enumerable: !0, value: i },
          modelViewMatrix: { value: new Fh() },
          normalMatrix: { value: new Uu() },
        }),
        (this.matrix = new Fh()),
        (this.matrixWorld = new Fh()),
        (this.matrixAutoUpdate = cd.DEFAULT_MATRIX_AUTO_UPDATE),
        (this.matrixWorldAutoUpdate = cd.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
        (this.matrixWorldNeedsUpdate = !1),
        (this.layers = new jh()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.animations = []),
        (this.userData = {});
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(t),
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(t) {
      return this.quaternion.premultiply(t), this;
    }
    setRotationFromAxisAngle(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    }
    setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, !0);
    }
    setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t);
    }
    setRotationFromQuaternion(t) {
      this.quaternion.copy(t);
    }
    rotateOnAxis(t, e) {
      return Zh.setFromAxisAngle(t, e), this.quaternion.multiply(Zh), this;
    }
    rotateOnWorldAxis(t, e) {
      return Zh.setFromAxisAngle(t, e), this.quaternion.premultiply(Zh), this;
    }
    rotateX(t) {
      return this.rotateOnAxis(nd, t);
    }
    rotateY(t) {
      return this.rotateOnAxis(id, t);
    }
    rotateZ(t) {
      return this.rotateOnAxis(rd, t);
    }
    translateOnAxis(t, e) {
      return (
        Kh.copy(t).applyQuaternion(this.quaternion),
        this.position.add(Kh.multiplyScalar(e)),
        this
      );
    }
    translateX(t) {
      return this.translateOnAxis(nd, t);
    }
    translateY(t) {
      return this.translateOnAxis(id, t);
    }
    translateZ(t) {
      return this.translateOnAxis(rd, t);
    }
    localToWorld(t) {
      return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        t.applyMatrix4(Jh.copy(this.matrixWorld).invert())
      );
    }
    lookAt(t, e, n) {
      t.isVector3 ? $h.copy(t) : $h.set(t, e, n);
      const i = this.parent;
      this.updateWorldMatrix(!0, !1),
        Qh.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight
          ? Jh.lookAt(Qh, $h, this.up)
          : Jh.lookAt($h, Qh, this.up),
        this.quaternion.setFromRotationMatrix(Jh),
        i &&
          (Jh.extractRotation(i.matrixWorld),
          Zh.setFromRotationMatrix(Jh),
          this.quaternion.premultiply(Zh.invert()));
    }
    add(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
        return this;
      }
      return t === this
        ? (console.error(
            "THREE.Object3D.add: object can't be added as a child of itself.",
            t
          ),
          this)
        : (t && t.isObject3D
            ? (t.removeFromParent(),
              (t.parent = this),
              this.children.push(t),
              t.dispatchEvent(sd),
              (od.child = t),
              this.dispatchEvent(od),
              (od.child = null))
            : console.error(
                "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                t
              ),
          this);
    }
    remove(t) {
      if (arguments.length > 1) {
        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
        return this;
      }
      const e = this.children.indexOf(t);
      return (
        -1 !== e &&
          ((t.parent = null),
          this.children.splice(e, 1),
          t.dispatchEvent(ad),
          (ld.child = t),
          this.dispatchEvent(ld),
          (ld.child = null)),
        this
      );
    }
    removeFromParent() {
      const t = this.parent;
      return null !== t && t.remove(this), this;
    }
    clear() {
      return this.remove(...this.children);
    }
    attach(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        Jh.copy(this.matrixWorld).invert(),
        null !== t.parent &&
          (t.parent.updateWorldMatrix(!0, !1),
          Jh.multiply(t.parent.matrixWorld)),
        t.applyMatrix4(Jh),
        t.removeFromParent(),
        (t.parent = this),
        this.children.push(t),
        t.updateWorldMatrix(!1, !0),
        t.dispatchEvent(sd),
        (od.child = t),
        this.dispatchEvent(od),
        (od.child = null),
        this
      );
    }
    getObjectById(t) {
      return this.getObjectByProperty("id", t);
    }
    getObjectByName(t) {
      return this.getObjectByProperty("name", t);
    }
    getObjectByProperty(t, e) {
      if (this[t] === e) return this;
      for (let n = 0, i = this.children.length; n < i; n++) {
        const i = this.children[n].getObjectByProperty(t, e);
        if (void 0 !== i) return i;
      }
    }
    getObjectsByProperty(t, e, n = []) {
      this[t] === e && n.push(this);
      const i = this.children;
      for (let r = 0, s = i.length; r < s; r++)
        i[r].getObjectsByProperty(t, e, n);
      return n;
    }
    getWorldPosition(t) {
      return (
        this.updateWorldMatrix(!0, !1),
        t.setFromMatrixPosition(this.matrixWorld)
      );
    }
    getWorldQuaternion(t) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Qh, t, td), t
      );
    }
    getWorldScale(t) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Qh, ed, t), t
      );
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(!0, !1);
      const e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {}
    traverse(t) {
      t(this);
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
    }
    traverseVisible(t) {
      if (!1 === this.visible) return;
      t(this);
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
    }
    traverseAncestors(t) {
      const e = this.parent;
      null !== e && (t(e), e.traverseAncestors(t));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale),
        (this.matrixWorldNeedsUpdate = !0);
    }
    updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || t) &&
          (null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          (this.matrixWorldNeedsUpdate = !1),
          (t = !0));
      const e = this.children;
      for (let n = 0, i = e.length; n < i; n++) {
        const i = e[n];
        (!0 !== i.matrixWorldAutoUpdate && !0 !== t) || i.updateMatrixWorld(t);
      }
    }
    updateWorldMatrix(t, e) {
      const n = this.parent;
      if (
        (!0 === t &&
          null !== n &&
          !0 === n.matrixWorldAutoUpdate &&
          n.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        !0 === e)
      ) {
        const t = this.children;
        for (let e = 0, n = t.length; e < n; e++) {
          const n = t[e];
          !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0);
        }
      }
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t,
        n = {};
      e &&
        ((t = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {},
        }),
        (n.metadata = {
          version: 4.6,
          type: "Object",
          generator: "Object3D.toJSON",
        }));
      const i = {};
      function r(e, n) {
        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
      }
      if (
        ((i.uuid = this.uuid),
        (i.type = this.type),
        "" !== this.name && (i.name = this.name),
        !0 === this.castShadow && (i.castShadow = !0),
        !0 === this.receiveShadow && (i.receiveShadow = !0),
        !1 === this.visible && (i.visible = !1),
        !1 === this.frustumCulled && (i.frustumCulled = !1),
        0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        (i.layers = this.layers.mask),
        (i.matrix = this.matrix.toArray()),
        (i.up = this.up.toArray()),
        !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh &&
          ((i.type = "InstancedMesh"),
          (i.count = this.count),
          (i.instanceMatrix = this.instanceMatrix.toJSON()),
          null !== this.instanceColor &&
            (i.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh &&
          ((i.type = "BatchedMesh"),
          (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
          (i.sortObjects = this.sortObjects),
          (i.drawRanges = this._drawRanges),
          (i.reservedRanges = this._reservedRanges),
          (i.visibility = this._visibility),
          (i.active = this._active),
          (i.bounds = this._bounds.map((t) => ({
            boxInitialized: t.boxInitialized,
            boxMin: t.box.min.toArray(),
            boxMax: t.box.max.toArray(),
            sphereInitialized: t.sphereInitialized,
            sphereRadius: t.sphere.radius,
            sphereCenter: t.sphere.center.toArray(),
          }))),
          (i.maxGeometryCount = this._maxGeometryCount),
          (i.maxVertexCount = this._maxVertexCount),
          (i.maxIndexCount = this._maxIndexCount),
          (i.geometryInitialized = this._geometryInitialized),
          (i.geometryCount = this._geometryCount),
          (i.matricesTexture = this._matricesTexture.toJSON(t)),
          null !== this.boundingSphere &&
            (i.boundingSphere = {
              center: i.boundingSphere.center.toArray(),
              radius: i.boundingSphere.radius,
            }),
          null !== this.boundingBox &&
            (i.boundingBox = {
              min: i.boundingBox.min.toArray(),
              max: i.boundingBox.max.toArray(),
            })),
        this.isScene)
      )
        this.background &&
          (this.background.isColor
            ? (i.background = this.background.toJSON())
            : this.background.isTexture &&
              (i.background = this.background.toJSON(t).uuid)),
          this.environment &&
            this.environment.isTexture &&
            !0 !== this.environment.isRenderTargetTexture &&
            (i.environment = this.environment.toJSON(t).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        i.geometry = r(t.geometries, this.geometry);
        const e = this.geometry.parameters;
        if (void 0 !== e && void 0 !== e.shapes) {
          const n = e.shapes;
          if (Array.isArray(n))
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              r(t.shapes, i);
            }
          else r(t.shapes, n);
        }
      }
      if (
        (this.isSkinnedMesh &&
          ((i.bindMode = this.bindMode),
          (i.bindMatrix = this.bindMatrix.toArray()),
          void 0 !== this.skeleton &&
            (r(t.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
        void 0 !== this.material)
      )
        if (Array.isArray(this.material)) {
          const e = [];
          for (let n = 0, i = this.material.length; n < i; n++)
            e.push(r(t.materials, this.material[n]));
          i.material = e;
        } else i.material = r(t.materials, this.material);
      if (this.children.length > 0) {
        i.children = [];
        for (let e = 0; e < this.children.length; e++)
          i.children.push(this.children[e].toJSON(t).object);
      }
      if (this.animations.length > 0) {
        i.animations = [];
        for (let e = 0; e < this.animations.length; e++) {
          const n = this.animations[e];
          i.animations.push(r(t.animations, n));
        }
      }
      if (e) {
        const e = s(t.geometries),
          i = s(t.materials),
          r = s(t.textures),
          a = s(t.images),
          o = s(t.shapes),
          l = s(t.skeletons),
          c = s(t.animations),
          u = s(t.nodes);
        e.length > 0 && (n.geometries = e),
          i.length > 0 && (n.materials = i),
          r.length > 0 && (n.textures = r),
          a.length > 0 && (n.images = a),
          o.length > 0 && (n.shapes = o),
          l.length > 0 && (n.skeletons = l),
          c.length > 0 && (n.animations = c),
          u.length > 0 && (n.nodes = u);
      }
      return (n.object = i), n;
      function s(t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          delete i.metadata, e.push(i);
        }
        return e;
      }
    }
    clone(t) {
      return new this.constructor().copy(this, t);
    }
    copy(t, e = !0) {
      if (
        ((this.name = t.name),
        this.up.copy(t.up),
        this.position.copy(t.position),
        (this.rotation.order = t.rotation.order),
        this.quaternion.copy(t.quaternion),
        this.scale.copy(t.scale),
        this.matrix.copy(t.matrix),
        this.matrixWorld.copy(t.matrixWorld),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
        (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
        (this.layers.mask = t.layers.mask),
        (this.visible = t.visible),
        (this.castShadow = t.castShadow),
        (this.receiveShadow = t.receiveShadow),
        (this.frustumCulled = t.frustumCulled),
        (this.renderOrder = t.renderOrder),
        (this.animations = t.animations.slice()),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        !0 === e)
      )
        for (let e = 0; e < t.children.length; e++) {
          const n = t.children[e];
          this.add(n.clone());
        }
      return this;
    }
  }
  (cd.DEFAULT_UP = new ah(0, 1, 0)),
    (cd.DEFAULT_MATRIX_AUTO_UPDATE = !0),
    (cd.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
  const ud = new ah(),
    hd = new ah(),
    dd = new ah(),
    pd = new ah(),
    fd = new ah(),
    md = new ah(),
    gd = new ah(),
    vd = new ah(),
    _d = new ah(),
    xd = new ah();
  class yd {
    constructor(t = new ah(), e = new ah(), n = new ah()) {
      (this.a = t), (this.b = e), (this.c = n);
    }
    static getNormal(t, e, n, i) {
      i.subVectors(n, e), ud.subVectors(t, e), i.cross(ud);
      const r = i.lengthSq();
      return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
    }
    static getBarycoord(t, e, n, i, r) {
      ud.subVectors(i, e), hd.subVectors(n, e), dd.subVectors(t, e);
      const s = ud.dot(ud),
        a = ud.dot(hd),
        o = ud.dot(dd),
        l = hd.dot(hd),
        c = hd.dot(dd),
        u = s * l - a * a;
      if (0 === u) return r.set(0, 0, 0), null;
      const h = 1 / u,
        d = (l * o - a * c) * h,
        p = (s * c - a * o) * h;
      return r.set(1 - d - p, p, d);
    }
    static containsPoint(t, e, n, i) {
      return (
        null !== this.getBarycoord(t, e, n, i, pd) &&
        pd.x >= 0 &&
        pd.y >= 0 &&
        pd.x + pd.y <= 1
      );
    }
    static getInterpolation(t, e, n, i, r, s, a, o) {
      return null === this.getBarycoord(t, e, n, i, pd)
        ? ((o.x = 0),
          (o.y = 0),
          "z" in o && (o.z = 0),
          "w" in o && (o.w = 0),
          null)
        : (o.setScalar(0),
          o.addScaledVector(r, pd.x),
          o.addScaledVector(s, pd.y),
          o.addScaledVector(a, pd.z),
          o);
    }
    static isFrontFacing(t, e, n, i) {
      return ud.subVectors(n, e), hd.subVectors(t, e), ud.cross(hd).dot(i) < 0;
    }
    set(t, e, n) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
    }
    setFromPointsAndIndices(t, e, n, i) {
      return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
    }
    setFromAttributeAndIndices(t, e, n, i) {
      return (
        this.a.fromBufferAttribute(t, e),
        this.b.fromBufferAttribute(t, n),
        this.c.fromBufferAttribute(t, i),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    }
    getArea() {
      return (
        ud.subVectors(this.c, this.b),
        hd.subVectors(this.a, this.b),
        0.5 * ud.cross(hd).length()
      );
    }
    getMidpoint(t) {
      return t
        .addVectors(this.a, this.b)
        .add(this.c)
        .multiplyScalar(1 / 3);
    }
    getNormal(t) {
      return yd.getNormal(this.a, this.b, this.c, t);
    }
    getPlane(t) {
      return t.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(t, e) {
      return yd.getBarycoord(t, this.a, this.b, this.c, e);
    }
    getInterpolation(t, e, n, i, r) {
      return yd.getInterpolation(t, this.a, this.b, this.c, e, n, i, r);
    }
    containsPoint(t) {
      return yd.containsPoint(t, this.a, this.b, this.c);
    }
    isFrontFacing(t) {
      return yd.isFrontFacing(this.a, this.b, this.c, t);
    }
    intersectsBox(t) {
      return t.intersectsTriangle(this);
    }
    closestPointToPoint(t, e) {
      const n = this.a,
        i = this.b,
        r = this.c;
      let s, a;
      fd.subVectors(i, n), md.subVectors(r, n), vd.subVectors(t, n);
      const o = fd.dot(vd),
        l = md.dot(vd);
      if (o <= 0 && l <= 0) return e.copy(n);
      _d.subVectors(t, i);
      const c = fd.dot(_d),
        u = md.dot(_d);
      if (c >= 0 && u <= c) return e.copy(i);
      const h = o * u - c * l;
      if (h <= 0 && o >= 0 && c <= 0)
        return (s = o / (o - c)), e.copy(n).addScaledVector(fd, s);
      xd.subVectors(t, r);
      const d = fd.dot(xd),
        p = md.dot(xd);
      if (p >= 0 && d <= p) return e.copy(r);
      const f = d * l - o * p;
      if (f <= 0 && l >= 0 && p <= 0)
        return (a = l / (l - p)), e.copy(n).addScaledVector(md, a);
      const m = c * p - d * u;
      if (m <= 0 && u - c >= 0 && d - p >= 0)
        return (
          gd.subVectors(r, i),
          (a = (u - c) / (u - c + (d - p))),
          e.copy(i).addScaledVector(gd, a)
        );
      const g = 1 / (m + f + h);
      return (
        (s = f * g),
        (a = h * g),
        e.copy(n).addScaledVector(fd, s).addScaledVector(md, a)
      );
    }
    equals(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
  }
  const Sd = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    },
    Md = { h: 0, s: 0, l: 0 },
    Ed = { h: 0, s: 0, l: 0 };
  function Td(t, e, n) {
    return (
      n < 0 && (n += 1),
      n > 1 && (n -= 1),
      n < 1 / 6
        ? t + 6 * (e - t) * n
        : n < 0.5
        ? e
        : n < 2 / 3
        ? t + 6 * (e - t) * (2 / 3 - n)
        : t
    );
  }
  class bd {
    constructor(t, e, n) {
      return (
        (this.isColor = !0),
        (this.r = 1),
        (this.g = 1),
        (this.b = 1),
        this.set(t, e, n)
      );
    }
    set(t, e, n) {
      if (void 0 === e && void 0 === n) {
        const e = t;
        e && e.isColor
          ? this.copy(e)
          : "number" == typeof e
          ? this.setHex(e)
          : "string" == typeof e && this.setStyle(e);
      } else this.setRGB(t, e, n);
      return this;
    }
    setScalar(t) {
      return (this.r = t), (this.g = t), (this.b = t), this;
    }
    setHex(t, e = ru) {
      return (
        (t = Math.floor(t)),
        (this.r = ((t >> 16) & 255) / 255),
        (this.g = ((t >> 8) & 255) / 255),
        (this.b = (255 & t) / 255),
        Wu.toWorkingColorSpace(this, e),
        this
      );
    }
    setRGB(t, e, n, i = Wu.workingColorSpace) {
      return (
        (this.r = t),
        (this.g = e),
        (this.b = n),
        Wu.toWorkingColorSpace(this, i),
        this
      );
    }
    setHSL(t, e, n, i = Wu.workingColorSpace) {
      if (
        ((t = (function (t, e) {
          return ((t % e) + e) % e;
        })(t, 1)),
        (e = Au(e, 0, 1)),
        (n = Au(n, 0, 1)),
        0 === e)
      )
        this.r = this.g = this.b = n;
      else {
        const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
          r = 2 * n - i;
        (this.r = Td(r, i, t + 1 / 3)),
          (this.g = Td(r, i, t)),
          (this.b = Td(r, i, t - 1 / 3));
      }
      return Wu.toWorkingColorSpace(this, i), this;
    }
    setStyle(t, e = ru) {
      function n(e) {
        void 0 !== e &&
          parseFloat(e) < 1 &&
          console.warn(
            "THREE.Color: Alpha component of " + t + " will be ignored."
          );
      }
      let i;
      if ((i = /^(\w+)\(([^\)]*)\)/.exec(t))) {
        let r;
        const s = i[1],
          a = i[2];
        switch (s) {
          case "rgb":
          case "rgba":
            if (
              (r =
                /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  a
                ))
            )
              return (
                n(r[4]),
                this.setRGB(
                  Math.min(255, parseInt(r[1], 10)) / 255,
                  Math.min(255, parseInt(r[2], 10)) / 255,
                  Math.min(255, parseInt(r[3], 10)) / 255,
                  e
                )
              );
            if (
              (r =
                /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  a
                ))
            )
              return (
                n(r[4]),
                this.setRGB(
                  Math.min(100, parseInt(r[1], 10)) / 100,
                  Math.min(100, parseInt(r[2], 10)) / 100,
                  Math.min(100, parseInt(r[3], 10)) / 100,
                  e
                )
              );
            break;
          case "hsl":
          case "hsla":
            if (
              (r =
                /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  a
                ))
            )
              return (
                n(r[4]),
                this.setHSL(
                  parseFloat(r[1]) / 360,
                  parseFloat(r[2]) / 100,
                  parseFloat(r[3]) / 100,
                  e
                )
              );
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + t);
        }
      } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
        const n = i[1],
          r = n.length;
        if (3 === r)
          return this.setRGB(
            parseInt(n.charAt(0), 16) / 15,
            parseInt(n.charAt(1), 16) / 15,
            parseInt(n.charAt(2), 16) / 15,
            e
          );
        if (6 === r) return this.setHex(parseInt(n, 16), e);
        console.warn("THREE.Color: Invalid hex color " + t);
      } else if (t && t.length > 0) return this.setColorName(t, e);
      return this;
    }
    setColorName(t, e = ru) {
      const n = Sd[t.toLowerCase()];
      return (
        void 0 !== n
          ? this.setHex(n, e)
          : console.warn("THREE.Color: Unknown color " + t),
        this
      );
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(t) {
      return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
    }
    copySRGBToLinear(t) {
      return (this.r = Xu(t.r)), (this.g = Xu(t.g)), (this.b = Xu(t.b)), this;
    }
    copyLinearToSRGB(t) {
      return (this.r = qu(t.r)), (this.g = qu(t.g)), (this.b = qu(t.b)), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(t = ru) {
      return (
        Wu.fromWorkingColorSpace(Dd.copy(this), t),
        65536 * Math.round(Au(255 * Dd.r, 0, 255)) +
          256 * Math.round(Au(255 * Dd.g, 0, 255)) +
          Math.round(Au(255 * Dd.b, 0, 255))
      );
    }
    getHexString(t = ru) {
      return ("000000" + this.getHex(t).toString(16)).slice(-6);
    }
    getHSL(t, e = Wu.workingColorSpace) {
      Wu.fromWorkingColorSpace(Dd.copy(this), e);
      const n = Dd.r,
        i = Dd.g,
        r = Dd.b,
        s = Math.max(n, i, r),
        a = Math.min(n, i, r);
      let o, l;
      const c = (a + s) / 2;
      if (a === s) (o = 0), (l = 0);
      else {
        const t = s - a;
        switch (((l = c <= 0.5 ? t / (s + a) : t / (2 - s - a)), s)) {
          case n:
            o = (i - r) / t + (i < r ? 6 : 0);
            break;
          case i:
            o = (r - n) / t + 2;
            break;
          case r:
            o = (n - i) / t + 4;
        }
        o /= 6;
      }
      return (t.h = o), (t.s = l), (t.l = c), t;
    }
    getRGB(t, e = Wu.workingColorSpace) {
      return (
        Wu.fromWorkingColorSpace(Dd.copy(this), e),
        (t.r = Dd.r),
        (t.g = Dd.g),
        (t.b = Dd.b),
        t
      );
    }
    getStyle(t = ru) {
      Wu.fromWorkingColorSpace(Dd.copy(this), t);
      const e = Dd.r,
        n = Dd.g,
        i = Dd.b;
      return t !== ru
        ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
        : `rgb(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(
            255 * i
          )})`;
    }
    offsetHSL(t, e, n) {
      return this.getHSL(Md), this.setHSL(Md.h + t, Md.s + e, Md.l + n);
    }
    add(t) {
      return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
    }
    addColors(t, e) {
      return (
        (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
      );
    }
    addScalar(t) {
      return (this.r += t), (this.g += t), (this.b += t), this;
    }
    sub(t) {
      return (
        (this.r = Math.max(0, this.r - t.r)),
        (this.g = Math.max(0, this.g - t.g)),
        (this.b = Math.max(0, this.b - t.b)),
        this
      );
    }
    multiply(t) {
      return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
    }
    multiplyScalar(t) {
      return (this.r *= t), (this.g *= t), (this.b *= t), this;
    }
    lerp(t, e) {
      return (
        (this.r += (t.r - this.r) * e),
        (this.g += (t.g - this.g) * e),
        (this.b += (t.b - this.b) * e),
        this
      );
    }
    lerpColors(t, e, n) {
      return (
        (this.r = t.r + (e.r - t.r) * n),
        (this.g = t.g + (e.g - t.g) * n),
        (this.b = t.b + (e.b - t.b) * n),
        this
      );
    }
    lerpHSL(t, e) {
      this.getHSL(Md), t.getHSL(Ed);
      const n = Ru(Md.h, Ed.h, e),
        i = Ru(Md.s, Ed.s, e),
        r = Ru(Md.l, Ed.l, e);
      return this.setHSL(n, i, r), this;
    }
    setFromVector3(t) {
      return (this.r = t.x), (this.g = t.y), (this.b = t.z), this;
    }
    applyMatrix3(t) {
      const e = this.r,
        n = this.g,
        i = this.b,
        r = t.elements;
      return (
        (this.r = r[0] * e + r[3] * n + r[6] * i),
        (this.g = r[1] * e + r[4] * n + r[7] * i),
        (this.b = r[2] * e + r[5] * n + r[8] * i),
        this
      );
    }
    equals(t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    }
    fromArray(t, e = 0) {
      return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
    }
    toArray(t = [], e = 0) {
      return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
    }
    fromBufferAttribute(t, e) {
      return (
        (this.r = t.getX(e)), (this.g = t.getY(e)), (this.b = t.getZ(e)), this
      );
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  }
  const Dd = new bd();
  bd.NAMES = Sd;
  let wd = 0;
  class Cd extends Tu {
    constructor() {
      super(),
        (this.isMaterial = !0),
        Object.defineProperty(this, "id", { value: wd++ }),
        (this.uuid = Cu()),
        (this.name = ""),
        (this.type = "Material"),
        (this.blending = 1),
        (this.side = 0),
        (this.vertexColors = !1),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.alphaHash = !1),
        (this.blendSrc = 204),
        (this.blendDst = 205),
        (this.blendEquation = tc),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.blendColor = new bd(0, 0, 0)),
        (this.blendAlpha = 0),
        (this.depthFunc = 3),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.stencilWriteMask = 255),
        (this.stencilFunc = 519),
        (this.stencilRef = 0),
        (this.stencilFuncMask = 255),
        (this.stencilFail = du),
        (this.stencilZFail = du),
        (this.stencilZPass = du),
        (this.stencilWrite = !1),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.shadowSide = null),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaToCoverage = !1),
        (this.premultipliedAlpha = !1),
        (this.forceSinglePass = !1),
        (this.visible = !0),
        (this.toneMapped = !0),
        (this.userData = {}),
        (this.version = 0),
        (this._alphaTest = 0);
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(t) {
      this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(t) {
      if (void 0 !== t)
        for (const e in t) {
          const n = t[e];
          if (void 0 === n) {
            console.warn(
              `THREE.Material: parameter '${e}' has value of undefined.`
            );
            continue;
          }
          const i = this[e];
          void 0 !== i
            ? i && i.isColor
              ? i.set(n)
              : i && i.isVector3 && n && n.isVector3
              ? i.copy(n)
              : (this[e] = n)
            : console.warn(
                `THREE.Material: '${e}' is not a property of THREE.${this.type}.`
              );
        }
    }
    toJSON(t) {
      const e = void 0 === t || "string" == typeof t;
      e && (t = { textures: {}, images: {} });
      const n = {
        metadata: {
          version: 4.6,
          type: "Material",
          generator: "Material.toJSON",
        },
      };
      function i(t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          delete i.metadata, e.push(i);
        }
        return e;
      }
      if (
        ((n.uuid = this.uuid),
        (n.type = this.type),
        "" !== this.name && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        void 0 !== this.roughness && (n.roughness = this.roughness),
        void 0 !== this.metalness && (n.metalness = this.metalness),
        void 0 !== this.sheen && (n.sheen = this.sheen),
        this.sheenColor &&
          this.sheenColor.isColor &&
          (n.sheenColor = this.sheenColor.getHex()),
        void 0 !== this.sheenRoughness &&
          (n.sheenRoughness = this.sheenRoughness),
        this.emissive &&
          this.emissive.isColor &&
          (n.emissive = this.emissive.getHex()),
        void 0 !== this.emissiveIntensity &&
          1 !== this.emissiveIntensity &&
          (n.emissiveIntensity = this.emissiveIntensity),
        this.specular &&
          this.specular.isColor &&
          (n.specular = this.specular.getHex()),
        void 0 !== this.specularIntensity &&
          (n.specularIntensity = this.specularIntensity),
        this.specularColor &&
          this.specularColor.isColor &&
          (n.specularColor = this.specularColor.getHex()),
        void 0 !== this.shininess && (n.shininess = this.shininess),
        void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
        void 0 !== this.clearcoatRoughness &&
          (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap &&
          this.clearcoatMap.isTexture &&
          (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
        this.clearcoatRoughnessMap &&
          this.clearcoatRoughnessMap.isTexture &&
          (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
        this.clearcoatNormalMap &&
          this.clearcoatNormalMap.isTexture &&
          ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
          (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
        void 0 !== this.dispersion && (n.dispersion = this.dispersion),
        void 0 !== this.iridescence && (n.iridescence = this.iridescence),
        void 0 !== this.iridescenceIOR &&
          (n.iridescenceIOR = this.iridescenceIOR),
        void 0 !== this.iridescenceThicknessRange &&
          (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap &&
          this.iridescenceMap.isTexture &&
          (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
        this.iridescenceThicknessMap &&
          this.iridescenceThicknessMap.isTexture &&
          (n.iridescenceThicknessMap =
            this.iridescenceThicknessMap.toJSON(t).uuid),
        void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
        void 0 !== this.anisotropyRotation &&
          (n.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap &&
          this.anisotropyMap.isTexture &&
          (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
        this.matcap &&
          this.matcap.isTexture &&
          (n.matcap = this.matcap.toJSON(t).uuid),
        this.alphaMap &&
          this.alphaMap.isTexture &&
          (n.alphaMap = this.alphaMap.toJSON(t).uuid),
        this.lightMap &&
          this.lightMap.isTexture &&
          ((n.lightMap = this.lightMap.toJSON(t).uuid),
          (n.lightMapIntensity = this.lightMapIntensity)),
        this.aoMap &&
          this.aoMap.isTexture &&
          ((n.aoMap = this.aoMap.toJSON(t).uuid),
          (n.aoMapIntensity = this.aoMapIntensity)),
        this.bumpMap &&
          this.bumpMap.isTexture &&
          ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
          (n.bumpScale = this.bumpScale)),
        this.normalMap &&
          this.normalMap.isTexture &&
          ((n.normalMap = this.normalMap.toJSON(t).uuid),
          (n.normalMapType = this.normalMapType),
          (n.normalScale = this.normalScale.toArray())),
        this.displacementMap &&
          this.displacementMap.isTexture &&
          ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
          (n.displacementScale = this.displacementScale),
          (n.displacementBias = this.displacementBias)),
        this.roughnessMap &&
          this.roughnessMap.isTexture &&
          (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
        this.metalnessMap &&
          this.metalnessMap.isTexture &&
          (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
        this.emissiveMap &&
          this.emissiveMap.isTexture &&
          (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
        this.specularMap &&
          this.specularMap.isTexture &&
          (n.specularMap = this.specularMap.toJSON(t).uuid),
        this.specularIntensityMap &&
          this.specularIntensityMap.isTexture &&
          (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
        this.specularColorMap &&
          this.specularColorMap.isTexture &&
          (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
        this.envMap &&
          this.envMap.isTexture &&
          ((n.envMap = this.envMap.toJSON(t).uuid),
          void 0 !== this.combine && (n.combine = this.combine)),
        void 0 !== this.envMapRotation &&
          (n.envMapRotation = this.envMapRotation.toArray()),
        void 0 !== this.envMapIntensity &&
          (n.envMapIntensity = this.envMapIntensity),
        void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
        void 0 !== this.refractionRatio &&
          (n.refractionRatio = this.refractionRatio),
        this.gradientMap &&
          this.gradientMap.isTexture &&
          (n.gradientMap = this.gradientMap.toJSON(t).uuid),
        void 0 !== this.transmission && (n.transmission = this.transmission),
        this.transmissionMap &&
          this.transmissionMap.isTexture &&
          (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
        void 0 !== this.thickness && (n.thickness = this.thickness),
        this.thicknessMap &&
          this.thicknessMap.isTexture &&
          (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
        void 0 !== this.attenuationDistance &&
          this.attenuationDistance !== 1 / 0 &&
          (n.attenuationDistance = this.attenuationDistance),
        void 0 !== this.attenuationColor &&
          (n.attenuationColor = this.attenuationColor.getHex()),
        void 0 !== this.size && (n.size = this.size),
        null !== this.shadowSide && (n.shadowSide = this.shadowSide),
        void 0 !== this.sizeAttenuation &&
          (n.sizeAttenuation = this.sizeAttenuation),
        1 !== this.blending && (n.blending = this.blending),
        0 !== this.side && (n.side = this.side),
        !0 === this.vertexColors && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        !0 === this.transparent && (n.transparent = !0),
        204 !== this.blendSrc && (n.blendSrc = this.blendSrc),
        205 !== this.blendDst && (n.blendDst = this.blendDst),
        this.blendEquation !== tc && (n.blendEquation = this.blendEquation),
        null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha),
        null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha),
        null !== this.blendEquationAlpha &&
          (n.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor &&
          this.blendColor.isColor &&
          (n.blendColor = this.blendColor.getHex()),
        0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
        3 !== this.depthFunc && (n.depthFunc = this.depthFunc),
        !1 === this.depthTest && (n.depthTest = this.depthTest),
        !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
        !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
        255 !== this.stencilWriteMask &&
          (n.stencilWriteMask = this.stencilWriteMask),
        519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc),
        0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
        255 !== this.stencilFuncMask &&
          (n.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== du && (n.stencilFail = this.stencilFail),
        this.stencilZFail !== du && (n.stencilZFail = this.stencilZFail),
        this.stencilZPass !== du && (n.stencilZPass = this.stencilZPass),
        !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
        void 0 !== this.rotation &&
          0 !== this.rotation &&
          (n.rotation = this.rotation),
        !0 === this.polygonOffset && (n.polygonOffset = !0),
        0 !== this.polygonOffsetFactor &&
          (n.polygonOffsetFactor = this.polygonOffsetFactor),
        0 !== this.polygonOffsetUnits &&
          (n.polygonOffsetUnits = this.polygonOffsetUnits),
        void 0 !== this.linewidth &&
          1 !== this.linewidth &&
          (n.linewidth = this.linewidth),
        void 0 !== this.dashSize && (n.dashSize = this.dashSize),
        void 0 !== this.gapSize && (n.gapSize = this.gapSize),
        void 0 !== this.scale && (n.scale = this.scale),
        !0 === this.dithering && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        !0 === this.alphaHash && (n.alphaHash = !0),
        !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
        !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
        !0 === this.forceSinglePass && (n.forceSinglePass = !0),
        !0 === this.wireframe && (n.wireframe = !0),
        this.wireframeLinewidth > 1 &&
          (n.wireframeLinewidth = this.wireframeLinewidth),
        "round" !== this.wireframeLinecap &&
          (n.wireframeLinecap = this.wireframeLinecap),
        "round" !== this.wireframeLinejoin &&
          (n.wireframeLinejoin = this.wireframeLinejoin),
        !0 === this.flatShading && (n.flatShading = !0),
        !1 === this.visible && (n.visible = !1),
        !1 === this.toneMapped && (n.toneMapped = !1),
        !1 === this.fog && (n.fog = !1),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        e)
      ) {
        const e = i(t.textures),
          r = i(t.images);
        e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
      }
      return n;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.name = t.name),
        (this.blending = t.blending),
        (this.side = t.side),
        (this.vertexColors = t.vertexColors),
        (this.opacity = t.opacity),
        (this.transparent = t.transparent),
        (this.blendSrc = t.blendSrc),
        (this.blendDst = t.blendDst),
        (this.blendEquation = t.blendEquation),
        (this.blendSrcAlpha = t.blendSrcAlpha),
        (this.blendDstAlpha = t.blendDstAlpha),
        (this.blendEquationAlpha = t.blendEquationAlpha),
        this.blendColor.copy(t.blendColor),
        (this.blendAlpha = t.blendAlpha),
        (this.depthFunc = t.depthFunc),
        (this.depthTest = t.depthTest),
        (this.depthWrite = t.depthWrite),
        (this.stencilWriteMask = t.stencilWriteMask),
        (this.stencilFunc = t.stencilFunc),
        (this.stencilRef = t.stencilRef),
        (this.stencilFuncMask = t.stencilFuncMask),
        (this.stencilFail = t.stencilFail),
        (this.stencilZFail = t.stencilZFail),
        (this.stencilZPass = t.stencilZPass),
        (this.stencilWrite = t.stencilWrite);
      const e = t.clippingPlanes;
      let n = null;
      if (null !== e) {
        const t = e.length;
        n = new Array(t);
        for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
      }
      return (
        (this.clippingPlanes = n),
        (this.clipIntersection = t.clipIntersection),
        (this.clipShadows = t.clipShadows),
        (this.shadowSide = t.shadowSide),
        (this.colorWrite = t.colorWrite),
        (this.precision = t.precision),
        (this.polygonOffset = t.polygonOffset),
        (this.polygonOffsetFactor = t.polygonOffsetFactor),
        (this.polygonOffsetUnits = t.polygonOffsetUnits),
        (this.dithering = t.dithering),
        (this.alphaTest = t.alphaTest),
        (this.alphaHash = t.alphaHash),
        (this.alphaToCoverage = t.alphaToCoverage),
        (this.premultipliedAlpha = t.premultipliedAlpha),
        (this.forceSinglePass = t.forceSinglePass),
        (this.visible = t.visible),
        (this.toneMapped = t.toneMapped),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
  }
  class Ad extends Cd {
    constructor(t) {
      super(),
        (this.isMeshBasicMaterial = !0),
        (this.type = "MeshBasicMaterial"),
        (this.color = new bd(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.envMapRotation = new qh()),
        (this.combine = _c),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.fog = !0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        this.envMapRotation.copy(t.envMapRotation),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.fog = t.fog),
        this
      );
    }
  }
  const Rd = new ah(),
    Pd = new Iu();
  class Ld {
    constructor(t, e, n = !1) {
      if (Array.isArray(t))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      (this.isBufferAttribute = !0),
        (this.name = ""),
        (this.array = t),
        (this.itemSize = e),
        (this.count = void 0 !== t ? t.length / e : 0),
        (this.normalized = n),
        (this.usage = 35044),
        (this._updateRange = { offset: 0, count: -1 }),
        (this.updateRanges = []),
        (this.gpuType = Gc),
        (this.version = 0);
    }
    onUploadCallback() {}
    set needsUpdate(t) {
      !0 === t && this.version++;
    }
    get updateRange() {
      return (
        (t =
          "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.") in
          zu || ((zu[t] = !0), console.warn(t)),
        this._updateRange
      );
      var t;
    }
    setUsage(t) {
      return (this.usage = t), this;
    }
    addUpdateRange(t, e) {
      this.updateRanges.push({ start: t, count: e });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(t) {
      return (
        (this.name = t.name),
        (this.array = new t.array.constructor(t.array)),
        (this.itemSize = t.itemSize),
        (this.count = t.count),
        (this.normalized = t.normalized),
        (this.usage = t.usage),
        (this.gpuType = t.gpuType),
        this
      );
    }
    copyAt(t, e, n) {
      (t *= this.itemSize), (n *= e.itemSize);
      for (let i = 0, r = this.itemSize; i < r; i++)
        this.array[t + i] = e.array[n + i];
      return this;
    }
    copyArray(t) {
      return this.array.set(t), this;
    }
    applyMatrix3(t) {
      if (2 === this.itemSize)
        for (let e = 0, n = this.count; e < n; e++)
          Pd.fromBufferAttribute(this, e),
            Pd.applyMatrix3(t),
            this.setXY(e, Pd.x, Pd.y);
      else if (3 === this.itemSize)
        for (let e = 0, n = this.count; e < n; e++)
          Rd.fromBufferAttribute(this, e),
            Rd.applyMatrix3(t),
            this.setXYZ(e, Rd.x, Rd.y, Rd.z);
      return this;
    }
    applyMatrix4(t) {
      for (let e = 0, n = this.count; e < n; e++)
        Rd.fromBufferAttribute(this, e),
          Rd.applyMatrix4(t),
          this.setXYZ(e, Rd.x, Rd.y, Rd.z);
      return this;
    }
    applyNormalMatrix(t) {
      for (let e = 0, n = this.count; e < n; e++)
        Rd.fromBufferAttribute(this, e),
          Rd.applyNormalMatrix(t),
          this.setXYZ(e, Rd.x, Rd.y, Rd.z);
      return this;
    }
    transformDirection(t) {
      for (let e = 0, n = this.count; e < n; e++)
        Rd.fromBufferAttribute(this, e),
          Rd.transformDirection(t),
          this.setXYZ(e, Rd.x, Rd.y, Rd.z);
      return this;
    }
    set(t, e = 0) {
      return this.array.set(t, e), this;
    }
    getComponent(t, e) {
      let n = this.array[t * this.itemSize + e];
      return this.normalized && (n = Pu(n, this.array)), n;
    }
    setComponent(t, e, n) {
      return (
        this.normalized && (n = Lu(n, this.array)),
        (this.array[t * this.itemSize + e] = n),
        this
      );
    }
    getX(t) {
      let e = this.array[t * this.itemSize];
      return this.normalized && (e = Pu(e, this.array)), e;
    }
    setX(t, e) {
      return (
        this.normalized && (e = Lu(e, this.array)),
        (this.array[t * this.itemSize] = e),
        this
      );
    }
    getY(t) {
      let e = this.array[t * this.itemSize + 1];
      return this.normalized && (e = Pu(e, this.array)), e;
    }
    setY(t, e) {
      return (
        this.normalized && (e = Lu(e, this.array)),
        (this.array[t * this.itemSize + 1] = e),
        this
      );
    }
    getZ(t) {
      let e = this.array[t * this.itemSize + 2];
      return this.normalized && (e = Pu(e, this.array)), e;
    }
    setZ(t, e) {
      return (
        this.normalized && (e = Lu(e, this.array)),
        (this.array[t * this.itemSize + 2] = e),
        this
      );
    }
    getW(t) {
      let e = this.array[t * this.itemSize + 3];
      return this.normalized && (e = Pu(e, this.array)), e;
    }
    setW(t, e) {
      return (
        this.normalized && (e = Lu(e, this.array)),
        (this.array[t * this.itemSize + 3] = e),
        this
      );
    }
    setXY(t, e, n) {
      return (
        (t *= this.itemSize),
        this.normalized && ((e = Lu(e, this.array)), (n = Lu(n, this.array))),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        this
      );
    }
    setXYZ(t, e, n, i) {
      return (
        (t *= this.itemSize),
        this.normalized &&
          ((e = Lu(e, this.array)),
          (n = Lu(n, this.array)),
          (i = Lu(i, this.array))),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        (this.array[t + 2] = i),
        this
      );
    }
    setXYZW(t, e, n, i, r) {
      return (
        (t *= this.itemSize),
        this.normalized &&
          ((e = Lu(e, this.array)),
          (n = Lu(n, this.array)),
          (i = Lu(i, this.array)),
          (r = Lu(r, this.array))),
        (this.array[t + 0] = e),
        (this.array[t + 1] = n),
        (this.array[t + 2] = i),
        (this.array[t + 3] = r),
        this
      );
    }
    onUpload(t) {
      return (this.onUploadCallback = t), this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const t = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized,
      };
      return (
        "" !== this.name && (t.name = this.name),
        35044 !== this.usage && (t.usage = this.usage),
        t
      );
    }
  }
  class Id extends Ld {
    constructor(t, e, n) {
      super(new Uint16Array(t), e, n);
    }
  }
  class Ud extends Ld {
    constructor(t, e, n) {
      super(new Uint32Array(t), e, n);
    }
  }
  class Nd extends Ld {
    constructor(t, e, n) {
      super(new Float32Array(t), e, n);
    }
  }
  let Fd = 0;
  const Od = new Fh(),
    Bd = new cd(),
    zd = new ah(),
    kd = new ch(),
    Vd = new ch(),
    Hd = new ah();
  class Gd extends Tu {
    constructor() {
      super(),
        (this.isBufferGeometry = !0),
        Object.defineProperty(this, "id", { value: Fd++ }),
        (this.uuid = Cu()),
        (this.name = ""),
        (this.type = "BufferGeometry"),
        (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.morphTargetsRelative = !1),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.drawRange = { start: 0, count: 1 / 0 }),
        (this.userData = {});
    }
    getIndex() {
      return this.index;
    }
    setIndex(t) {
      return (
        Array.isArray(t)
          ? (this.index = new (Fu(t) ? Ud : Id)(t, 1))
          : (this.index = t),
        this
      );
    }
    getAttribute(t) {
      return this.attributes[t];
    }
    setAttribute(t, e) {
      return (this.attributes[t] = e), this;
    }
    deleteAttribute(t) {
      return delete this.attributes[t], this;
    }
    hasAttribute(t) {
      return void 0 !== this.attributes[t];
    }
    addGroup(t, e, n = 0) {
      this.groups.push({ start: t, count: e, materialIndex: n });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(t, e) {
      (this.drawRange.start = t), (this.drawRange.count = e);
    }
    applyMatrix4(t) {
      const e = this.attributes.position;
      void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
      const n = this.attributes.normal;
      if (void 0 !== n) {
        const e = new Uu().getNormalMatrix(t);
        n.applyNormalMatrix(e), (n.needsUpdate = !0);
      }
      const i = this.attributes.tangent;
      return (
        void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
      );
    }
    applyQuaternion(t) {
      return Od.makeRotationFromQuaternion(t), this.applyMatrix4(Od), this;
    }
    rotateX(t) {
      return Od.makeRotationX(t), this.applyMatrix4(Od), this;
    }
    rotateY(t) {
      return Od.makeRotationY(t), this.applyMatrix4(Od), this;
    }
    rotateZ(t) {
      return Od.makeRotationZ(t), this.applyMatrix4(Od), this;
    }
    translate(t, e, n) {
      return Od.makeTranslation(t, e, n), this.applyMatrix4(Od), this;
    }
    scale(t, e, n) {
      return Od.makeScale(t, e, n), this.applyMatrix4(Od), this;
    }
    lookAt(t) {
      return (
        Bd.lookAt(t), Bd.updateMatrix(), this.applyMatrix4(Bd.matrix), this
      );
    }
    center() {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(zd).negate(),
        this.translate(zd.x, zd.y, zd.z),
        this
      );
    }
    setFromPoints(t) {
      const e = [];
      for (let n = 0, i = t.length; n < i; n++) {
        const i = t[n];
        e.push(i.x, i.y, i.z || 0);
      }
      return this.setAttribute("position", new Nd(e, 3)), this;
    }
    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new ch());
      const t = this.attributes.position,
        e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute)
        return (
          console.error(
            "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
            this
          ),
          void this.boundingBox.set(
            new ah(-1 / 0, -1 / 0, -1 / 0),
            new ah(1 / 0, 1 / 0, 1 / 0)
          )
        );
      if (void 0 !== t) {
        if ((this.boundingBox.setFromBufferAttribute(t), e))
          for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t];
            kd.setFromBufferAttribute(n),
              this.morphTargetsRelative
                ? (Hd.addVectors(this.boundingBox.min, kd.min),
                  this.boundingBox.expandByPoint(Hd),
                  Hd.addVectors(this.boundingBox.max, kd.max),
                  this.boundingBox.expandByPoint(Hd))
                : (this.boundingBox.expandByPoint(kd.min),
                  this.boundingBox.expandByPoint(kd.max));
          }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) ||
        isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z)) &&
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
          this
        );
    }
    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new wh());
      const t = this.attributes.position,
        e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute)
        return (
          console.error(
            "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
            this
          ),
          void this.boundingSphere.set(new ah(), 1 / 0)
        );
      if (t) {
        const n = this.boundingSphere.center;
        if ((kd.setFromBufferAttribute(t), e))
          for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t];
            Vd.setFromBufferAttribute(n),
              this.morphTargetsRelative
                ? (Hd.addVectors(kd.min, Vd.min),
                  kd.expandByPoint(Hd),
                  Hd.addVectors(kd.max, Vd.max),
                  kd.expandByPoint(Hd))
                : (kd.expandByPoint(Vd.min), kd.expandByPoint(Vd.max));
          }
        kd.getCenter(n);
        let i = 0;
        for (let e = 0, r = t.count; e < r; e++)
          Hd.fromBufferAttribute(t, e),
            (i = Math.max(i, n.distanceToSquared(Hd)));
        if (e)
          for (let r = 0, s = e.length; r < s; r++) {
            const s = e[r],
              a = this.morphTargetsRelative;
            for (let e = 0, r = s.count; e < r; e++)
              Hd.fromBufferAttribute(s, e),
                a && (zd.fromBufferAttribute(t, e), Hd.add(zd)),
                (i = Math.max(i, n.distanceToSquared(Hd)));
          }
        (this.boundingSphere.radius = Math.sqrt(i)),
          isNaN(this.boundingSphere.radius) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
              this
            );
      }
    }
    computeTangents() {
      const t = this.index,
        e = this.attributes;
      if (
        null === t ||
        void 0 === e.position ||
        void 0 === e.normal ||
        void 0 === e.uv
      )
        return void console.error(
          "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
        );
      const n = e.position,
        i = e.normal,
        r = e.uv;
      !1 === this.hasAttribute("tangent") &&
        this.setAttribute("tangent", new Ld(new Float32Array(4 * n.count), 4));
      const s = this.getAttribute("tangent"),
        a = [],
        o = [];
      for (let t = 0; t < n.count; t++) (a[t] = new ah()), (o[t] = new ah());
      const l = new ah(),
        c = new ah(),
        u = new ah(),
        h = new Iu(),
        d = new Iu(),
        p = new Iu(),
        f = new ah(),
        m = new ah();
      function g(t, e, i) {
        l.fromBufferAttribute(n, t),
          c.fromBufferAttribute(n, e),
          u.fromBufferAttribute(n, i),
          h.fromBufferAttribute(r, t),
          d.fromBufferAttribute(r, e),
          p.fromBufferAttribute(r, i),
          c.sub(l),
          u.sub(l),
          d.sub(h),
          p.sub(h);
        const s = 1 / (d.x * p.y - p.x * d.y);
        isFinite(s) &&
          (f
            .copy(c)
            .multiplyScalar(p.y)
            .addScaledVector(u, -d.y)
            .multiplyScalar(s),
          m
            .copy(u)
            .multiplyScalar(d.x)
            .addScaledVector(c, -p.x)
            .multiplyScalar(s),
          a[t].add(f),
          a[e].add(f),
          a[i].add(f),
          o[t].add(m),
          o[e].add(m),
          o[i].add(m));
      }
      let v = this.groups;
      0 === v.length && (v = [{ start: 0, count: t.count }]);
      for (let e = 0, n = v.length; e < n; ++e) {
        const n = v[e],
          i = n.start;
        for (let e = i, r = i + n.count; e < r; e += 3)
          g(t.getX(e + 0), t.getX(e + 1), t.getX(e + 2));
      }
      const _ = new ah(),
        x = new ah(),
        y = new ah(),
        S = new ah();
      function M(t) {
        y.fromBufferAttribute(i, t), S.copy(y);
        const e = a[t];
        _.copy(e),
          _.sub(y.multiplyScalar(y.dot(e))).normalize(),
          x.crossVectors(S, e);
        const n = x.dot(o[t]) < 0 ? -1 : 1;
        s.setXYZW(t, _.x, _.y, _.z, n);
      }
      for (let e = 0, n = v.length; e < n; ++e) {
        const n = v[e],
          i = n.start;
        for (let e = i, r = i + n.count; e < r; e += 3)
          M(t.getX(e + 0)), M(t.getX(e + 1)), M(t.getX(e + 2));
      }
    }
    computeVertexNormals() {
      const t = this.index,
        e = this.getAttribute("position");
      if (void 0 !== e) {
        let n = this.getAttribute("normal");
        if (void 0 === n)
          (n = new Ld(new Float32Array(3 * e.count), 3)),
            this.setAttribute("normal", n);
        else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
        const i = new ah(),
          r = new ah(),
          s = new ah(),
          a = new ah(),
          o = new ah(),
          l = new ah(),
          c = new ah(),
          u = new ah();
        if (t)
          for (let h = 0, d = t.count; h < d; h += 3) {
            const d = t.getX(h + 0),
              p = t.getX(h + 1),
              f = t.getX(h + 2);
            i.fromBufferAttribute(e, d),
              r.fromBufferAttribute(e, p),
              s.fromBufferAttribute(e, f),
              c.subVectors(s, r),
              u.subVectors(i, r),
              c.cross(u),
              a.fromBufferAttribute(n, d),
              o.fromBufferAttribute(n, p),
              l.fromBufferAttribute(n, f),
              a.add(c),
              o.add(c),
              l.add(c),
              n.setXYZ(d, a.x, a.y, a.z),
              n.setXYZ(p, o.x, o.y, o.z),
              n.setXYZ(f, l.x, l.y, l.z);
          }
        else
          for (let t = 0, a = e.count; t < a; t += 3)
            i.fromBufferAttribute(e, t + 0),
              r.fromBufferAttribute(e, t + 1),
              s.fromBufferAttribute(e, t + 2),
              c.subVectors(s, r),
              u.subVectors(i, r),
              c.cross(u),
              n.setXYZ(t + 0, c.x, c.y, c.z),
              n.setXYZ(t + 1, c.x, c.y, c.z),
              n.setXYZ(t + 2, c.x, c.y, c.z);
        this.normalizeNormals(), (n.needsUpdate = !0);
      }
    }
    normalizeNormals() {
      const t = this.attributes.normal;
      for (let e = 0, n = t.count; e < n; e++)
        Hd.fromBufferAttribute(t, e),
          Hd.normalize(),
          t.setXYZ(e, Hd.x, Hd.y, Hd.z);
    }
    toNonIndexed() {
      function t(t, e) {
        const n = t.array,
          i = t.itemSize,
          r = t.normalized,
          s = new n.constructor(e.length * i);
        let a = 0,
          o = 0;
        for (let r = 0, l = e.length; r < l; r++) {
          a = t.isInterleavedBufferAttribute
            ? e[r] * t.data.stride + t.offset
            : e[r] * i;
          for (let t = 0; t < i; t++) s[o++] = n[a++];
        }
        return new Ld(s, i, r);
      }
      if (null === this.index)
        return (
          console.warn(
            "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
          ),
          this
        );
      const e = new Gd(),
        n = this.index.array,
        i = this.attributes;
      for (const r in i) {
        const s = t(i[r], n);
        e.setAttribute(r, s);
      }
      const r = this.morphAttributes;
      for (const i in r) {
        const s = [],
          a = r[i];
        for (let e = 0, i = a.length; e < i; e++) {
          const i = t(a[e], n);
          s.push(i);
        }
        e.morphAttributes[i] = s;
      }
      e.morphTargetsRelative = this.morphTargetsRelative;
      const s = this.groups;
      for (let t = 0, n = s.length; t < n; t++) {
        const n = s[t];
        e.addGroup(n.start, n.count, n.materialIndex);
      }
      return e;
    }
    toJSON() {
      const t = {
        metadata: {
          version: 4.6,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON",
        },
      };
      if (
        ((t.uuid = this.uuid),
        (t.type = this.type),
        "" !== this.name && (t.name = this.name),
        Object.keys(this.userData).length > 0 && (t.userData = this.userData),
        void 0 !== this.parameters)
      ) {
        const e = this.parameters;
        for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
        return t;
      }
      t.data = { attributes: {} };
      const e = this.index;
      null !== e &&
        (t.data.index = {
          type: e.array.constructor.name,
          array: Array.prototype.slice.call(e.array),
        });
      const n = this.attributes;
      for (const e in n) {
        const i = n[e];
        t.data.attributes[e] = i.toJSON(t.data);
      }
      const i = {};
      let r = !1;
      for (const e in this.morphAttributes) {
        const n = this.morphAttributes[e],
          s = [];
        for (let e = 0, i = n.length; e < i; e++) {
          const i = n[e];
          s.push(i.toJSON(t.data));
        }
        s.length > 0 && ((i[e] = s), (r = !0));
      }
      r &&
        ((t.data.morphAttributes = i),
        (t.data.morphTargetsRelative = this.morphTargetsRelative));
      const s = this.groups;
      s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
      const a = this.boundingSphere;
      return (
        null !== a &&
          (t.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius,
          }),
        t
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null);
      const e = {};
      this.name = t.name;
      const n = t.index;
      null !== n && this.setIndex(n.clone(e));
      const i = t.attributes;
      for (const t in i) {
        const n = i[t];
        this.setAttribute(t, n.clone(e));
      }
      const r = t.morphAttributes;
      for (const t in r) {
        const n = [],
          i = r[t];
        for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
        this.morphAttributes[t] = n;
      }
      this.morphTargetsRelative = t.morphTargetsRelative;
      const s = t.groups;
      for (let t = 0, e = s.length; t < e; t++) {
        const e = s[t];
        this.addGroup(e.start, e.count, e.materialIndex);
      }
      const a = t.boundingBox;
      null !== a && (this.boundingBox = a.clone());
      const o = t.boundingSphere;
      return (
        null !== o && (this.boundingSphere = o.clone()),
        (this.drawRange.start = t.drawRange.start),
        (this.drawRange.count = t.drawRange.count),
        (this.userData = t.userData),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  const Wd = new Fh(),
    Xd = new Nh(),
    qd = new wh(),
    jd = new ah(),
    Yd = new ah(),
    Kd = new ah(),
    Zd = new ah(),
    Jd = new ah(),
    $d = new ah(),
    Qd = new Iu(),
    tp = new Iu(),
    ep = new Iu(),
    np = new ah(),
    ip = new ah(),
    rp = new ah(),
    sp = new ah(),
    ap = new ah();
  class op extends cd {
    constructor(t = new Gd(), e = new Ad()) {
      super(),
        (this.isMesh = !0),
        (this.type = "Mesh"),
        (this.geometry = t),
        (this.material = e),
        this.updateMorphTargets();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        void 0 !== t.morphTargetInfluences &&
          (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
        void 0 !== t.morphTargetDictionary &&
          (this.morphTargetDictionary = Object.assign(
            {},
            t.morphTargetDictionary
          )),
        (this.material = Array.isArray(t.material)
          ? t.material.slice()
          : t.material),
        (this.geometry = t.geometry),
        this
      );
    }
    updateMorphTargets() {
      const t = this.geometry.morphAttributes,
        e = Object.keys(t);
      if (e.length > 0) {
        const n = t[e[0]];
        if (void 0 !== n) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let t = 0, e = n.length; t < e; t++) {
            const e = n[t].name || String(t);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[e] = t);
          }
        }
      }
    }
    getVertexPosition(t, e) {
      const n = this.geometry,
        i = n.attributes.position,
        r = n.morphAttributes.position,
        s = n.morphTargetsRelative;
      e.fromBufferAttribute(i, t);
      const a = this.morphTargetInfluences;
      if (r && a) {
        $d.set(0, 0, 0);
        for (let n = 0, i = r.length; n < i; n++) {
          const i = a[n],
            o = r[n];
          0 !== i &&
            (Jd.fromBufferAttribute(o, t),
            s ? $d.addScaledVector(Jd, i) : $d.addScaledVector(Jd.sub(e), i));
        }
        e.add($d);
      }
      return e;
    }
    raycast(t, e) {
      const n = this.geometry,
        i = this.material,
        r = this.matrixWorld;
      if (void 0 !== i) {
        if (
          (null === n.boundingSphere && n.computeBoundingSphere(),
          qd.copy(n.boundingSphere),
          qd.applyMatrix4(r),
          Xd.copy(t.ray).recast(t.near),
          !1 === qd.containsPoint(Xd.origin))
        ) {
          if (null === Xd.intersectSphere(qd, jd)) return;
          if (Xd.origin.distanceToSquared(jd) > (t.far - t.near) ** 2) return;
        }
        Wd.copy(r).invert(),
          Xd.copy(t.ray).applyMatrix4(Wd),
          (null !== n.boundingBox && !1 === Xd.intersectsBox(n.boundingBox)) ||
            this._computeIntersections(t, e, Xd);
      }
    }
    _computeIntersections(t, e, n) {
      let i;
      const r = this.geometry,
        s = this.material,
        a = r.index,
        o = r.attributes.position,
        l = r.attributes.uv,
        c = r.attributes.uv1,
        u = r.attributes.normal,
        h = r.groups,
        d = r.drawRange;
      if (null !== a)
        if (Array.isArray(s))
          for (let r = 0, o = h.length; r < o; r++) {
            const o = h[r],
              p = s[o.materialIndex];
            for (
              let r = Math.max(o.start, d.start),
                s = Math.min(
                  a.count,
                  Math.min(o.start + o.count, d.start + d.count)
                );
              r < s;
              r += 3
            )
              (i = lp(
                this,
                p,
                t,
                n,
                l,
                c,
                u,
                a.getX(r),
                a.getX(r + 1),
                a.getX(r + 2)
              )),
                i &&
                  ((i.faceIndex = Math.floor(r / 3)),
                  (i.face.materialIndex = o.materialIndex),
                  e.push(i));
          }
        else
          for (
            let r = Math.max(0, d.start),
              o = Math.min(a.count, d.start + d.count);
            r < o;
            r += 3
          )
            (i = lp(
              this,
              s,
              t,
              n,
              l,
              c,
              u,
              a.getX(r),
              a.getX(r + 1),
              a.getX(r + 2)
            )),
              i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
      else if (void 0 !== o)
        if (Array.isArray(s))
          for (let r = 0, a = h.length; r < a; r++) {
            const a = h[r],
              p = s[a.materialIndex];
            for (
              let r = Math.max(a.start, d.start),
                s = Math.min(
                  o.count,
                  Math.min(a.start + a.count, d.start + d.count)
                );
              r < s;
              r += 3
            )
              (i = lp(this, p, t, n, l, c, u, r, r + 1, r + 2)),
                i &&
                  ((i.faceIndex = Math.floor(r / 3)),
                  (i.face.materialIndex = a.materialIndex),
                  e.push(i));
          }
        else
          for (
            let r = Math.max(0, d.start),
              a = Math.min(o.count, d.start + d.count);
            r < a;
            r += 3
          )
            (i = lp(this, s, t, n, l, c, u, r, r + 1, r + 2)),
              i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
    }
  }
  function lp(t, e, n, i, r, s, a, o, l, c) {
    t.getVertexPosition(o, Yd),
      t.getVertexPosition(l, Kd),
      t.getVertexPosition(c, Zd);
    const u = (function (t, e, n, i, r, s, a, o) {
      let l;
      if (
        ((l =
          1 === e.side
            ? i.intersectTriangle(a, s, r, !0, o)
            : i.intersectTriangle(r, s, a, 0 === e.side, o)),
        null === l)
      )
        return null;
      ap.copy(o), ap.applyMatrix4(t.matrixWorld);
      const c = n.ray.origin.distanceTo(ap);
      return c < n.near || c > n.far
        ? null
        : { distance: c, point: ap.clone(), object: t };
    })(t, e, n, i, Yd, Kd, Zd, sp);
    if (u) {
      r &&
        (Qd.fromBufferAttribute(r, o),
        tp.fromBufferAttribute(r, l),
        ep.fromBufferAttribute(r, c),
        (u.uv = yd.getInterpolation(sp, Yd, Kd, Zd, Qd, tp, ep, new Iu()))),
        s &&
          (Qd.fromBufferAttribute(s, o),
          tp.fromBufferAttribute(s, l),
          ep.fromBufferAttribute(s, c),
          (u.uv1 = yd.getInterpolation(sp, Yd, Kd, Zd, Qd, tp, ep, new Iu()))),
        a &&
          (np.fromBufferAttribute(a, o),
          ip.fromBufferAttribute(a, l),
          rp.fromBufferAttribute(a, c),
          (u.normal = yd.getInterpolation(
            sp,
            Yd,
            Kd,
            Zd,
            np,
            ip,
            rp,
            new ah()
          )),
          u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
      const t = { a: o, b: l, c, normal: new ah(), materialIndex: 0 };
      yd.getNormal(Yd, Kd, Zd, t.normal), (u.face = t);
    }
    return u;
  }
  class cp extends Gd {
    constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
      super(),
        (this.type = "BoxGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          depth: n,
          widthSegments: i,
          heightSegments: r,
          depthSegments: s,
        });
      const a = this;
      (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
      const o = [],
        l = [],
        c = [],
        u = [];
      let h = 0,
        d = 0;
      function p(t, e, n, i, r, s, p, f, m, g, v) {
        const _ = s / m,
          x = p / g,
          y = s / 2,
          S = p / 2,
          M = f / 2,
          E = m + 1,
          T = g + 1;
        let b = 0,
          D = 0;
        const w = new ah();
        for (let s = 0; s < T; s++) {
          const a = s * x - S;
          for (let o = 0; o < E; o++) {
            const h = o * _ - y;
            (w[t] = h * i),
              (w[e] = a * r),
              (w[n] = M),
              l.push(w.x, w.y, w.z),
              (w[t] = 0),
              (w[e] = 0),
              (w[n] = f > 0 ? 1 : -1),
              c.push(w.x, w.y, w.z),
              u.push(o / m),
              u.push(1 - s / g),
              (b += 1);
          }
        }
        for (let t = 0; t < g; t++)
          for (let e = 0; e < m; e++) {
            const n = h + e + E * t,
              i = h + e + E * (t + 1),
              r = h + (e + 1) + E * (t + 1),
              s = h + (e + 1) + E * t;
            o.push(n, i, s), o.push(i, r, s), (D += 6);
          }
        a.addGroup(d, D, v), (d += D), (h += b);
      }
      p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
        p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
        p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
        p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
        p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
        p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
        this.setIndex(o),
        this.setAttribute("position", new Nd(l, 3)),
        this.setAttribute("normal", new Nd(c, 3)),
        this.setAttribute("uv", new Nd(u, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new cp(
        t.width,
        t.height,
        t.depth,
        t.widthSegments,
        t.heightSegments,
        t.depthSegments
      );
    }
  }
  function up(t) {
    const e = {};
    for (const n in t) {
      e[n] = {};
      for (const i in t[n]) {
        const r = t[n][i];
        r &&
        (r.isColor ||
          r.isMatrix3 ||
          r.isMatrix4 ||
          r.isVector2 ||
          r.isVector3 ||
          r.isVector4 ||
          r.isTexture ||
          r.isQuaternion)
          ? r.isRenderTargetTexture
            ? (console.warn(
                "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
              ),
              (e[n][i] = null))
            : (e[n][i] = r.clone())
          : Array.isArray(r)
          ? (e[n][i] = r.slice())
          : (e[n][i] = r);
      }
    }
    return e;
  }
  function hp(t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
      const i = up(t[n]);
      for (const t in i) e[t] = i[t];
    }
    return e;
  }
  function dp(t) {
    const e = t.getRenderTarget();
    return null === e
      ? t.outputColorSpace
      : !0 === e.isXRRenderTarget
      ? e.texture.colorSpace
      : Wu.workingColorSpace;
  }
  const pp = { clone: up, merge: hp };
  class fp extends Cd {
    constructor(t) {
      super(),
        (this.isShaderMaterial = !0),
        (this.type = "ShaderMaterial"),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.uniformsGroups = []),
        (this.vertexShader =
          "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
        (this.fragmentShader =
          "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
        (this.linewidth = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.clipping = !1),
        (this.forceSinglePass = !0),
        (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
        (this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv1: [0, 0],
        }),
        (this.index0AttributeName = void 0),
        (this.uniformsNeedUpdate = !1),
        (this.glslVersion = null),
        void 0 !== t && this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.fragmentShader = t.fragmentShader),
        (this.vertexShader = t.vertexShader),
        (this.uniforms = up(t.uniforms)),
        (this.uniformsGroups = (function (t) {
          const e = [];
          for (let n = 0; n < t.length; n++) e.push(t[n].clone());
          return e;
        })(t.uniformsGroups)),
        (this.defines = Object.assign({}, t.defines)),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.fog = t.fog),
        (this.lights = t.lights),
        (this.clipping = t.clipping),
        (this.extensions = Object.assign({}, t.extensions)),
        (this.glslVersion = t.glslVersion),
        this
      );
    }
    toJSON(t) {
      const e = super.toJSON(t);
      (e.glslVersion = this.glslVersion), (e.uniforms = {});
      for (const n in this.uniforms) {
        const i = this.uniforms[n].value;
        i && i.isTexture
          ? (e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid })
          : i && i.isColor
          ? (e.uniforms[n] = { type: "c", value: i.getHex() })
          : i && i.isVector2
          ? (e.uniforms[n] = { type: "v2", value: i.toArray() })
          : i && i.isVector3
          ? (e.uniforms[n] = { type: "v3", value: i.toArray() })
          : i && i.isVector4
          ? (e.uniforms[n] = { type: "v4", value: i.toArray() })
          : i && i.isMatrix3
          ? (e.uniforms[n] = { type: "m3", value: i.toArray() })
          : i && i.isMatrix4
          ? (e.uniforms[n] = { type: "m4", value: i.toArray() })
          : (e.uniforms[n] = { value: i });
      }
      Object.keys(this.defines).length > 0 && (e.defines = this.defines),
        (e.vertexShader = this.vertexShader),
        (e.fragmentShader = this.fragmentShader),
        (e.lights = this.lights),
        (e.clipping = this.clipping);
      const n = {};
      for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
      return Object.keys(n).length > 0 && (e.extensions = n), e;
    }
  }
  class mp extends cd {
    constructor() {
      super(),
        (this.isCamera = !0),
        (this.type = "Camera"),
        (this.matrixWorldInverse = new Fh()),
        (this.projectionMatrix = new Fh()),
        (this.projectionMatrixInverse = new Fh()),
        (this.coordinateSystem = Mu);
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        this.matrixWorldInverse.copy(t.matrixWorldInverse),
        this.projectionMatrix.copy(t.projectionMatrix),
        this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
        (this.coordinateSystem = t.coordinateSystem),
        this
      );
    }
    getWorldDirection(t) {
      return super.getWorldDirection(t).negate();
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t, e) {
      super.updateWorldMatrix(t, e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const gp = new ah(),
    vp = new Iu(),
    _p = new Iu();
  class xp extends mp {
    constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
      super(),
        (this.isPerspectiveCamera = !0),
        (this.type = "PerspectiveCamera"),
        (this.fov = t),
        (this.zoom = 1),
        (this.near = n),
        (this.far = i),
        (this.focus = 10),
        (this.aspect = e),
        (this.view = null),
        (this.filmGauge = 35),
        (this.filmOffset = 0),
        this.updateProjectionMatrix();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.fov = t.fov),
        (this.zoom = t.zoom),
        (this.near = t.near),
        (this.far = t.far),
        (this.focus = t.focus),
        (this.aspect = t.aspect),
        (this.view = null === t.view ? null : Object.assign({}, t.view)),
        (this.filmGauge = t.filmGauge),
        (this.filmOffset = t.filmOffset),
        this
      );
    }
    setFocalLength(t) {
      const e = (0.5 * this.getFilmHeight()) / t;
      (this.fov = 2 * wu * Math.atan(e)), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const t = Math.tan(0.5 * Du * this.fov);
      return (0.5 * this.getFilmHeight()) / t;
    }
    getEffectiveFOV() {
      return 2 * wu * Math.atan(Math.tan(0.5 * Du * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    getViewBounds(t, e, n) {
      gp.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
        e.set(gp.x, gp.y).multiplyScalar(-t / gp.z),
        gp.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
        n.set(gp.x, gp.y).multiplyScalar(-t / gp.z);
    }
    getViewSize(t, e) {
      return this.getViewBounds(t, vp, _p), e.subVectors(_p, vp);
    }
    setViewOffset(t, e, n, i, r, s) {
      (this.aspect = t / e),
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = e),
        (this.view.offsetX = n),
        (this.view.offsetY = i),
        (this.view.width = r),
        (this.view.height = s),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t = this.near;
      let e = (t * Math.tan(0.5 * Du * this.fov)) / this.zoom,
        n = 2 * e,
        i = this.aspect * n,
        r = -0.5 * i;
      const s = this.view;
      if (null !== this.view && this.view.enabled) {
        const t = s.fullWidth,
          a = s.fullHeight;
        (r += (s.offsetX * i) / t),
          (e -= (s.offsetY * n) / a),
          (i *= s.width / t),
          (n *= s.height / a);
      }
      const a = this.filmOffset;
      0 !== a && (r += (t * a) / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(
          r,
          r + i,
          e,
          e - n,
          t,
          this.far,
          this.coordinateSystem
        ),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.fov = this.fov),
        (e.object.zoom = this.zoom),
        (e.object.near = this.near),
        (e.object.far = this.far),
        (e.object.focus = this.focus),
        (e.object.aspect = this.aspect),
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        (e.object.filmGauge = this.filmGauge),
        (e.object.filmOffset = this.filmOffset),
        e
      );
    }
  }
  const yp = -90;
  class Sp extends cd {
    constructor(t, e, n) {
      super(),
        (this.type = "CubeCamera"),
        (this.renderTarget = n),
        (this.coordinateSystem = null),
        (this.activeMipmapLevel = 0);
      const i = new xp(yp, 1, t, e);
      (i.layers = this.layers), this.add(i);
      const r = new xp(yp, 1, t, e);
      (r.layers = this.layers), this.add(r);
      const s = new xp(yp, 1, t, e);
      (s.layers = this.layers), this.add(s);
      const a = new xp(yp, 1, t, e);
      (a.layers = this.layers), this.add(a);
      const o = new xp(yp, 1, t, e);
      (o.layers = this.layers), this.add(o);
      const l = new xp(yp, 1, t, e);
      (l.layers = this.layers), this.add(l);
    }
    updateCoordinateSystem() {
      const t = this.coordinateSystem,
        e = this.children.concat(),
        [n, i, r, s, a, o] = e;
      for (const t of e) this.remove(t);
      if (t === Mu)
        n.up.set(0, 1, 0),
          n.lookAt(1, 0, 0),
          i.up.set(0, 1, 0),
          i.lookAt(-1, 0, 0),
          r.up.set(0, 0, -1),
          r.lookAt(0, 1, 0),
          s.up.set(0, 0, 1),
          s.lookAt(0, -1, 0),
          a.up.set(0, 1, 0),
          a.lookAt(0, 0, 1),
          o.up.set(0, 1, 0),
          o.lookAt(0, 0, -1);
      else {
        if (t !== Eu)
          throw new Error(
            "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
              t
          );
        n.up.set(0, -1, 0),
          n.lookAt(-1, 0, 0),
          i.up.set(0, -1, 0),
          i.lookAt(1, 0, 0),
          r.up.set(0, 0, 1),
          r.lookAt(0, 1, 0),
          s.up.set(0, 0, -1),
          s.lookAt(0, -1, 0),
          a.up.set(0, -1, 0),
          a.lookAt(0, 0, 1),
          o.up.set(0, -1, 0),
          o.lookAt(0, 0, -1);
      }
      for (const t of e) this.add(t), t.updateMatrixWorld();
    }
    update(t, e) {
      null === this.parent && this.updateMatrixWorld();
      const { renderTarget: n, activeMipmapLevel: i } = this;
      this.coordinateSystem !== t.coordinateSystem &&
        ((this.coordinateSystem = t.coordinateSystem),
        this.updateCoordinateSystem());
      const [r, s, a, o, l, c] = this.children,
        u = t.getRenderTarget(),
        h = t.getActiveCubeFace(),
        d = t.getActiveMipmapLevel(),
        p = t.xr.enabled;
      t.xr.enabled = !1;
      const f = n.texture.generateMipmaps;
      (n.texture.generateMipmaps = !1),
        t.setRenderTarget(n, 0, i),
        t.render(e, r),
        t.setRenderTarget(n, 1, i),
        t.render(e, s),
        t.setRenderTarget(n, 2, i),
        t.render(e, a),
        t.setRenderTarget(n, 3, i),
        t.render(e, o),
        t.setRenderTarget(n, 4, i),
        t.render(e, l),
        (n.texture.generateMipmaps = f),
        t.setRenderTarget(n, 5, i),
        t.render(e, c),
        t.setRenderTarget(u, h, d),
        (t.xr.enabled = p),
        (n.texture.needsPMREMUpdate = !0);
    }
  }
  class Mp extends Qu {
    constructor(t, e, n, i, r, s, a, o, l, c) {
      super(
        (t = void 0 !== t ? t : []),
        (e = void 0 !== e ? e : Ac),
        n,
        i,
        r,
        s,
        a,
        o,
        l,
        c
      ),
        (this.isCubeTexture = !0),
        (this.flipY = !1);
    }
    get images() {
      return this.image;
    }
    set images(t) {
      this.image = t;
    }
  }
  class Ep extends nh {
    constructor(t = 1, e = {}) {
      super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
      const n = { width: t, height: t, depth: 1 },
        i = [n, n, n, n, n, n];
      (this.texture = new Mp(
        i,
        e.mapping,
        e.wrapS,
        e.wrapT,
        e.magFilter,
        e.minFilter,
        e.format,
        e.type,
        e.anisotropy,
        e.colorSpace
      )),
        (this.texture.isRenderTargetTexture = !0),
        (this.texture.generateMipmaps =
          void 0 !== e.generateMipmaps && e.generateMipmaps),
        (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Bc);
    }
    fromEquirectangularTexture(t, e) {
      (this.texture.type = e.type),
        (this.texture.colorSpace = e.colorSpace),
        (this.texture.generateMipmaps = e.generateMipmaps),
        (this.texture.minFilter = e.minFilter),
        (this.texture.magFilter = e.magFilter);
      const n = { tEquirect: { value: null } },
        i =
          "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
        r =
          "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
        s = new cp(5, 5, 5),
        a = new fp({
          name: "CubemapFromEquirect",
          uniforms: up(n),
          vertexShader: i,
          fragmentShader: r,
          side: 1,
          blending: 0,
        });
      a.uniforms.tEquirect.value = e;
      const o = new op(s, a),
        l = e.minFilter;
      return (
        e.minFilter === kc && (e.minFilter = Bc),
        new Sp(1, 10, this).update(t, o),
        (e.minFilter = l),
        o.geometry.dispose(),
        o.material.dispose(),
        this
      );
    }
    clear(t, e, n, i) {
      const r = t.getRenderTarget();
      for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
      t.setRenderTarget(r);
    }
  }
  const Tp = new ah(),
    bp = new ah(),
    Dp = new Uu();
  class wp {
    constructor(t = new ah(1, 0, 0), e = 0) {
      (this.isPlane = !0), (this.normal = t), (this.constant = e);
    }
    set(t, e) {
      return this.normal.copy(t), (this.constant = e), this;
    }
    setComponents(t, e, n, i) {
      return this.normal.set(t, e, n), (this.constant = i), this;
    }
    setFromNormalAndCoplanarPoint(t, e) {
      return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
    }
    setFromCoplanarPoints(t, e, n) {
      const i = Tp.subVectors(n, e).cross(bp.subVectors(t, e)).normalize();
      return this.setFromNormalAndCoplanarPoint(i, t), this;
    }
    copy(t) {
      return this.normal.copy(t.normal), (this.constant = t.constant), this;
    }
    normalize() {
      const t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), (this.constant *= t), this;
    }
    negate() {
      return (this.constant *= -1), this.normal.negate(), this;
    }
    distanceToPoint(t) {
      return this.normal.dot(t) + this.constant;
    }
    distanceToSphere(t) {
      return this.distanceToPoint(t.center) - t.radius;
    }
    projectPoint(t, e) {
      return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
    }
    intersectLine(t, e) {
      const n = t.delta(Tp),
        i = this.normal.dot(n);
      if (0 === i)
        return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
      const r = -(t.start.dot(this.normal) + this.constant) / i;
      return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r);
    }
    intersectsLine(t) {
      const e = this.distanceToPoint(t.start),
        n = this.distanceToPoint(t.end);
      return (e < 0 && n > 0) || (n < 0 && e > 0);
    }
    intersectsBox(t) {
      return t.intersectsPlane(this);
    }
    intersectsSphere(t) {
      return t.intersectsPlane(this);
    }
    coplanarPoint(t) {
      return t.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(t, e) {
      const n = e || Dp.getNormalMatrix(t),
        i = this.coplanarPoint(Tp).applyMatrix4(t),
        r = this.normal.applyMatrix3(n).normalize();
      return (this.constant = -i.dot(r)), this;
    }
    translate(t) {
      return (this.constant -= t.dot(this.normal)), this;
    }
    equals(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Cp = new wh(),
    Ap = new ah();
  class Rp {
    constructor(
      t = new wp(),
      e = new wp(),
      n = new wp(),
      i = new wp(),
      r = new wp(),
      s = new wp()
    ) {
      this.planes = [t, e, n, i, r, s];
    }
    set(t, e, n, i, r, s) {
      const a = this.planes;
      return (
        a[0].copy(t),
        a[1].copy(e),
        a[2].copy(n),
        a[3].copy(i),
        a[4].copy(r),
        a[5].copy(s),
        this
      );
    }
    copy(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
      return this;
    }
    setFromProjectionMatrix(t, e = 2e3) {
      const n = this.planes,
        i = t.elements,
        r = i[0],
        s = i[1],
        a = i[2],
        o = i[3],
        l = i[4],
        c = i[5],
        u = i[6],
        h = i[7],
        d = i[8],
        p = i[9],
        f = i[10],
        m = i[11],
        g = i[12],
        v = i[13],
        _ = i[14],
        x = i[15];
      if (
        (n[0].setComponents(o - r, h - l, m - d, x - g).normalize(),
        n[1].setComponents(o + r, h + l, m + d, x + g).normalize(),
        n[2].setComponents(o + s, h + c, m + p, x + v).normalize(),
        n[3].setComponents(o - s, h - c, m - p, x - v).normalize(),
        n[4].setComponents(o - a, h - u, m - f, x - _).normalize(),
        e === Mu)
      )
        n[5].setComponents(o + a, h + u, m + f, x + _).normalize();
      else {
        if (e !== Eu)
          throw new Error(
            "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
              e
          );
        n[5].setComponents(a, u, f, _).normalize();
      }
      return this;
    }
    intersectsObject(t) {
      if (void 0 !== t.boundingSphere)
        null === t.boundingSphere && t.computeBoundingSphere(),
          Cp.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
      else {
        const e = t.geometry;
        null === e.boundingSphere && e.computeBoundingSphere(),
          Cp.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
      }
      return this.intersectsSphere(Cp);
    }
    intersectsSprite(t) {
      return (
        Cp.center.set(0, 0, 0),
        (Cp.radius = 0.7071067811865476),
        Cp.applyMatrix4(t.matrixWorld),
        this.intersectsSphere(Cp)
      );
    }
    intersectsSphere(t) {
      const e = this.planes,
        n = t.center,
        i = -t.radius;
      for (let t = 0; t < 6; t++) if (e[t].distanceToPoint(n) < i) return !1;
      return !0;
    }
    intersectsBox(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) {
        const i = e[n];
        if (
          ((Ap.x = i.normal.x > 0 ? t.max.x : t.min.x),
          (Ap.y = i.normal.y > 0 ? t.max.y : t.min.y),
          (Ap.z = i.normal.z > 0 ? t.max.z : t.min.z),
          i.distanceToPoint(Ap) < 0)
        )
          return !1;
      }
      return !0;
    }
    containsPoint(t) {
      const e = this.planes;
      for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
      return !0;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  function Pp() {
    let t = null,
      e = !1,
      n = null,
      i = null;
    function r(e, s) {
      n(e, s), (i = t.requestAnimationFrame(r));
    }
    return {
      start: function () {
        !0 !== e && null !== n && ((i = t.requestAnimationFrame(r)), (e = !0));
      },
      stop: function () {
        t.cancelAnimationFrame(i), (e = !1);
      },
      setAnimationLoop: function (t) {
        n = t;
      },
      setContext: function (e) {
        t = e;
      },
    };
  }
  function Lp(t) {
    const e = new WeakMap();
    return {
      get: function (t) {
        return t.isInterleavedBufferAttribute && (t = t.data), e.get(t);
      },
      remove: function (n) {
        n.isInterleavedBufferAttribute && (n = n.data);
        const i = e.get(n);
        i && (t.deleteBuffer(i.buffer), e.delete(n));
      },
      update: function (n, i) {
        if (n.isGLBufferAttribute) {
          const t = e.get(n);
          return void (
            (!t || t.version < n.version) &&
            e.set(n, {
              buffer: n.buffer,
              type: n.type,
              bytesPerElement: n.elementSize,
              version: n.version,
            })
          );
        }
        n.isInterleavedBufferAttribute && (n = n.data);
        const r = e.get(n);
        if (void 0 === r)
          e.set(
            n,
            (function (e, n) {
              const i = e.array,
                r = e.usage,
                s = i.byteLength,
                a = t.createBuffer();
              let o;
              if (
                (t.bindBuffer(n, a),
                t.bufferData(n, i, r),
                e.onUploadCallback(),
                i instanceof Float32Array)
              )
                o = t.FLOAT;
              else if (i instanceof Uint16Array)
                o = e.isFloat16BufferAttribute
                  ? t.HALF_FLOAT
                  : t.UNSIGNED_SHORT;
              else if (i instanceof Int16Array) o = t.SHORT;
              else if (i instanceof Uint32Array) o = t.UNSIGNED_INT;
              else if (i instanceof Int32Array) o = t.INT;
              else if (i instanceof Int8Array) o = t.BYTE;
              else if (i instanceof Uint8Array) o = t.UNSIGNED_BYTE;
              else {
                if (!(i instanceof Uint8ClampedArray))
                  throw new Error(
                    "THREE.WebGLAttributes: Unsupported buffer data format: " +
                      i
                  );
                o = t.UNSIGNED_BYTE;
              }
              return {
                buffer: a,
                type: o,
                bytesPerElement: i.BYTES_PER_ELEMENT,
                version: e.version,
                size: s,
              };
            })(n, i)
          );
        else if (r.version < n.version) {
          if (r.size !== n.array.byteLength)
            throw new Error(
              "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
            );
          !(function (e, n, i) {
            const r = n.array,
              s = n._updateRange,
              a = n.updateRanges;
            if (
              (t.bindBuffer(i, e),
              -1 === s.count && 0 === a.length && t.bufferSubData(i, 0, r),
              0 !== a.length)
            ) {
              for (let e = 0, n = a.length; e < n; e++) {
                const n = a[e];
                t.bufferSubData(
                  i,
                  n.start * r.BYTES_PER_ELEMENT,
                  r,
                  n.start,
                  n.count
                );
              }
              n.clearUpdateRanges();
            }
            -1 !== s.count &&
              (t.bufferSubData(
                i,
                s.offset * r.BYTES_PER_ELEMENT,
                r,
                s.offset,
                s.count
              ),
              (s.count = -1)),
              n.onUploadCallback();
          })(r.buffer, n, i),
            (r.version = n.version);
        }
      },
    };
  }
  class Ip extends Gd {
    constructor(t = 1, e = 1, n = 1, i = 1) {
      super(),
        (this.type = "PlaneGeometry"),
        (this.parameters = {
          width: t,
          height: e,
          widthSegments: n,
          heightSegments: i,
        });
      const r = t / 2,
        s = e / 2,
        a = Math.floor(n),
        o = Math.floor(i),
        l = a + 1,
        c = o + 1,
        u = t / a,
        h = e / o,
        d = [],
        p = [],
        f = [],
        m = [];
      for (let t = 0; t < c; t++) {
        const e = t * h - s;
        for (let n = 0; n < l; n++) {
          const i = n * u - r;
          p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / a), m.push(1 - t / o);
        }
      }
      for (let t = 0; t < o; t++)
        for (let e = 0; e < a; e++) {
          const n = e + l * t,
            i = e + l * (t + 1),
            r = e + 1 + l * (t + 1),
            s = e + 1 + l * t;
          d.push(n, i, s), d.push(i, r, s);
        }
      this.setIndex(d),
        this.setAttribute("position", new Nd(p, 3)),
        this.setAttribute("normal", new Nd(f, 3)),
        this.setAttribute("uv", new Nd(m, 2));
    }
    copy(t) {
      return (
        super.copy(t), (this.parameters = Object.assign({}, t.parameters)), this
      );
    }
    static fromJSON(t) {
      return new Ip(t.width, t.height, t.widthSegments, t.heightSegments);
    }
  }
  const Up = {
      alphahash_fragment:
        "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
      alphahash_pars_fragment:
        "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
      alphamap_fragment:
        "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
      alphamap_pars_fragment:
        "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      alphatest_fragment:
        "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
      alphatest_pars_fragment:
        "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
      aomap_fragment:
        "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
      aomap_pars_fragment:
        "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
      batching_pars_vertex:
        "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
      batching_vertex:
        "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
      begin_vertex:
        "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
      beginnormal_vertex:
        "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
      bsdfs:
        "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
      iridescence_fragment:
        "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
      bumpmap_pars_fragment:
        "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
      clipping_planes_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
      clipping_planes_pars_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
      clipping_planes_pars_vertex:
        "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
      clipping_planes_vertex:
        "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
      color_fragment:
        "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
      color_pars_fragment:
        "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_pars_vertex:
        "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_vertex:
        "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
      common:
        "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
      cube_uv_reflection_fragment:
        "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
      defaultnormal_vertex:
        "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
      displacementmap_pars_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
      displacementmap_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
      emissivemap_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
      emissivemap_pars_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
      colorspace_fragment:
        "gl_FragColor = linearToOutputTexel( gl_FragColor );",
      colorspace_pars_fragment:
        "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
      envmap_fragment:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
      envmap_common_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
      envmap_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
      envmap_pars_vertex:
        "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
      envmap_physical_pars_fragment:
        "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
      envmap_vertex:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
      fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
      fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
      fog_fragment:
        "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
      fog_pars_fragment:
        "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
      gradientmap_pars_fragment:
        "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
      lightmap_pars_fragment:
        "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
      lights_lambert_fragment:
        "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
      lights_lambert_pars_fragment:
        "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
      lights_pars_begin:
        "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
      lights_toon_fragment:
        "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
      lights_toon_pars_fragment:
        "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
      lights_phong_fragment:
        "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
      lights_phong_pars_fragment:
        "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
      lights_physical_fragment:
        "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
      lights_physical_pars_fragment:
        "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
      lights_fragment_begin:
        "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
      lights_fragment_maps:
        "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
      lights_fragment_end:
        "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
      logdepthbuf_fragment:
        "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
      logdepthbuf_pars_fragment:
        "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
      logdepthbuf_pars_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
      logdepthbuf_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
      map_fragment:
        "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
      map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
      map_particle_fragment:
        "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
      map_particle_pars_fragment:
        "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      metalnessmap_fragment:
        "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
      metalnessmap_pars_fragment:
        "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
      morphinstance_vertex:
        "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[MORPHTARGETS_COUNT];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
      morphcolor_vertex:
        "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
      morphnormal_vertex:
        "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
      morphtarget_pars_vertex:
        "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t#endif\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\t#ifndef USE_INSTANCING_MORPH\n\t\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\t#endif\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
      morphtarget_vertex:
        "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
      normal_fragment_begin:
        "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
      normal_fragment_maps:
        "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
      normal_pars_fragment:
        "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_pars_vertex:
        "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_vertex:
        "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
      normalmap_pars_fragment:
        "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
      clearcoat_normal_fragment_begin:
        "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
      clearcoat_normal_fragment_maps:
        "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
      clearcoat_pars_fragment:
        "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
      iridescence_pars_fragment:
        "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
      opaque_fragment:
        "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
      packing:
        "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
      premultiplied_alpha_fragment:
        "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
      project_vertex:
        "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
      dithering_fragment:
        "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
      dithering_pars_fragment:
        "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
      roughnessmap_fragment:
        "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
      roughnessmap_pars_fragment:
        "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
      shadowmap_pars_fragment:
        "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n#endif",
      shadowmap_pars_vertex:
        "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
      shadowmap_vertex:
        "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
      shadowmask_pars_fragment:
        "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
      skinbase_vertex:
        "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
      skinning_pars_vertex:
        "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
      skinning_vertex:
        "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
      skinnormal_vertex:
        "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
      specularmap_fragment:
        "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
      specularmap_pars_fragment:
        "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
      tonemapping_fragment:
        "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
      tonemapping_pars_fragment:
        "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
      transmission_fragment:
        "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
      transmission_pars_fragment:
        "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
      uv_pars_fragment:
        "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
      uv_pars_vertex:
        "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
      uv_vertex:
        "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
      worldpos_vertex:
        "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
      background_vert:
        "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
      background_frag:
        "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      backgroundCube_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      backgroundCube_frag:
        "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      cube_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      cube_frag:
        "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      depth_vert:
        "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
      depth_frag:
        "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
      distanceRGBA_vert:
        "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
      distanceRGBA_frag:
        "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
      equirect_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
      equirect_frag:
        "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      linedashed_vert:
        "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      linedashed_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      meshbasic_vert:
        "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
      meshbasic_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshlambert_vert:
        "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshlambert_frag:
        "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshmatcap_vert:
        "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
      meshmatcap_frag:
        "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshnormal_vert:
        "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
      meshnormal_frag:
        "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
      meshphong_vert:
        "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshphong_frag:
        "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshphysical_vert:
        "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
      meshphysical_frag:
        "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshtoon_vert:
        "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshtoon_frag:
        "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      points_vert:
        "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
      points_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      shadow_vert:
        "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      shadow_frag:
        "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
      sprite_vert:
        "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      sprite_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
    },
    Np = {
      common: {
        diffuse: { value: new bd(16777215) },
        opacity: { value: 1 },
        map: { value: null },
        mapTransform: { value: new Uu() },
        alphaMap: { value: null },
        alphaMapTransform: { value: new Uu() },
        alphaTest: { value: 0 },
      },
      specularmap: {
        specularMap: { value: null },
        specularMapTransform: { value: new Uu() },
      },
      envmap: {
        envMap: { value: null },
        envMapRotation: { value: new Uu() },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        ior: { value: 1.5 },
        refractionRatio: { value: 0.98 },
      },
      aomap: {
        aoMap: { value: null },
        aoMapIntensity: { value: 1 },
        aoMapTransform: { value: new Uu() },
      },
      lightmap: {
        lightMap: { value: null },
        lightMapIntensity: { value: 1 },
        lightMapTransform: { value: new Uu() },
      },
      bumpmap: {
        bumpMap: { value: null },
        bumpMapTransform: { value: new Uu() },
        bumpScale: { value: 1 },
      },
      normalmap: {
        normalMap: { value: null },
        normalMapTransform: { value: new Uu() },
        normalScale: { value: new Iu(1, 1) },
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementMapTransform: { value: new Uu() },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 },
      },
      emissivemap: {
        emissiveMap: { value: null },
        emissiveMapTransform: { value: new Uu() },
      },
      metalnessmap: {
        metalnessMap: { value: null },
        metalnessMapTransform: { value: new Uu() },
      },
      roughnessmap: {
        roughnessMap: { value: null },
        roughnessMapTransform: { value: new Uu() },
      },
      gradientmap: { gradientMap: { value: null } },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new bd(16777215) },
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: {
          value: [],
          properties: { direction: {}, color: {} },
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
          },
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        spotLightMap: { value: [] },
        spotShadowMap: { value: [] },
        spotLightMatrix: { value: [] },
        pointLights: {
          value: [],
          properties: { color: {}, position: {}, decay: {}, distance: {} },
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {},
          },
        },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: {
          value: [],
          properties: { direction: {}, skyColor: {}, groundColor: {} },
        },
        rectAreaLights: {
          value: [],
          properties: { color: {}, position: {}, width: {}, height: {} },
        },
        ltc_1: { value: null },
        ltc_2: { value: null },
      },
      points: {
        diffuse: { value: new bd(16777215) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        alphaMapTransform: { value: new Uu() },
        alphaTest: { value: 0 },
        uvTransform: { value: new Uu() },
      },
      sprite: {
        diffuse: { value: new bd(16777215) },
        opacity: { value: 1 },
        center: { value: new Iu(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        mapTransform: { value: new Uu() },
        alphaMap: { value: null },
        alphaMapTransform: { value: new Uu() },
        alphaTest: { value: 0 },
      },
    },
    Fp = {
      basic: {
        uniforms: hp([
          Np.common,
          Np.specularmap,
          Np.envmap,
          Np.aomap,
          Np.lightmap,
          Np.fog,
        ]),
        vertexShader: Up.meshbasic_vert,
        fragmentShader: Up.meshbasic_frag,
      },
      lambert: {
        uniforms: hp([
          Np.common,
          Np.specularmap,
          Np.envmap,
          Np.aomap,
          Np.lightmap,
          Np.emissivemap,
          Np.bumpmap,
          Np.normalmap,
          Np.displacementmap,
          Np.fog,
          Np.lights,
          { emissive: { value: new bd(0) } },
        ]),
        vertexShader: Up.meshlambert_vert,
        fragmentShader: Up.meshlambert_frag,
      },
      phong: {
        uniforms: hp([
          Np.common,
          Np.specularmap,
          Np.envmap,
          Np.aomap,
          Np.lightmap,
          Np.emissivemap,
          Np.bumpmap,
          Np.normalmap,
          Np.displacementmap,
          Np.fog,
          Np.lights,
          {
            emissive: { value: new bd(0) },
            specular: { value: new bd(1118481) },
            shininess: { value: 30 },
          },
        ]),
        vertexShader: Up.meshphong_vert,
        fragmentShader: Up.meshphong_frag,
      },
      standard: {
        uniforms: hp([
          Np.common,
          Np.envmap,
          Np.aomap,
          Np.lightmap,
          Np.emissivemap,
          Np.bumpmap,
          Np.normalmap,
          Np.displacementmap,
          Np.roughnessmap,
          Np.metalnessmap,
          Np.fog,
          Np.lights,
          {
            emissive: { value: new bd(0) },
            roughness: { value: 1 },
            metalness: { value: 0 },
            envMapIntensity: { value: 1 },
          },
        ]),
        vertexShader: Up.meshphysical_vert,
        fragmentShader: Up.meshphysical_frag,
      },
      toon: {
        uniforms: hp([
          Np.common,
          Np.aomap,
          Np.lightmap,
          Np.emissivemap,
          Np.bumpmap,
          Np.normalmap,
          Np.displacementmap,
          Np.gradientmap,
          Np.fog,
          Np.lights,
          { emissive: { value: new bd(0) } },
        ]),
        vertexShader: Up.meshtoon_vert,
        fragmentShader: Up.meshtoon_frag,
      },
      matcap: {
        uniforms: hp([
          Np.common,
          Np.bumpmap,
          Np.normalmap,
          Np.displacementmap,
          Np.fog,
          { matcap: { value: null } },
        ]),
        vertexShader: Up.meshmatcap_vert,
        fragmentShader: Up.meshmatcap_frag,
      },
      points: {
        uniforms: hp([Np.points, Np.fog]),
        vertexShader: Up.points_vert,
        fragmentShader: Up.points_frag,
      },
      dashed: {
        uniforms: hp([
          Np.common,
          Np.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 },
          },
        ]),
        vertexShader: Up.linedashed_vert,
        fragmentShader: Up.linedashed_frag,
      },
      depth: {
        uniforms: hp([Np.common, Np.displacementmap]),
        vertexShader: Up.depth_vert,
        fragmentShader: Up.depth_frag,
      },
      normal: {
        uniforms: hp([
          Np.common,
          Np.bumpmap,
          Np.normalmap,
          Np.displacementmap,
          { opacity: { value: 1 } },
        ]),
        vertexShader: Up.meshnormal_vert,
        fragmentShader: Up.meshnormal_frag,
      },
      sprite: {
        uniforms: hp([Np.sprite, Np.fog]),
        vertexShader: Up.sprite_vert,
        fragmentShader: Up.sprite_frag,
      },
      background: {
        uniforms: {
          uvTransform: { value: new Uu() },
          t2D: { value: null },
          backgroundIntensity: { value: 1 },
        },
        vertexShader: Up.background_vert,
        fragmentShader: Up.background_frag,
      },
      backgroundCube: {
        uniforms: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          backgroundBlurriness: { value: 0 },
          backgroundIntensity: { value: 1 },
          backgroundRotation: { value: new Uu() },
        },
        vertexShader: Up.backgroundCube_vert,
        fragmentShader: Up.backgroundCube_frag,
      },
      cube: {
        uniforms: {
          tCube: { value: null },
          tFlip: { value: -1 },
          opacity: { value: 1 },
        },
        vertexShader: Up.cube_vert,
        fragmentShader: Up.cube_frag,
      },
      equirect: {
        uniforms: { tEquirect: { value: null } },
        vertexShader: Up.equirect_vert,
        fragmentShader: Up.equirect_frag,
      },
      distanceRGBA: {
        uniforms: hp([
          Np.common,
          Np.displacementmap,
          {
            referencePosition: { value: new ah() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 },
          },
        ]),
        vertexShader: Up.distanceRGBA_vert,
        fragmentShader: Up.distanceRGBA_frag,
      },
      shadow: {
        uniforms: hp([
          Np.lights,
          Np.fog,
          { color: { value: new bd(0) }, opacity: { value: 1 } },
        ]),
        vertexShader: Up.shadow_vert,
        fragmentShader: Up.shadow_frag,
      },
    };
  Fp.physical = {
    uniforms: hp([
      Fp.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatMapTransform: { value: new Uu() },
        clearcoatNormalMap: { value: null },
        clearcoatNormalMapTransform: { value: new Uu() },
        clearcoatNormalScale: { value: new Iu(1, 1) },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatRoughnessMapTransform: { value: new Uu() },
        dispersion: { value: 0 },
        iridescence: { value: 0 },
        iridescenceMap: { value: null },
        iridescenceMapTransform: { value: new Uu() },
        iridescenceIOR: { value: 1.3 },
        iridescenceThicknessMinimum: { value: 100 },
        iridescenceThicknessMaximum: { value: 400 },
        iridescenceThicknessMap: { value: null },
        iridescenceThicknessMapTransform: { value: new Uu() },
        sheen: { value: 0 },
        sheenColor: { value: new bd(0) },
        sheenColorMap: { value: null },
        sheenColorMapTransform: { value: new Uu() },
        sheenRoughness: { value: 1 },
        sheenRoughnessMap: { value: null },
        sheenRoughnessMapTransform: { value: new Uu() },
        transmission: { value: 0 },
        transmissionMap: { value: null },
        transmissionMapTransform: { value: new Uu() },
        transmissionSamplerSize: { value: new Iu() },
        transmissionSamplerMap: { value: null },
        thickness: { value: 0 },
        thicknessMap: { value: null },
        thicknessMapTransform: { value: new Uu() },
        attenuationDistance: { value: 0 },
        attenuationColor: { value: new bd(0) },
        specularColor: { value: new bd(1, 1, 1) },
        specularColorMap: { value: null },
        specularColorMapTransform: { value: new Uu() },
        specularIntensity: { value: 1 },
        specularIntensityMap: { value: null },
        specularIntensityMapTransform: { value: new Uu() },
        anisotropyVector: { value: new Iu() },
        anisotropyMap: { value: null },
        anisotropyMapTransform: { value: new Uu() },
      },
    ]),
    vertexShader: Up.meshphysical_vert,
    fragmentShader: Up.meshphysical_frag,
  };
  const Op = { r: 0, b: 0, g: 0 },
    Bp = new qh(),
    zp = new Fh();
  function kp(t, e, n, i, r, s, a) {
    const o = new bd(0);
    let l,
      c,
      u = !0 === s ? 0 : 1,
      h = null,
      d = 0,
      p = null;
    function f(t) {
      let i = !0 === t.isScene ? t.background : null;
      return (
        i && i.isTexture && (i = (t.backgroundBlurriness > 0 ? n : e).get(i)), i
      );
    }
    function m(e, n) {
      e.getRGB(Op, dp(t)), i.buffers.color.setClear(Op.r, Op.g, Op.b, n, a);
    }
    return {
      getClearColor: function () {
        return o;
      },
      setClearColor: function (t, e = 1) {
        o.set(t), (u = e), m(o, u);
      },
      getClearAlpha: function () {
        return u;
      },
      setClearAlpha: function (t) {
        (u = t), m(o, u);
      },
      render: function (e) {
        let n = !1;
        const r = f(e);
        null === r ? m(o, u) : r && r.isColor && (m(r, 1), (n = !0));
        const s = t.xr.getEnvironmentBlendMode();
        "additive" === s
          ? i.buffers.color.setClear(0, 0, 0, 1, a)
          : "alpha-blend" === s && i.buffers.color.setClear(0, 0, 0, 0, a),
          (t.autoClear || n) &&
            t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil);
      },
      addToRenderList: function (e, n) {
        const i = f(n);
        i && (i.isCubeTexture || i.mapping === Pc)
          ? (void 0 === c &&
              ((c = new op(
                new cp(1, 1, 1),
                new fp({
                  name: "BackgroundCubeMaterial",
                  uniforms: up(Fp.backgroundCube.uniforms),
                  vertexShader: Fp.backgroundCube.vertexShader,
                  fragmentShader: Fp.backgroundCube.fragmentShader,
                  side: 1,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )),
              c.geometry.deleteAttribute("normal"),
              c.geometry.deleteAttribute("uv"),
              (c.onBeforeRender = function (t, e, n) {
                this.matrixWorld.copyPosition(n.matrixWorld);
              }),
              Object.defineProperty(c.material, "envMap", {
                get: function () {
                  return this.uniforms.envMap.value;
                },
              }),
              r.update(c)),
            Bp.copy(n.backgroundRotation),
            (Bp.x *= -1),
            (Bp.y *= -1),
            (Bp.z *= -1),
            i.isCubeTexture &&
              !1 === i.isRenderTargetTexture &&
              ((Bp.y *= -1), (Bp.z *= -1)),
            (c.material.uniforms.envMap.value = i),
            (c.material.uniforms.flipEnvMap.value =
              i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1),
            (c.material.uniforms.backgroundBlurriness.value =
              n.backgroundBlurriness),
            (c.material.uniforms.backgroundIntensity.value =
              n.backgroundIntensity),
            c.material.uniforms.backgroundRotation.value.setFromMatrix4(
              zp.makeRotationFromEuler(Bp)
            ),
            (c.material.toneMapped = Wu.getTransfer(i.colorSpace) !== cu),
            (h === i && d === i.version && p === t.toneMapping) ||
              ((c.material.needsUpdate = !0),
              (h = i),
              (d = i.version),
              (p = t.toneMapping)),
            c.layers.enableAll(),
            e.unshift(c, c.geometry, c.material, 0, 0, null))
          : i &&
            i.isTexture &&
            (void 0 === l &&
              ((l = new op(
                new Ip(2, 2),
                new fp({
                  name: "BackgroundMaterial",
                  uniforms: up(Fp.background.uniforms),
                  vertexShader: Fp.background.vertexShader,
                  fragmentShader: Fp.background.fragmentShader,
                  side: 0,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )),
              l.geometry.deleteAttribute("normal"),
              Object.defineProperty(l.material, "map", {
                get: function () {
                  return this.uniforms.t2D.value;
                },
              }),
              r.update(l)),
            (l.material.uniforms.t2D.value = i),
            (l.material.uniforms.backgroundIntensity.value =
              n.backgroundIntensity),
            (l.material.toneMapped = Wu.getTransfer(i.colorSpace) !== cu),
            !0 === i.matrixAutoUpdate && i.updateMatrix(),
            l.material.uniforms.uvTransform.value.copy(i.matrix),
            (h === i && d === i.version && p === t.toneMapping) ||
              ((l.material.needsUpdate = !0),
              (h = i),
              (d = i.version),
              (p = t.toneMapping)),
            l.layers.enableAll(),
            e.unshift(l, l.geometry, l.material, 0, 0, null));
      },
    };
  }
  function Vp(t, e) {
    const n = t.getParameter(t.MAX_VERTEX_ATTRIBS),
      i = {},
      r = c(null);
    let s = r,
      a = !1;
    function o(e) {
      return t.bindVertexArray(e);
    }
    function l(e) {
      return t.deleteVertexArray(e);
    }
    function c(t) {
      const e = [],
        i = [],
        r = [];
      for (let t = 0; t < n; t++) (e[t] = 0), (i[t] = 0), (r[t] = 0);
      return {
        geometry: null,
        program: null,
        wireframe: !1,
        newAttributes: e,
        enabledAttributes: i,
        attributeDivisors: r,
        object: t,
        attributes: {},
        index: null,
      };
    }
    function u() {
      const t = s.newAttributes;
      for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
    }
    function h(t) {
      d(t, 0);
    }
    function d(e, n) {
      const i = s.newAttributes,
        r = s.enabledAttributes,
        a = s.attributeDivisors;
      (i[e] = 1),
        0 === r[e] && (t.enableVertexAttribArray(e), (r[e] = 1)),
        a[e] !== n && (t.vertexAttribDivisor(e, n), (a[e] = n));
    }
    function p() {
      const e = s.newAttributes,
        n = s.enabledAttributes;
      for (let i = 0, r = n.length; i < r; i++)
        n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
    }
    function f(e, n, i, r, s, a, o) {
      !0 === o
        ? t.vertexAttribIPointer(e, n, i, s, a)
        : t.vertexAttribPointer(e, n, i, r, s, a);
    }
    function m() {
      g(), (a = !0), s !== r && ((s = r), o(s.object));
    }
    function g() {
      (r.geometry = null), (r.program = null), (r.wireframe = !1);
    }
    return {
      setup: function (n, r, l, m, g) {
        let v = !1;
        const _ = (function (e, n, r) {
          const s = !0 === r.wireframe;
          let a = i[e.id];
          void 0 === a && ((a = {}), (i[e.id] = a));
          let o = a[n.id];
          void 0 === o && ((o = {}), (a[n.id] = o));
          let l = o[s];
          return (
            void 0 === l && ((l = c(t.createVertexArray())), (o[s] = l)), l
          );
        })(m, l, r);
        s !== _ && ((s = _), o(s.object)),
          (v = (function (t, e, n, i) {
            const r = s.attributes,
              a = e.attributes;
            let o = 0;
            const l = n.getAttributes();
            for (const e in l)
              if (l[e].location >= 0) {
                const n = r[e];
                let i = a[e];
                if (
                  (void 0 === i &&
                    ("instanceMatrix" === e &&
                      t.instanceMatrix &&
                      (i = t.instanceMatrix),
                    "instanceColor" === e &&
                      t.instanceColor &&
                      (i = t.instanceColor)),
                  void 0 === n)
                )
                  return !0;
                if (n.attribute !== i) return !0;
                if (i && n.data !== i.data) return !0;
                o++;
              }
            return s.attributesNum !== o || s.index !== i;
          })(n, m, l, g)),
          v &&
            (function (t, e, n, i) {
              const r = {},
                a = e.attributes;
              let o = 0;
              const l = n.getAttributes();
              for (const e in l)
                if (l[e].location >= 0) {
                  let n = a[e];
                  void 0 === n &&
                    ("instanceMatrix" === e &&
                      t.instanceMatrix &&
                      (n = t.instanceMatrix),
                    "instanceColor" === e &&
                      t.instanceColor &&
                      (n = t.instanceColor));
                  const i = {};
                  (i.attribute = n),
                    n && n.data && (i.data = n.data),
                    (r[e] = i),
                    o++;
                }
              (s.attributes = r), (s.attributesNum = o), (s.index = i);
            })(n, m, l, g),
          null !== g && e.update(g, t.ELEMENT_ARRAY_BUFFER),
          (v || a) &&
            ((a = !1),
            (function (n, i, r, s) {
              u();
              const a = s.attributes,
                o = r.getAttributes(),
                l = i.defaultAttributeValues;
              for (const i in o) {
                const r = o[i];
                if (r.location >= 0) {
                  let o = a[i];
                  if (
                    (void 0 === o &&
                      ("instanceMatrix" === i &&
                        n.instanceMatrix &&
                        (o = n.instanceMatrix),
                      "instanceColor" === i &&
                        n.instanceColor &&
                        (o = n.instanceColor)),
                    void 0 !== o)
                  ) {
                    const i = o.normalized,
                      a = o.itemSize,
                      l = e.get(o);
                    if (void 0 === l) continue;
                    const c = l.buffer,
                      u = l.type,
                      p = l.bytesPerElement,
                      m =
                        u === t.INT ||
                        u === t.UNSIGNED_INT ||
                        1013 === o.gpuType;
                    if (o.isInterleavedBufferAttribute) {
                      const e = o.data,
                        l = e.stride,
                        g = o.offset;
                      if (e.isInstancedInterleavedBuffer) {
                        for (let t = 0; t < r.locationSize; t++)
                          d(r.location + t, e.meshPerAttribute);
                        !0 !== n.isInstancedMesh &&
                          void 0 === s._maxInstanceCount &&
                          (s._maxInstanceCount = e.meshPerAttribute * e.count);
                      } else
                        for (let t = 0; t < r.locationSize; t++)
                          h(r.location + t);
                      t.bindBuffer(t.ARRAY_BUFFER, c);
                      for (let t = 0; t < r.locationSize; t++)
                        f(
                          r.location + t,
                          a / r.locationSize,
                          u,
                          i,
                          l * p,
                          (g + (a / r.locationSize) * t) * p,
                          m
                        );
                    } else {
                      if (o.isInstancedBufferAttribute) {
                        for (let t = 0; t < r.locationSize; t++)
                          d(r.location + t, o.meshPerAttribute);
                        !0 !== n.isInstancedMesh &&
                          void 0 === s._maxInstanceCount &&
                          (s._maxInstanceCount = o.meshPerAttribute * o.count);
                      } else
                        for (let t = 0; t < r.locationSize; t++)
                          h(r.location + t);
                      t.bindBuffer(t.ARRAY_BUFFER, c);
                      for (let t = 0; t < r.locationSize; t++)
                        f(
                          r.location + t,
                          a / r.locationSize,
                          u,
                          i,
                          a * p,
                          (a / r.locationSize) * t * p,
                          m
                        );
                    }
                  } else if (void 0 !== l) {
                    const e = l[i];
                    if (void 0 !== e)
                      switch (e.length) {
                        case 2:
                          t.vertexAttrib2fv(r.location, e);
                          break;
                        case 3:
                          t.vertexAttrib3fv(r.location, e);
                          break;
                        case 4:
                          t.vertexAttrib4fv(r.location, e);
                          break;
                        default:
                          t.vertexAttrib1fv(r.location, e);
                      }
                  }
                }
              }
              p();
            })(n, r, l, m),
            null !== g &&
              t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e.get(g).buffer));
      },
      reset: m,
      resetDefaultState: g,
      dispose: function () {
        m();
        for (const t in i) {
          const e = i[t];
          for (const t in e) {
            const n = e[t];
            for (const t in n) l(n[t].object), delete n[t];
            delete e[t];
          }
          delete i[t];
        }
      },
      releaseStatesOfGeometry: function (t) {
        if (void 0 === i[t.id]) return;
        const e = i[t.id];
        for (const t in e) {
          const n = e[t];
          for (const t in n) l(n[t].object), delete n[t];
          delete e[t];
        }
        delete i[t.id];
      },
      releaseStatesOfProgram: function (t) {
        for (const e in i) {
          const n = i[e];
          if (void 0 === n[t.id]) continue;
          const r = n[t.id];
          for (const t in r) l(r[t].object), delete r[t];
          delete n[t.id];
        }
      },
      initAttributes: u,
      enableAttribute: h,
      disableUnusedAttributes: p,
    };
  }
  function Hp(t, e, n) {
    let i;
    function r(e, r, s) {
      0 !== s && (t.drawArraysInstanced(i, e, r, s), n.update(r, i, s));
    }
    (this.setMode = function (t) {
      i = t;
    }),
      (this.render = function (e, r) {
        t.drawArrays(i, e, r), n.update(r, i, 1);
      }),
      (this.renderInstances = r),
      (this.renderMultiDraw = function (t, r, s) {
        if (0 === s) return;
        const a = e.get("WEBGL_multi_draw");
        if (null === a) for (let e = 0; e < s; e++) this.render(t[e], r[e]);
        else {
          a.multiDrawArraysWEBGL(i, t, 0, r, 0, s);
          let e = 0;
          for (let t = 0; t < s; t++) e += r[t];
          n.update(e, i, 1);
        }
      }),
      (this.renderMultiDrawInstances = function (t, s, a, o) {
        if (0 === a) return;
        const l = e.get("WEBGL_multi_draw");
        if (null === l) for (let e = 0; e < t.length; e++) r(t[e], s[e], o[e]);
        else {
          l.multiDrawArraysInstancedWEBGL(i, t, 0, s, 0, o, 0, a);
          let e = 0;
          for (let t = 0; t < a; t++) e += s[t];
          for (let t = 0; t < o.length; t++) n.update(e, i, o[t]);
        }
      });
  }
  function Gp(t, e, n, i) {
    let r;
    function s(e) {
      if ("highp" === e) {
        if (
          t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision >
            0 &&
          t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
            .precision > 0
        )
          return "highp";
        e = "mediump";
      }
      return "mediump" === e &&
        t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision >
          0 &&
        t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT)
          .precision > 0
        ? "mediump"
        : "lowp";
    }
    let a = void 0 !== n.precision ? n.precision : "highp";
    const o = s(a);
    o !== a &&
      (console.warn(
        "THREE.WebGLRenderer:",
        a,
        "not supported, using",
        o,
        "instead."
      ),
      (a = o));
    const l = !0 === n.logarithmicDepthBuffer,
      c = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
      u = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    return {
      isWebGL2: !0,
      getMaxAnisotropy: function () {
        if (void 0 !== r) return r;
        if (!0 === e.has("EXT_texture_filter_anisotropic")) {
          const n = e.get("EXT_texture_filter_anisotropic");
          r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else r = 0;
        return r;
      },
      getMaxPrecision: s,
      textureFormatReadable: function (e) {
        return (
          e === qc ||
          i.convert(e) === t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT)
        );
      },
      textureTypeReadable: function (n) {
        const r =
          n === Wc &&
          (e.has("EXT_color_buffer_half_float") ||
            e.has("EXT_color_buffer_float"));
        return !(
          n !== Vc &&
          i.convert(n) !== t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE) &&
          n !== Gc &&
          !r
        );
      },
      precision: a,
      logarithmicDepthBuffer: l,
      maxTextures: c,
      maxVertexTextures: u,
      maxTextureSize: t.getParameter(t.MAX_TEXTURE_SIZE),
      maxCubemapSize: t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
      maxAttributes: t.getParameter(t.MAX_VERTEX_ATTRIBS),
      maxVertexUniforms: t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
      maxVaryings: t.getParameter(t.MAX_VARYING_VECTORS),
      maxFragmentUniforms: t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
      vertexTextures: u > 0,
      maxSamples: t.getParameter(t.MAX_SAMPLES),
    };
  }
  function Wp(t) {
    const e = this;
    let n = null,
      i = 0,
      r = !1,
      s = !1;
    const a = new wp(),
      o = new Uu(),
      l = { value: null, needsUpdate: !1 };
    function c(t, n, i, r) {
      const s = null !== t ? t.length : 0;
      let c = null;
      if (0 !== s) {
        if (((c = l.value), !0 !== r || null === c)) {
          const e = i + 4 * s,
            r = n.matrixWorldInverse;
          o.getNormalMatrix(r),
            (null === c || c.length < e) && (c = new Float32Array(e));
          for (let e = 0, n = i; e !== s; ++e, n += 4)
            a.copy(t[e]).applyMatrix4(r, o),
              a.normal.toArray(c, n),
              (c[n + 3] = a.constant);
        }
        (l.value = c), (l.needsUpdate = !0);
      }
      return (e.numPlanes = s), (e.numIntersection = 0), c;
    }
    (this.uniform = l),
      (this.numPlanes = 0),
      (this.numIntersection = 0),
      (this.init = function (t, e) {
        const n = 0 !== t.length || e || 0 !== i || r;
        return (r = e), (i = t.length), n;
      }),
      (this.beginShadows = function () {
        (s = !0), c(null);
      }),
      (this.endShadows = function () {
        s = !1;
      }),
      (this.setGlobalState = function (t, e) {
        n = c(t, e, 0);
      }),
      (this.setState = function (a, o, u) {
        const h = a.clippingPlanes,
          d = a.clipIntersection,
          p = a.clipShadows,
          f = t.get(a);
        if (!r || null === h || 0 === h.length || (s && !p))
          s
            ? c(null)
            : (l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
              (e.numPlanes = i),
              (e.numIntersection = 0));
        else {
          const t = s ? 0 : i,
            e = 4 * t;
          let r = f.clippingState || null;
          (l.value = r), (r = c(h, o, e, u));
          for (let t = 0; t !== e; ++t) r[t] = n[t];
          (f.clippingState = r),
            (this.numIntersection = d ? this.numPlanes : 0),
            (this.numPlanes += t);
        }
      });
  }
  function Xp(t) {
    let e = new WeakMap();
    function n(t, e) {
      return 303 === e ? (t.mapping = Ac) : 304 === e && (t.mapping = Rc), t;
    }
    function i(t) {
      const n = t.target;
      n.removeEventListener("dispose", i);
      const r = e.get(n);
      void 0 !== r && (e.delete(n), r.dispose());
    }
    return {
      get: function (r) {
        if (r && r.isTexture) {
          const s = r.mapping;
          if (303 === s || 304 === s) {
            if (e.has(r)) return n(e.get(r).texture, r.mapping);
            {
              const s = r.image;
              if (s && s.height > 0) {
                const a = new Ep(s.height);
                return (
                  a.fromEquirectangularTexture(t, r),
                  e.set(r, a),
                  r.addEventListener("dispose", i),
                  n(a.texture, r.mapping)
                );
              }
              return null;
            }
          }
        }
        return r;
      },
      dispose: function () {
        e = new WeakMap();
      },
    };
  }
  class qp extends mp {
    constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
      super(),
        (this.isOrthographicCamera = !0),
        (this.type = "OrthographicCamera"),
        (this.zoom = 1),
        (this.view = null),
        (this.left = t),
        (this.right = e),
        (this.top = n),
        (this.bottom = i),
        (this.near = r),
        (this.far = s),
        this.updateProjectionMatrix();
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        (this.left = t.left),
        (this.right = t.right),
        (this.top = t.top),
        (this.bottom = t.bottom),
        (this.near = t.near),
        (this.far = t.far),
        (this.zoom = t.zoom),
        (this.view = null === t.view ? null : Object.assign({}, t.view)),
        this
      );
    }
    setViewOffset(t, e, n, i, r, s) {
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
        (this.view.enabled = !0),
        (this.view.fullWidth = t),
        (this.view.fullHeight = e),
        (this.view.offsetX = n),
        (this.view.offsetY = i),
        (this.view.width = r),
        (this.view.height = s),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const t = (this.right - this.left) / (2 * this.zoom),
        e = (this.top - this.bottom) / (2 * this.zoom),
        n = (this.right + this.left) / 2,
        i = (this.top + this.bottom) / 2;
      let r = n - t,
        s = n + t,
        a = i + e,
        o = i - e;
      if (null !== this.view && this.view.enabled) {
        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
          e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        (r += t * this.view.offsetX),
          (s = r + t * this.view.width),
          (a -= e * this.view.offsetY),
          (o = a - e * this.view.height);
      }
      this.projectionMatrix.makeOrthographic(
        r,
        s,
        a,
        o,
        this.near,
        this.far,
        this.coordinateSystem
      ),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        (e.object.zoom = this.zoom),
        (e.object.left = this.left),
        (e.object.right = this.right),
        (e.object.top = this.top),
        (e.object.bottom = this.bottom),
        (e.object.near = this.near),
        (e.object.far = this.far),
        null !== this.view && (e.object.view = Object.assign({}, this.view)),
        e
      );
    }
  }
  const jp = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
    Yp = new qp(),
    Kp = new bd();
  let Zp = null,
    Jp = 0,
    $p = 0,
    Qp = !1;
  const tf = (1 + Math.sqrt(5)) / 2,
    ef = 1 / tf,
    nf = [
      new ah(-tf, ef, 0),
      new ah(tf, ef, 0),
      new ah(-ef, 0, tf),
      new ah(ef, 0, tf),
      new ah(0, tf, -ef),
      new ah(0, tf, ef),
      new ah(-1, 1, -1),
      new ah(1, 1, -1),
      new ah(-1, 1, 1),
      new ah(1, 1, 1),
    ];
  class rf {
    constructor(t) {
      (this._renderer = t),
        (this._pingPongRenderTarget = null),
        (this._lodMax = 0),
        (this._cubeSize = 0),
        (this._lodPlanes = []),
        (this._sizeLods = []),
        (this._sigmas = []),
        (this._blurMaterial = null),
        (this._cubemapMaterial = null),
        (this._equirectMaterial = null),
        this._compileMaterial(this._blurMaterial);
    }
    fromScene(t, e = 0, n = 0.1, i = 100) {
      (Zp = this._renderer.getRenderTarget()),
        (Jp = this._renderer.getActiveCubeFace()),
        ($p = this._renderer.getActiveMipmapLevel()),
        (Qp = this._renderer.xr.enabled),
        (this._renderer.xr.enabled = !1),
        this._setSize(256);
      const r = this._allocateTargets();
      return (
        (r.depthBuffer = !0),
        this._sceneToCubeUV(t, n, i, r),
        e > 0 && this._blur(r, 0, 0, e),
        this._applyPMREM(r),
        this._cleanup(r),
        r
      );
    }
    fromEquirectangular(t, e = null) {
      return this._fromTexture(t, e);
    }
    fromCubemap(t, e = null) {
      return this._fromTexture(t, e);
    }
    compileCubemapShader() {
      null === this._cubemapMaterial &&
        ((this._cubemapMaterial = lf()),
        this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      null === this._equirectMaterial &&
        ((this._equirectMaterial = of()),
        this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(),
        null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
        null !== this._equirectMaterial && this._equirectMaterial.dispose();
    }
    _setSize(t) {
      (this._lodMax = Math.floor(Math.log2(t))),
        (this._cubeSize = Math.pow(2, this._lodMax));
    }
    _dispose() {
      null !== this._blurMaterial && this._blurMaterial.dispose(),
        null !== this._pingPongRenderTarget &&
          this._pingPongRenderTarget.dispose();
      for (let t = 0; t < this._lodPlanes.length; t++)
        this._lodPlanes[t].dispose();
    }
    _cleanup(t) {
      this._renderer.setRenderTarget(Zp, Jp, $p),
        (this._renderer.xr.enabled = Qp),
        (t.scissorTest = !1),
        af(t, 0, 0, t.width, t.height);
    }
    _fromTexture(t, e) {
      t.mapping === Ac || t.mapping === Rc
        ? this._setSize(
            0 === t.image.length
              ? 16
              : t.image[0].width || t.image[0].image.width
          )
        : this._setSize(t.image.width / 4),
        (Zp = this._renderer.getRenderTarget()),
        (Jp = this._renderer.getActiveCubeFace()),
        ($p = this._renderer.getActiveMipmapLevel()),
        (Qp = this._renderer.xr.enabled),
        (this._renderer.xr.enabled = !1);
      const n = e || this._allocateTargets();
      return (
        this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
      );
    }
    _allocateTargets() {
      const t = 3 * Math.max(this._cubeSize, 112),
        e = 4 * this._cubeSize,
        n = {
          magFilter: Bc,
          minFilter: Bc,
          generateMipmaps: !1,
          type: Wc,
          format: qc,
          colorSpace: su,
          depthBuffer: !1,
        },
        i = sf(t, e, n);
      if (
        null === this._pingPongRenderTarget ||
        this._pingPongRenderTarget.width !== t ||
        this._pingPongRenderTarget.height !== e
      ) {
        null !== this._pingPongRenderTarget && this._dispose(),
          (this._pingPongRenderTarget = sf(t, e, n));
        const { _lodMax: i } = this;
        ({
          sizeLods: this._sizeLods,
          lodPlanes: this._lodPlanes,
          sigmas: this._sigmas,
        } = (function (t) {
          const e = [],
            n = [],
            i = [];
          let r = t;
          const s = t - 4 + 1 + jp.length;
          for (let a = 0; a < s; a++) {
            const s = Math.pow(2, r);
            n.push(s);
            let o = 1 / s;
            a > t - 4 ? (o = jp[a - t + 4 - 1]) : 0 === a && (o = 0), i.push(o);
            const l = 1 / (s - 2),
              c = -l,
              u = 1 + l,
              h = [c, c, u, c, u, u, c, c, u, u, c, u],
              d = 6,
              p = 6,
              f = 3,
              m = 2,
              g = 1,
              v = new Float32Array(f * p * d),
              _ = new Float32Array(m * p * d),
              x = new Float32Array(g * p * d);
            for (let t = 0; t < d; t++) {
              const e = ((t % 3) * 2) / 3 - 1,
                n = t > 2 ? 0 : -1,
                i = [
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n + 1,
                  0,
                ];
              v.set(i, f * p * t), _.set(h, m * p * t);
              const r = [t, t, t, t, t, t];
              x.set(r, g * p * t);
            }
            const y = new Gd();
            y.setAttribute("position", new Ld(v, f)),
              y.setAttribute("uv", new Ld(_, m)),
              y.setAttribute("faceIndex", new Ld(x, g)),
              e.push(y),
              r > 4 && r--;
          }
          return { lodPlanes: e, sizeLods: n, sigmas: i };
        })(i)),
          (this._blurMaterial = (function (t, e, n) {
            const i = new Float32Array(20),
              r = new ah(0, 1, 0);
            return new fp({
              name: "SphericalGaussianBlur",
              defines: {
                n: 20,
                CUBEUV_TEXEL_WIDTH: 1 / e,
                CUBEUV_TEXEL_HEIGHT: 1 / n,
                CUBEUV_MAX_MIP: `${t}.0`,
              },
              uniforms: {
                envMap: { value: null },
                samples: { value: 1 },
                weights: { value: i },
                latitudinal: { value: !1 },
                dTheta: { value: 0 },
                mipInt: { value: 0 },
                poleAxis: { value: r },
              },
              vertexShader:
                "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
              fragmentShader:
                "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
              blending: 0,
              depthTest: !1,
              depthWrite: !1,
            });
          })(i, t, e));
      }
      return i;
    }
    _compileMaterial(t) {
      const e = new op(this._lodPlanes[0], t);
      this._renderer.compile(e, Yp);
    }
    _sceneToCubeUV(t, e, n, i) {
      const r = new xp(90, 1, e, n),
        s = [1, -1, 1, 1, 1, 1],
        a = [1, 1, 1, -1, -1, -1],
        o = this._renderer,
        l = o.autoClear,
        c = o.toneMapping;
      o.getClearColor(Kp), (o.toneMapping = Sc), (o.autoClear = !1);
      const u = new Ad({
          name: "PMREM.Background",
          side: 1,
          depthWrite: !1,
          depthTest: !1,
        }),
        h = new op(new cp(), u);
      let d = !1;
      const p = t.background;
      p
        ? p.isColor && (u.color.copy(p), (t.background = null), (d = !0))
        : (u.color.copy(Kp), (d = !0));
      for (let e = 0; e < 6; e++) {
        const n = e % 3;
        0 === n
          ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0))
          : 1 === n
          ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0))
          : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e]));
        const l = this._cubeSize;
        af(i, n * l, e > 2 ? l : 0, l, l),
          o.setRenderTarget(i),
          d && o.render(h, r),
          o.render(t, r);
      }
      h.geometry.dispose(),
        h.material.dispose(),
        (o.toneMapping = c),
        (o.autoClear = l),
        (t.background = p);
    }
    _textureToCubeUV(t, e) {
      const n = this._renderer,
        i = t.mapping === Ac || t.mapping === Rc;
      i
        ? (null === this._cubemapMaterial && (this._cubemapMaterial = lf()),
          (this._cubemapMaterial.uniforms.flipEnvMap.value =
            !1 === t.isRenderTargetTexture ? -1 : 1))
        : null === this._equirectMaterial && (this._equirectMaterial = of());
      const r = i ? this._cubemapMaterial : this._equirectMaterial,
        s = new op(this._lodPlanes[0], r);
      r.uniforms.envMap.value = t;
      const a = this._cubeSize;
      af(e, 0, 0, 3 * a, 2 * a), n.setRenderTarget(e), n.render(s, Yp);
    }
    _applyPMREM(t) {
      const e = this._renderer,
        n = e.autoClear;
      e.autoClear = !1;
      const i = this._lodPlanes.length;
      for (let e = 1; e < i; e++) {
        const n = Math.sqrt(
            this._sigmas[e] * this._sigmas[e] -
              this._sigmas[e - 1] * this._sigmas[e - 1]
          ),
          r = nf[(i - e - 1) % nf.length];
        this._blur(t, e - 1, e, n, r);
      }
      e.autoClear = n;
    }
    _blur(t, e, n, i, r) {
      const s = this._pingPongRenderTarget;
      this._halfBlur(t, s, e, n, i, "latitudinal", r),
        this._halfBlur(s, t, n, n, i, "longitudinal", r);
    }
    _halfBlur(t, e, n, i, r, s, a) {
      const o = this._renderer,
        l = this._blurMaterial;
      "latitudinal" !== s &&
        "longitudinal" !== s &&
        console.error(
          "blur direction must be either latitudinal or longitudinal!"
        );
      const c = new op(this._lodPlanes[i], l),
        u = l.uniforms,
        h = this._sizeLods[n] - 1,
        d = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
        p = r / d,
        f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
      f > 20 &&
        console.warn(
          `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
        );
      const m = [];
      let g = 0;
      for (let t = 0; t < 20; ++t) {
        const e = t / p,
          n = Math.exp((-e * e) / 2);
        m.push(n), 0 === t ? (g += n) : t < f && (g += 2 * n);
      }
      for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
      (u.envMap.value = t.texture),
        (u.samples.value = f),
        (u.weights.value = m),
        (u.latitudinal.value = "latitudinal" === s),
        a && (u.poleAxis.value = a);
      const { _lodMax: v } = this;
      (u.dTheta.value = d), (u.mipInt.value = v - n);
      const _ = this._sizeLods[i];
      af(
        e,
        3 * _ * (i > v - 4 ? i - v + 4 : 0),
        4 * (this._cubeSize - _),
        3 * _,
        2 * _
      ),
        o.setRenderTarget(e),
        o.render(c, Yp);
    }
  }
  function sf(t, e, n) {
    const i = new nh(t, e, n);
    return (
      (i.texture.mapping = Pc),
      (i.texture.name = "PMREM.cubeUv"),
      (i.scissorTest = !0),
      i
    );
  }
  function af(t, e, n, i, r) {
    t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
  }
  function of() {
    return new fp({
      name: "EquirectangularToCubeUV",
      uniforms: { envMap: { value: null } },
      vertexShader:
        "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
      fragmentShader:
        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
      blending: 0,
      depthTest: !1,
      depthWrite: !1,
    });
  }
  function lf() {
    return new fp({
      name: "CubemapToCubeUV",
      uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
      vertexShader:
        "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
      fragmentShader:
        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
      blending: 0,
      depthTest: !1,
      depthWrite: !1,
    });
  }
  function cf(t) {
    let e = new WeakMap(),
      n = null;
    function i(t) {
      const n = t.target;
      n.removeEventListener("dispose", i);
      const r = e.get(n);
      void 0 !== r && (e.delete(n), r.dispose());
    }
    return {
      get: function (r) {
        if (r && r.isTexture) {
          const s = r.mapping,
            a = 303 === s || 304 === s,
            o = s === Ac || s === Rc;
          if (a || o) {
            let s = e.get(r);
            const l = void 0 !== s ? s.texture.pmremVersion : 0;
            if (r.isRenderTargetTexture && r.pmremVersion !== l)
              return (
                null === n && (n = new rf(t)),
                (s = a ? n.fromEquirectangular(r, s) : n.fromCubemap(r, s)),
                (s.texture.pmremVersion = r.pmremVersion),
                e.set(r, s),
                s.texture
              );
            if (void 0 !== s) return s.texture;
            {
              const l = r.image;
              return (a && l && l.height > 0) ||
                (o &&
                  l &&
                  (function (t) {
                    let e = 0;
                    for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                    return 6 === e;
                  })(l))
                ? (null === n && (n = new rf(t)),
                  (s = a ? n.fromEquirectangular(r) : n.fromCubemap(r)),
                  (s.texture.pmremVersion = r.pmremVersion),
                  e.set(r, s),
                  r.addEventListener("dispose", i),
                  s.texture)
                : null;
            }
          }
        }
        return r;
      },
      dispose: function () {
        (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
      },
    };
  }
  function uf(t) {
    const e = {};
    function n(n) {
      if (void 0 !== e[n]) return e[n];
      let i;
      switch (n) {
        case "WEBGL_depth_texture":
          i =
            t.getExtension("WEBGL_depth_texture") ||
            t.getExtension("MOZ_WEBGL_depth_texture") ||
            t.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          i =
            t.getExtension("EXT_texture_filter_anisotropic") ||
            t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
            t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          i =
            t.getExtension("WEBGL_compressed_texture_s3tc") ||
            t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
            t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          i =
            t.getExtension("WEBGL_compressed_texture_pvrtc") ||
            t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          i = t.getExtension(n);
      }
      return (e[n] = i), i;
    }
    return {
      has: function (t) {
        return null !== n(t);
      },
      init: function () {
        n("EXT_color_buffer_float"),
          n("WEBGL_clip_cull_distance"),
          n("OES_texture_float_linear"),
          n("EXT_color_buffer_half_float"),
          n("WEBGL_multisampled_render_to_texture"),
          n("WEBGL_render_shared_exponent");
      },
      get: function (t) {
        const e = n(t);
        return (
          null === e &&
            console.warn(
              "THREE.WebGLRenderer: " + t + " extension not supported."
            ),
          e
        );
      },
    };
  }
  function hf(t, e, n, i) {
    const r = {},
      s = new WeakMap();
    function a(t) {
      const o = t.target;
      null !== o.index && e.remove(o.index);
      for (const t in o.attributes) e.remove(o.attributes[t]);
      for (const t in o.morphAttributes) {
        const n = o.morphAttributes[t];
        for (let t = 0, i = n.length; t < i; t++) e.remove(n[t]);
      }
      o.removeEventListener("dispose", a), delete r[o.id];
      const l = s.get(o);
      l && (e.remove(l), s.delete(o)),
        i.releaseStatesOfGeometry(o),
        !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
        n.memory.geometries--;
    }
    function o(t) {
      const n = [],
        i = t.index,
        r = t.attributes.position;
      let a = 0;
      if (null !== i) {
        const t = i.array;
        a = i.version;
        for (let e = 0, i = t.length; e < i; e += 3) {
          const i = t[e + 0],
            r = t[e + 1],
            s = t[e + 2];
          n.push(i, r, r, s, s, i);
        }
      } else {
        if (void 0 === r) return;
        {
          const t = r.array;
          a = r.version;
          for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
            const t = e + 0,
              i = e + 1,
              r = e + 2;
            n.push(t, i, i, r, r, t);
          }
        }
      }
      const o = new (Fu(n) ? Ud : Id)(n, 1);
      o.version = a;
      const l = s.get(t);
      l && e.remove(l), s.set(t, o);
    }
    return {
      get: function (t, e) {
        return (
          !0 === r[e.id] ||
            (e.addEventListener("dispose", a),
            (r[e.id] = !0),
            n.memory.geometries++),
          e
        );
      },
      update: function (n) {
        const i = n.attributes;
        for (const n in i) e.update(i[n], t.ARRAY_BUFFER);
        const r = n.morphAttributes;
        for (const n in r) {
          const i = r[n];
          for (let n = 0, r = i.length; n < r; n++)
            e.update(i[n], t.ARRAY_BUFFER);
        }
      },
      getWireframeAttribute: function (t) {
        const e = s.get(t);
        if (e) {
          const n = t.index;
          null !== n && e.version < n.version && o(t);
        } else o(t);
        return s.get(t);
      },
    };
  }
  function df(t, e, n) {
    let i, r, s;
    function a(e, a, o) {
      0 !== o &&
        (t.drawElementsInstanced(i, a, r, e * s, o), n.update(a, i, o));
    }
    (this.setMode = function (t) {
      i = t;
    }),
      (this.setIndex = function (t) {
        (r = t.type), (s = t.bytesPerElement);
      }),
      (this.render = function (e, a) {
        t.drawElements(i, a, r, e * s), n.update(a, i, 1);
      }),
      (this.renderInstances = a),
      (this.renderMultiDraw = function (t, a, o) {
        if (0 === o) return;
        const l = e.get("WEBGL_multi_draw");
        if (null === l) for (let e = 0; e < o; e++) this.render(t[e] / s, a[e]);
        else {
          l.multiDrawElementsWEBGL(i, a, 0, r, t, 0, o);
          let e = 0;
          for (let t = 0; t < o; t++) e += a[t];
          n.update(e, i, 1);
        }
      }),
      (this.renderMultiDrawInstances = function (t, o, l, c) {
        if (0 === l) return;
        const u = e.get("WEBGL_multi_draw");
        if (null === u)
          for (let e = 0; e < t.length; e++) a(t[e] / s, o[e], c[e]);
        else {
          u.multiDrawElementsInstancedWEBGL(i, o, 0, r, t, 0, c, 0, l);
          let e = 0;
          for (let t = 0; t < l; t++) e += o[t];
          for (let t = 0; t < c.length; t++) n.update(e, i, c[t]);
        }
      });
  }
  function pf(t) {
    const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: e,
      programs: null,
      autoReset: !0,
      reset: function () {
        (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
      },
      update: function (n, i, r) {
        switch ((e.calls++, i)) {
          case t.TRIANGLES:
            e.triangles += r * (n / 3);
            break;
          case t.LINES:
            e.lines += r * (n / 2);
            break;
          case t.LINE_STRIP:
            e.lines += r * (n - 1);
            break;
          case t.LINE_LOOP:
            e.lines += r * n;
            break;
          case t.POINTS:
            e.points += r * n;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", i);
        }
      },
    };
  }
  function ff(t, e, n) {
    const i = new WeakMap(),
      r = new th();
    return {
      update: function (s, a, o) {
        const l = s.morphTargetInfluences,
          c =
            a.morphAttributes.position ||
            a.morphAttributes.normal ||
            a.morphAttributes.color,
          u = void 0 !== c ? c.length : 0;
        let h = i.get(a);
        if (void 0 === h || h.count !== u) {
          void 0 !== h && h.texture.dispose();
          const d = void 0 !== a.morphAttributes.position,
            p = void 0 !== a.morphAttributes.normal,
            f = void 0 !== a.morphAttributes.color,
            m = a.morphAttributes.position || [],
            g = a.morphAttributes.normal || [],
            v = a.morphAttributes.color || [];
          let _ = 0;
          !0 === d && (_ = 1), !0 === p && (_ = 2), !0 === f && (_ = 3);
          let x = a.attributes.position.count * _,
            y = 1;
          x > e.maxTextureSize &&
            ((y = Math.ceil(x / e.maxTextureSize)), (x = e.maxTextureSize));
          const S = new Float32Array(x * y * 4 * u),
            M = new ih(S, x, y, u);
          (M.type = Gc), (M.needsUpdate = !0);
          const E = 4 * _;
          for (let b = 0; b < u; b++) {
            const D = m[b],
              w = g[b],
              C = v[b],
              A = x * y * 4 * b;
            for (let R = 0; R < D.count; R++) {
              const P = R * E;
              !0 === d &&
                (r.fromBufferAttribute(D, R),
                (S[A + P + 0] = r.x),
                (S[A + P + 1] = r.y),
                (S[A + P + 2] = r.z),
                (S[A + P + 3] = 0)),
                !0 === p &&
                  (r.fromBufferAttribute(w, R),
                  (S[A + P + 4] = r.x),
                  (S[A + P + 5] = r.y),
                  (S[A + P + 6] = r.z),
                  (S[A + P + 7] = 0)),
                !0 === f &&
                  (r.fromBufferAttribute(C, R),
                  (S[A + P + 8] = r.x),
                  (S[A + P + 9] = r.y),
                  (S[A + P + 10] = r.z),
                  (S[A + P + 11] = 4 === C.itemSize ? r.w : 1));
            }
          }
          function T() {
            M.dispose(), i.delete(a), a.removeEventListener("dispose", T);
          }
          (h = { count: u, texture: M, size: new Iu(x, y) }),
            i.set(a, h),
            a.addEventListener("dispose", T);
        }
        if (!0 === s.isInstancedMesh && null !== s.morphTexture)
          o.getUniforms().setValue(t, "morphTexture", s.morphTexture, n);
        else {
          let L = 0;
          for (let U = 0; U < l.length; U++) L += l[U];
          const I = a.morphTargetsRelative ? 1 : 1 - L;
          o.getUniforms().setValue(t, "morphTargetBaseInfluence", I),
            o.getUniforms().setValue(t, "morphTargetInfluences", l);
        }
        o.getUniforms().setValue(t, "morphTargetsTexture", h.texture, n),
          o.getUniforms().setValue(t, "morphTargetsTextureSize", h.size);
      },
    };
  }
  function mf(t, e, n, i) {
    let r = new WeakMap();
    function s(t) {
      const e = t.target;
      e.removeEventListener("dispose", s),
        n.remove(e.instanceMatrix),
        null !== e.instanceColor && n.remove(e.instanceColor);
    }
    return {
      update: function (a) {
        const o = i.render.frame,
          l = a.geometry,
          c = e.get(a, l);
        if (
          (r.get(c) !== o && (e.update(c), r.set(c, o)),
          a.isInstancedMesh &&
            (!1 === a.hasEventListener("dispose", s) &&
              a.addEventListener("dispose", s),
            r.get(a) !== o &&
              (n.update(a.instanceMatrix, t.ARRAY_BUFFER),
              null !== a.instanceColor &&
                n.update(a.instanceColor, t.ARRAY_BUFFER),
              r.set(a, o))),
          a.isSkinnedMesh)
        ) {
          const t = a.skeleton;
          r.get(t) !== o && (t.update(), r.set(t, o));
        }
        return c;
      },
      dispose: function () {
        r = new WeakMap();
      },
    };
  }
  class gf extends Qu {
    constructor(t, e, n, i, r, s, a, o, l, c) {
      if ((c = void 0 !== c ? c : jc) !== jc && c !== Yc)
        throw new Error(
          "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
        );
      void 0 === n && c === jc && (n = Hc),
        void 0 === n && c === Yc && (n = Xc),
        super(null, i, r, s, a, o, c, n, l),
        (this.isDepthTexture = !0),
        (this.image = { width: t, height: e }),
        (this.magFilter = void 0 !== a ? a : Nc),
        (this.minFilter = void 0 !== o ? o : Nc),
        (this.flipY = !1),
        (this.generateMipmaps = !1),
        (this.compareFunction = null);
    }
    copy(t) {
      return super.copy(t), (this.compareFunction = t.compareFunction), this;
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        null !== this.compareFunction &&
          (e.compareFunction = this.compareFunction),
        e
      );
    }
  }
  const vf = new Qu(),
    _f = new gf(1, 1);
  _f.compareFunction = 515;
  const xf = new ih(),
    yf = new rh(),
    Sf = new Mp(),
    Mf = [],
    Ef = [],
    Tf = new Float32Array(16),
    bf = new Float32Array(9),
    Df = new Float32Array(4);
  function wf(t, e, n) {
    const i = t[0];
    if (i <= 0 || i > 0) return t;
    const r = e * n;
    let s = Mf[r];
    if ((void 0 === s && ((s = new Float32Array(r)), (Mf[r] = s)), 0 !== e)) {
      i.toArray(s, 0);
      for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r);
    }
    return s;
  }
  function Cf(t, e) {
    if (t.length !== e.length) return !1;
    for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
    return !0;
  }
  function Af(t, e) {
    for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
  }
  function Rf(t, e) {
    let n = Ef[e];
    void 0 === n && ((n = new Int32Array(e)), (Ef[e] = n));
    for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
    return n;
  }
  function Pf(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
  }
  function Lf(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y) ||
        (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
    else {
      if (Cf(n, e)) return;
      t.uniform2fv(this.addr, e), Af(n, e);
    }
  }
  function If(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
        (t.uniform3f(this.addr, e.x, e.y, e.z),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z));
    else if (void 0 !== e.r)
      (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
        (t.uniform3f(this.addr, e.r, e.g, e.b),
        (n[0] = e.r),
        (n[1] = e.g),
        (n[2] = e.b));
    else {
      if (Cf(n, e)) return;
      t.uniform3fv(this.addr, e), Af(n, e);
    }
  }
  function Uf(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
        (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z),
        (n[3] = e.w));
    else {
      if (Cf(n, e)) return;
      t.uniform4fv(this.addr, e), Af(n, e);
    }
  }
  function Nf(t, e) {
    const n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (Cf(n, e)) return;
      t.uniformMatrix2fv(this.addr, !1, e), Af(n, e);
    } else {
      if (Cf(n, i)) return;
      Df.set(i), t.uniformMatrix2fv(this.addr, !1, Df), Af(n, i);
    }
  }
  function Ff(t, e) {
    const n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (Cf(n, e)) return;
      t.uniformMatrix3fv(this.addr, !1, e), Af(n, e);
    } else {
      if (Cf(n, i)) return;
      bf.set(i), t.uniformMatrix3fv(this.addr, !1, bf), Af(n, i);
    }
  }
  function Of(t, e) {
    const n = this.cache,
      i = e.elements;
    if (void 0 === i) {
      if (Cf(n, e)) return;
      t.uniformMatrix4fv(this.addr, !1, e), Af(n, e);
    } else {
      if (Cf(n, i)) return;
      Tf.set(i), t.uniformMatrix4fv(this.addr, !1, Tf), Af(n, i);
    }
  }
  function Bf(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
  }
  function zf(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y) ||
        (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
    else {
      if (Cf(n, e)) return;
      t.uniform2iv(this.addr, e), Af(n, e);
    }
  }
  function kf(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
        (t.uniform3i(this.addr, e.x, e.y, e.z),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z));
    else {
      if (Cf(n, e)) return;
      t.uniform3iv(this.addr, e), Af(n, e);
    }
  }
  function Vf(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
        (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z),
        (n[3] = e.w));
    else {
      if (Cf(n, e)) return;
      t.uniform4iv(this.addr, e), Af(n, e);
    }
  }
  function Hf(t, e) {
    const n = this.cache;
    n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
  }
  function Gf(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y) ||
        (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
    else {
      if (Cf(n, e)) return;
      t.uniform2uiv(this.addr, e), Af(n, e);
    }
  }
  function Wf(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
        (t.uniform3ui(this.addr, e.x, e.y, e.z),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z));
    else {
      if (Cf(n, e)) return;
      t.uniform3uiv(this.addr, e), Af(n, e);
    }
  }
  function Xf(t, e) {
    const n = this.cache;
    if (void 0 !== e.x)
      (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
        (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        (n[0] = e.x),
        (n[1] = e.y),
        (n[2] = e.z),
        (n[3] = e.w));
    else {
      if (Cf(n, e)) return;
      t.uniform4uiv(this.addr, e), Af(n, e);
    }
  }
  function qf(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r));
    const s = this.type === t.SAMPLER_2D_SHADOW ? _f : vf;
    n.setTexture2D(e || s, r);
  }
  function jf(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture3D(e || yf, r);
  }
  function Yf(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTextureCube(e || Sf, r);
  }
  function Kf(t, e, n) {
    const i = this.cache,
      r = n.allocateTextureUnit();
    i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
      n.setTexture2DArray(e || xf, r);
  }
  function Zf(t, e) {
    t.uniform1fv(this.addr, e);
  }
  function Jf(t, e) {
    const n = wf(e, this.size, 2);
    t.uniform2fv(this.addr, n);
  }
  function $f(t, e) {
    const n = wf(e, this.size, 3);
    t.uniform3fv(this.addr, n);
  }
  function Qf(t, e) {
    const n = wf(e, this.size, 4);
    t.uniform4fv(this.addr, n);
  }
  function tm(t, e) {
    const n = wf(e, this.size, 4);
    t.uniformMatrix2fv(this.addr, !1, n);
  }
  function em(t, e) {
    const n = wf(e, this.size, 9);
    t.uniformMatrix3fv(this.addr, !1, n);
  }
  function nm(t, e) {
    const n = wf(e, this.size, 16);
    t.uniformMatrix4fv(this.addr, !1, n);
  }
  function im(t, e) {
    t.uniform1iv(this.addr, e);
  }
  function rm(t, e) {
    t.uniform2iv(this.addr, e);
  }
  function sm(t, e) {
    t.uniform3iv(this.addr, e);
  }
  function am(t, e) {
    t.uniform4iv(this.addr, e);
  }
  function om(t, e) {
    t.uniform1uiv(this.addr, e);
  }
  function lm(t, e) {
    t.uniform2uiv(this.addr, e);
  }
  function cm(t, e) {
    t.uniform3uiv(this.addr, e);
  }
  function um(t, e) {
    t.uniform4uiv(this.addr, e);
  }
  function hm(t, e, n) {
    const i = this.cache,
      r = e.length,
      s = Rf(n, r);
    Cf(i, s) || (t.uniform1iv(this.addr, s), Af(i, s));
    for (let t = 0; t !== r; ++t) n.setTexture2D(e[t] || vf, s[t]);
  }
  function dm(t, e, n) {
    const i = this.cache,
      r = e.length,
      s = Rf(n, r);
    Cf(i, s) || (t.uniform1iv(this.addr, s), Af(i, s));
    for (let t = 0; t !== r; ++t) n.setTexture3D(e[t] || yf, s[t]);
  }
  function pm(t, e, n) {
    const i = this.cache,
      r = e.length,
      s = Rf(n, r);
    Cf(i, s) || (t.uniform1iv(this.addr, s), Af(i, s));
    for (let t = 0; t !== r; ++t) n.setTextureCube(e[t] || Sf, s[t]);
  }
  function fm(t, e, n) {
    const i = this.cache,
      r = e.length,
      s = Rf(n, r);
    Cf(i, s) || (t.uniform1iv(this.addr, s), Af(i, s));
    for (let t = 0; t !== r; ++t) n.setTexture2DArray(e[t] || xf, s[t]);
  }
  class mm {
    constructor(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.type = e.type),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return Pf;
            case 35664:
              return Lf;
            case 35665:
              return If;
            case 35666:
              return Uf;
            case 35674:
              return Nf;
            case 35675:
              return Ff;
            case 35676:
              return Of;
            case 5124:
            case 35670:
              return Bf;
            case 35667:
            case 35671:
              return zf;
            case 35668:
            case 35672:
              return kf;
            case 35669:
            case 35673:
              return Vf;
            case 5125:
              return Hf;
            case 36294:
              return Gf;
            case 36295:
              return Wf;
            case 36296:
              return Xf;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return qf;
            case 35679:
            case 36299:
            case 36307:
              return jf;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return Yf;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return Kf;
          }
        })(e.type));
    }
  }
  class gm {
    constructor(t, e, n) {
      (this.id = t),
        (this.addr = n),
        (this.cache = []),
        (this.type = e.type),
        (this.size = e.size),
        (this.setValue = (function (t) {
          switch (t) {
            case 5126:
              return Zf;
            case 35664:
              return Jf;
            case 35665:
              return $f;
            case 35666:
              return Qf;
            case 35674:
              return tm;
            case 35675:
              return em;
            case 35676:
              return nm;
            case 5124:
            case 35670:
              return im;
            case 35667:
            case 35671:
              return rm;
            case 35668:
            case 35672:
              return sm;
            case 35669:
            case 35673:
              return am;
            case 5125:
              return om;
            case 36294:
              return lm;
            case 36295:
              return cm;
            case 36296:
              return um;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return hm;
            case 35679:
            case 36299:
            case 36307:
              return dm;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return pm;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return fm;
          }
        })(e.type));
    }
  }
  class vm {
    constructor(t) {
      (this.id = t), (this.seq = []), (this.map = {});
    }
    setValue(t, e, n) {
      const i = this.seq;
      for (let r = 0, s = i.length; r !== s; ++r) {
        const s = i[r];
        s.setValue(t, e[s.id], n);
      }
    }
  }
  const _m = /(\w+)(\])?(\[|\.)?/g;
  function xm(t, e) {
    t.seq.push(e), (t.map[e.id] = e);
  }
  function ym(t, e, n) {
    const i = t.name,
      r = i.length;
    for (_m.lastIndex = 0; ; ) {
      const s = _m.exec(i),
        a = _m.lastIndex;
      let o = s[1];
      const l = "]" === s[2],
        c = s[3];
      if ((l && (o |= 0), void 0 === c || ("[" === c && a + 2 === r))) {
        xm(n, void 0 === c ? new mm(o, t, e) : new gm(o, t, e));
        break;
      }
      {
        let t = n.map[o];
        void 0 === t && ((t = new vm(o)), xm(n, t)), (n = t);
      }
    }
  }
  class Sm {
    constructor(t, e) {
      (this.seq = []), (this.map = {});
      const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
      for (let i = 0; i < n; ++i) {
        const n = t.getActiveUniform(e, i);
        ym(n, t.getUniformLocation(e, n.name), this);
      }
    }
    setValue(t, e, n, i) {
      const r = this.map[e];
      void 0 !== r && r.setValue(t, n, i);
    }
    setOptional(t, e, n) {
      const i = e[n];
      void 0 !== i && this.setValue(t, n, i);
    }
    static upload(t, e, n, i) {
      for (let r = 0, s = e.length; r !== s; ++r) {
        const s = e[r],
          a = n[s.id];
        !1 !== a.needsUpdate && s.setValue(t, a.value, i);
      }
    }
    static seqWithValue(t, e) {
      const n = [];
      for (let i = 0, r = t.length; i !== r; ++i) {
        const r = t[i];
        r.id in e && n.push(r);
      }
      return n;
    }
  }
  function Mm(t, e, n) {
    const i = t.createShader(e);
    return t.shaderSource(i, n), t.compileShader(i), i;
  }
  const Em = 37297;
  let Tm = 0;
  function bm(t, e, n) {
    const i = t.getShaderParameter(e, t.COMPILE_STATUS),
      r = t.getShaderInfoLog(e).trim();
    if (i && "" === r) return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
      const i = parseInt(s[1]);
      return (
        n.toUpperCase() +
        "\n\n" +
        r +
        "\n\n" +
        (function (t, e) {
          const n = t.split("\n"),
            i = [],
            r = Math.max(e - 6, 0),
            s = Math.min(e + 6, n.length);
          for (let t = r; t < s; t++) {
            const r = t + 1;
            i.push(`${r === e ? ">" : " "} ${r}: ${n[t]}`);
          }
          return i.join("\n");
        })(t.getShaderSource(e), i)
      );
    }
    return r;
  }
  function Dm(t, e) {
    const n = (function (t) {
      const e = Wu.getPrimaries(Wu.workingColorSpace),
        n = Wu.getPrimaries(t);
      let i;
      switch (
        (e === n
          ? (i = "")
          : e === hu && n === uu
          ? (i = "LinearDisplayP3ToLinearSRGB")
          : e === uu && n === hu && (i = "LinearSRGBToLinearDisplayP3"),
        t)
      ) {
        case su:
        case ou:
          return [i, "LinearTransferOETF"];
        case ru:
        case au:
          return [i, "sRGBTransferOETF"];
        default:
          return (
            console.warn("THREE.WebGLProgram: Unsupported color space:", t),
            [i, "LinearTransferOETF"]
          );
      }
    })(e);
    return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`;
  }
  function wm(t, e) {
    let n;
    switch (e) {
      case Mc:
        n = "Linear";
        break;
      case Ec:
        n = "Reinhard";
        break;
      case Tc:
        n = "OptimizedCineon";
        break;
      case bc:
        n = "ACESFilmic";
        break;
      case wc:
        n = "AgX";
        break;
      case Cc:
        n = "Neutral";
        break;
      case Dc:
        n = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
          (n = "Linear");
    }
    return (
      "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    );
  }
  function Cm(t) {
    return "" !== t;
  }
  function Am(t, e) {
    const n =
      e.numSpotLightShadows +
      e.numSpotLightMaps -
      e.numSpotLightShadowsWithMaps;
    return t
      .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
      .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
      .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
      .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
      .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
      .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
      .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
      .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
      .replace(
        /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
        e.numSpotLightShadowsWithMaps
      )
      .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
      .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
  }
  function Rm(t, e) {
    return t
      .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
      .replace(
        /UNION_CLIPPING_PLANES/g,
        e.numClippingPlanes - e.numClipIntersection
      );
  }
  const Pm = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function Lm(t) {
    return t.replace(Pm, Um);
  }
  const Im = new Map();
  function Um(t, e) {
    let n = Up[e];
    if (void 0 === n) {
      const t = Im.get(e);
      if (void 0 === t) throw new Error("Can not resolve #include <" + e + ">");
      (n = Up[t]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          t
        );
    }
    return Lm(n);
  }
  const Nm =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function Fm(t) {
    return t.replace(Nm, Om);
  }
  function Om(t, e, n, i) {
    let r = "";
    for (let t = parseInt(e); t < parseInt(n); t++)
      r += i
        .replace(/\[\s*i\s*\]/g, "[ " + t + " ]")
        .replace(/UNROLLED_LOOP_INDEX/g, t);
    return r;
  }
  function Bm(t) {
    let e = `precision ${t.precision} float;\n\tprecision ${t.precision} int;\n\tprecision ${t.precision} sampler2D;\n\tprecision ${t.precision} samplerCube;\n\tprecision ${t.precision} sampler3D;\n\tprecision ${t.precision} sampler2DArray;\n\tprecision ${t.precision} sampler2DShadow;\n\tprecision ${t.precision} samplerCubeShadow;\n\tprecision ${t.precision} sampler2DArrayShadow;\n\tprecision ${t.precision} isampler2D;\n\tprecision ${t.precision} isampler3D;\n\tprecision ${t.precision} isamplerCube;\n\tprecision ${t.precision} isampler2DArray;\n\tprecision ${t.precision} usampler2D;\n\tprecision ${t.precision} usampler3D;\n\tprecision ${t.precision} usamplerCube;\n\tprecision ${t.precision} usampler2DArray;\n\t`;
    return (
      "highp" === t.precision
        ? (e += "\n#define HIGH_PRECISION")
        : "mediump" === t.precision
        ? (e += "\n#define MEDIUM_PRECISION")
        : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
      e
    );
  }
  function zm(t, e, n, i) {
    const r = t.getContext(),
      s = n.defines;
    let a = n.vertexShader,
      o = n.fragmentShader;
    const l = (function (t) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return (
          t.shadowMapType === Yl
            ? (e = "SHADOWMAP_TYPE_PCF")
            : t.shadowMapType === Kl
            ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
            : t.shadowMapType === Zl && (e = "SHADOWMAP_TYPE_VSM"),
          e
        );
      })(n),
      c = (function (t) {
        let e = "ENVMAP_TYPE_CUBE";
        if (t.envMap)
          switch (t.envMapMode) {
            case Ac:
            case Rc:
              e = "ENVMAP_TYPE_CUBE";
              break;
            case Pc:
              e = "ENVMAP_TYPE_CUBE_UV";
          }
        return e;
      })(n),
      u = (function (t) {
        let e = "ENVMAP_MODE_REFLECTION";
        return (
          t.envMap && t.envMapMode === Rc && (e = "ENVMAP_MODE_REFRACTION"), e
        );
      })(n),
      h = (function (t) {
        let e = "ENVMAP_BLENDING_NONE";
        if (t.envMap)
          switch (t.combine) {
            case _c:
              e = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case xc:
              e = "ENVMAP_BLENDING_MIX";
              break;
            case yc:
              e = "ENVMAP_BLENDING_ADD";
          }
        return e;
      })(n),
      d = (function (t) {
        const e = t.envMapCubeUVHeight;
        if (null === e) return null;
        const n = Math.log2(e) - 2,
          i = 1 / e;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
          texelHeight: i,
          maxMip: n,
        };
      })(n),
      p = (function (t) {
        return [
          t.extensionClipCullDistance
            ? "#extension GL_ANGLE_clip_cull_distance : require"
            : "",
          t.extensionMultiDraw
            ? "#extension GL_ANGLE_multi_draw : require"
            : "",
        ]
          .filter(Cm)
          .join("\n");
      })(n),
      f = (function (t) {
        const e = [];
        for (const n in t) {
          const i = t[n];
          !1 !== i && e.push("#define " + n + " " + i);
        }
        return e.join("\n");
      })(s),
      m = r.createProgram();
    let g,
      v,
      _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
    n.isRawShaderMaterial
      ? ((g = [
          "#define SHADER_TYPE " + n.shaderType,
          "#define SHADER_NAME " + n.shaderName,
          f,
        ]
          .filter(Cm)
          .join("\n")),
        g.length > 0 && (g += "\n"),
        (v = [
          "#define SHADER_TYPE " + n.shaderType,
          "#define SHADER_NAME " + n.shaderName,
          f,
        ]
          .filter(Cm)
          .join("\n")),
        v.length > 0 && (v += "\n"))
      : ((g = [
          Bm(n),
          "#define SHADER_TYPE " + n.shaderType,
          "#define SHADER_NAME " + n.shaderName,
          f,
          n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
          n.batching ? "#define USE_BATCHING" : "",
          n.instancing ? "#define USE_INSTANCING" : "",
          n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
          n.useFog && n.fog ? "#define USE_FOG" : "",
          n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
          n.map ? "#define USE_MAP" : "",
          n.envMap ? "#define USE_ENVMAP" : "",
          n.envMap ? "#define " + u : "",
          n.lightMap ? "#define USE_LIGHTMAP" : "",
          n.aoMap ? "#define USE_AOMAP" : "",
          n.bumpMap ? "#define USE_BUMPMAP" : "",
          n.normalMap ? "#define USE_NORMALMAP" : "",
          n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
          n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          n.anisotropy ? "#define USE_ANISOTROPY" : "",
          n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          n.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          n.specularMap ? "#define USE_SPECULARMAP" : "",
          n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          n.metalnessMap ? "#define USE_METALNESSMAP" : "",
          n.alphaMap ? "#define USE_ALPHAMAP" : "",
          n.alphaHash ? "#define USE_ALPHAHASH" : "",
          n.transmission ? "#define USE_TRANSMISSION" : "",
          n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          n.mapUv ? "#define MAP_UV " + n.mapUv : "",
          n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
          n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
          n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
          n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
          n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
          n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
          n.displacementMapUv
            ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv
            : "",
          n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
          n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
          n.anisotropyMapUv
            ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv
            : "",
          n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
          n.clearcoatNormalMapUv
            ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
            : "",
          n.clearcoatRoughnessMapUv
            ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv
            : "",
          n.iridescenceMapUv
            ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv
            : "",
          n.iridescenceThicknessMapUv
            ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
              n.iridescenceThicknessMapUv
            : "",
          n.sheenColorMapUv
            ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv
            : "",
          n.sheenRoughnessMapUv
            ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
            : "",
          n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
          n.specularColorMapUv
            ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv
            : "",
          n.specularIntensityMapUv
            ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv
            : "",
          n.transmissionMapUv
            ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv
            : "",
          n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
          n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "",
          n.vertexColors ? "#define USE_COLOR" : "",
          n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          n.vertexUv1s ? "#define USE_UV1" : "",
          n.vertexUv2s ? "#define USE_UV2" : "",
          n.vertexUv3s ? "#define USE_UV3" : "",
          n.pointsUvs ? "#define USE_POINTS_UV" : "",
          n.flatShading ? "#define FLAT_SHADED" : "",
          n.skinning ? "#define USE_SKINNING" : "",
          n.morphTargets ? "#define USE_MORPHTARGETS" : "",
          n.morphNormals && !1 === n.flatShading
            ? "#define USE_MORPHNORMALS"
            : "",
          n.morphColors ? "#define USE_MORPHCOLORS" : "",
          n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "",
          n.morphTargetsCount > 0
            ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
            : "",
          n.morphTargetsCount > 0
            ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
            : "",
          n.doubleSided ? "#define DOUBLE_SIDED" : "",
          n.flipSided ? "#define FLIP_SIDED" : "",
          n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          n.shadowMapEnabled ? "#define " + l : "",
          n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
          n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "\tattribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "\tattribute vec3 instanceColor;",
          "#endif",
          "#ifdef USE_INSTANCING_MORPH",
          "\tuniform sampler2D morphTexture;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_UV1",
          "\tattribute vec2 uv1;",
          "#endif",
          "#ifdef USE_UV2",
          "\tattribute vec2 uv2;",
          "#endif",
          "#ifdef USE_UV3",
          "\tattribute vec2 uv3;",
          "#endif",
          "#ifdef USE_TANGENT",
          "\tattribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "\tattribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "\tattribute vec3 color;",
          "#endif",
          "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
          "\tattribute vec3 morphTarget0;",
          "\tattribute vec3 morphTarget1;",
          "\tattribute vec3 morphTarget2;",
          "\tattribute vec3 morphTarget3;",
          "\t#ifdef USE_MORPHNORMALS",
          "\t\tattribute vec3 morphNormal0;",
          "\t\tattribute vec3 morphNormal1;",
          "\t\tattribute vec3 morphNormal2;",
          "\t\tattribute vec3 morphNormal3;",
          "\t#else",
          "\t\tattribute vec3 morphTarget4;",
          "\t\tattribute vec3 morphTarget5;",
          "\t\tattribute vec3 morphTarget6;",
          "\t\tattribute vec3 morphTarget7;",
          "\t#endif",
          "#endif",
          "#ifdef USE_SKINNING",
          "\tattribute vec4 skinIndex;",
          "\tattribute vec4 skinWeight;",
          "#endif",
          "\n",
        ]
          .filter(Cm)
          .join("\n")),
        (v = [
          Bm(n),
          "#define SHADER_TYPE " + n.shaderType,
          "#define SHADER_NAME " + n.shaderName,
          f,
          n.useFog && n.fog ? "#define USE_FOG" : "",
          n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
          n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
          n.map ? "#define USE_MAP" : "",
          n.matcap ? "#define USE_MATCAP" : "",
          n.envMap ? "#define USE_ENVMAP" : "",
          n.envMap ? "#define " + c : "",
          n.envMap ? "#define " + u : "",
          n.envMap ? "#define " + h : "",
          d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
          d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
          d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
          n.lightMap ? "#define USE_LIGHTMAP" : "",
          n.aoMap ? "#define USE_AOMAP" : "",
          n.bumpMap ? "#define USE_BUMPMAP" : "",
          n.normalMap ? "#define USE_NORMALMAP" : "",
          n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          n.anisotropy ? "#define USE_ANISOTROPY" : "",
          n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          n.clearcoat ? "#define USE_CLEARCOAT" : "",
          n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          n.dispersion ? "#define USE_DISPERSION" : "",
          n.iridescence ? "#define USE_IRIDESCENCE" : "",
          n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          n.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          n.specularMap ? "#define USE_SPECULARMAP" : "",
          n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          n.metalnessMap ? "#define USE_METALNESSMAP" : "",
          n.alphaMap ? "#define USE_ALPHAMAP" : "",
          n.alphaTest ? "#define USE_ALPHATEST" : "",
          n.alphaHash ? "#define USE_ALPHAHASH" : "",
          n.sheen ? "#define USE_SHEEN" : "",
          n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          n.transmission ? "#define USE_TRANSMISSION" : "",
          n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "",
          n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
          n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          n.vertexUv1s ? "#define USE_UV1" : "",
          n.vertexUv2s ? "#define USE_UV2" : "",
          n.vertexUv3s ? "#define USE_UV3" : "",
          n.pointsUvs ? "#define USE_POINTS_UV" : "",
          n.gradientMap ? "#define USE_GRADIENTMAP" : "",
          n.flatShading ? "#define FLAT_SHADED" : "",
          n.doubleSided ? "#define DOUBLE_SIDED" : "",
          n.flipSided ? "#define FLIP_SIDED" : "",
          n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          n.shadowMapEnabled ? "#define " + l : "",
          n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
          n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
          n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          n.toneMapping !== Sc ? "#define TONE_MAPPING" : "",
          n.toneMapping !== Sc ? Up.tonemapping_pars_fragment : "",
          n.toneMapping !== Sc ? wm("toneMapping", n.toneMapping) : "",
          n.dithering ? "#define DITHERING" : "",
          n.opaque ? "#define OPAQUE" : "",
          Up.colorspace_pars_fragment,
          Dm("linearToOutputTexel", n.outputColorSpace),
          n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
          "\n",
        ]
          .filter(Cm)
          .join("\n"))),
      (a = Lm(a)),
      (a = Am(a, n)),
      (a = Rm(a, n)),
      (o = Lm(o)),
      (o = Am(o, n)),
      (o = Rm(o, n)),
      (a = Fm(a)),
      (o = Fm(o)),
      !0 !== n.isRawShaderMaterial &&
        ((_ = "#version 300 es\n"),
        (g =
          [
            p,
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture",
          ].join("\n") +
          "\n" +
          g),
        (v =
          [
            "#define varying in",
            n.glslVersion === Su
              ? ""
              : "layout(location = 0) out highp vec4 pc_fragColor;",
            n.glslVersion === Su ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad",
          ].join("\n") +
          "\n" +
          v));
    const x = _ + g + a,
      y = _ + v + o,
      S = Mm(r, r.VERTEX_SHADER, x),
      M = Mm(r, r.FRAGMENT_SHADER, y);
    function E(e) {
      if (t.debug.checkShaderErrors) {
        const n = r.getProgramInfoLog(m).trim(),
          i = r.getShaderInfoLog(S).trim(),
          s = r.getShaderInfoLog(M).trim();
        let a = !0,
          o = !0;
        if (!1 === r.getProgramParameter(m, r.LINK_STATUS))
          if (((a = !1), "function" == typeof t.debug.onShaderError))
            t.debug.onShaderError(r, m, S, M);
          else {
            const t = bm(r, S, "vertex"),
              i = bm(r, M, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " +
                r.getError() +
                " - VALIDATE_STATUS " +
                r.getProgramParameter(m, r.VALIDATE_STATUS) +
                "\n\nMaterial Name: " +
                e.name +
                "\nMaterial Type: " +
                e.type +
                "\n\nProgram Info Log: " +
                n +
                "\n" +
                t +
                "\n" +
                i
            );
          }
        else
          "" !== n
            ? console.warn("THREE.WebGLProgram: Program Info Log:", n)
            : ("" !== i && "" !== s) || (o = !1);
        o &&
          (e.diagnostics = {
            runnable: a,
            programLog: n,
            vertexShader: { log: i, prefix: g },
            fragmentShader: { log: s, prefix: v },
          });
      }
      r.deleteShader(S),
        r.deleteShader(M),
        (T = new Sm(r, m)),
        (b = (function (t, e) {
          const n = {},
            i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
          for (let r = 0; r < i; r++) {
            const i = t.getActiveAttrib(e, r),
              s = i.name;
            let a = 1;
            i.type === t.FLOAT_MAT2 && (a = 2),
              i.type === t.FLOAT_MAT3 && (a = 3),
              i.type === t.FLOAT_MAT4 && (a = 4),
              (n[s] = {
                type: i.type,
                location: t.getAttribLocation(e, s),
                locationSize: a,
              });
          }
          return n;
        })(r, m));
    }
    let T, b;
    r.attachShader(m, S),
      r.attachShader(m, M),
      void 0 !== n.index0AttributeName
        ? r.bindAttribLocation(m, 0, n.index0AttributeName)
        : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
      r.linkProgram(m),
      (this.getUniforms = function () {
        return void 0 === T && E(this), T;
      }),
      (this.getAttributes = function () {
        return void 0 === b && E(this), b;
      });
    let D = !1 === n.rendererExtensionParallelShaderCompile;
    return (
      (this.isReady = function () {
        return !1 === D && (D = r.getProgramParameter(m, Em)), D;
      }),
      (this.destroy = function () {
        i.releaseStatesOfProgram(this),
          r.deleteProgram(m),
          (this.program = void 0);
      }),
      (this.type = n.shaderType),
      (this.name = n.shaderName),
      (this.id = Tm++),
      (this.cacheKey = e),
      (this.usedTimes = 1),
      (this.program = m),
      (this.vertexShader = S),
      (this.fragmentShader = M),
      this
    );
  }
  let km = 0;
  class Vm {
    constructor() {
      (this.shaderCache = new Map()), (this.materialCache = new Map());
    }
    update(t) {
      const e = t.vertexShader,
        n = t.fragmentShader,
        i = this._getShaderStage(e),
        r = this._getShaderStage(n),
        s = this._getShaderCacheForMaterial(t);
      return (
        !1 === s.has(i) && (s.add(i), i.usedTimes++),
        !1 === s.has(r) && (s.add(r), r.usedTimes++),
        this
      );
    }
    remove(t) {
      const e = this.materialCache.get(t);
      for (const t of e)
        t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
      return this.materialCache.delete(t), this;
    }
    getVertexShaderID(t) {
      return this._getShaderStage(t.vertexShader).id;
    }
    getFragmentShaderID(t) {
      return this._getShaderStage(t.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(t) {
      const e = this.materialCache;
      let n = e.get(t);
      return void 0 === n && ((n = new Set()), e.set(t, n)), n;
    }
    _getShaderStage(t) {
      const e = this.shaderCache;
      let n = e.get(t);
      return void 0 === n && ((n = new Hm(t)), e.set(t, n)), n;
    }
  }
  class Hm {
    constructor(t) {
      (this.id = km++), (this.code = t), (this.usedTimes = 0);
    }
  }
  function Gm(t, e, n, i, r, s, a) {
    const o = new jh(),
      l = new Vm(),
      c = new Set(),
      u = [],
      h = r.logarithmicDepthBuffer,
      d = r.vertexTextures;
    let p = r.precision;
    const f = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite",
    };
    function m(t) {
      return c.add(t), 0 === t ? "uv" : `uv${t}`;
    }
    return {
      getParameters: function (s, o, u, g, v) {
        const _ = g.fog,
          x = v.geometry,
          y = s.isMeshStandardMaterial ? g.environment : null,
          S = (s.isMeshStandardMaterial ? n : e).get(s.envMap || y),
          M = S && S.mapping === Pc ? S.image.height : null,
          E = f[s.type];
        null !== s.precision &&
          ((p = r.getMaxPrecision(s.precision)),
          p !== s.precision &&
            console.warn(
              "THREE.WebGLProgram.getParameters:",
              s.precision,
              "not supported, using",
              p,
              "instead."
            ));
        const T =
            x.morphAttributes.position ||
            x.morphAttributes.normal ||
            x.morphAttributes.color,
          b = void 0 !== T ? T.length : 0;
        let D,
          w,
          C,
          A,
          R = 0;
        if (
          (void 0 !== x.morphAttributes.position && (R = 1),
          void 0 !== x.morphAttributes.normal && (R = 2),
          void 0 !== x.morphAttributes.color && (R = 3),
          E)
        ) {
          const t = Fp[E];
          (D = t.vertexShader), (w = t.fragmentShader);
        } else
          (D = s.vertexShader),
            (w = s.fragmentShader),
            l.update(s),
            (C = l.getVertexShaderID(s)),
            (A = l.getFragmentShaderID(s));
        const P = t.getRenderTarget(),
          L = !0 === v.isInstancedMesh,
          I = !0 === v.isBatchedMesh,
          U = !!s.map,
          N = !!s.matcap,
          F = !!S,
          O = !!s.aoMap,
          B = !!s.lightMap,
          z = !!s.bumpMap,
          k = !!s.normalMap,
          V = !!s.displacementMap,
          H = !!s.emissiveMap,
          G = !!s.metalnessMap,
          W = !!s.roughnessMap,
          X = s.anisotropy > 0,
          q = s.clearcoat > 0,
          j = s.dispersion > 0,
          Y = s.iridescence > 0,
          K = s.sheen > 0,
          Z = s.transmission > 0,
          J = X && !!s.anisotropyMap,
          $ = q && !!s.clearcoatMap,
          Q = q && !!s.clearcoatNormalMap,
          tt = q && !!s.clearcoatRoughnessMap,
          et = Y && !!s.iridescenceMap,
          nt = Y && !!s.iridescenceThicknessMap,
          it = K && !!s.sheenColorMap,
          rt = K && !!s.sheenRoughnessMap,
          st = !!s.specularMap,
          at = !!s.specularColorMap,
          ot = !!s.specularIntensityMap,
          lt = Z && !!s.transmissionMap,
          ct = Z && !!s.thicknessMap,
          ut = !!s.gradientMap,
          ht = !!s.alphaMap,
          dt = s.alphaTest > 0,
          pt = !!s.alphaHash,
          ft = !!s.extensions;
        let mt = Sc;
        s.toneMapped &&
          ((null !== P && !0 !== P.isXRRenderTarget) || (mt = t.toneMapping));
        const gt = {
          shaderID: E,
          shaderType: s.type,
          shaderName: s.name,
          vertexShader: D,
          fragmentShader: w,
          defines: s.defines,
          customVertexShaderID: C,
          customFragmentShaderID: A,
          isRawShaderMaterial: !0 === s.isRawShaderMaterial,
          glslVersion: s.glslVersion,
          precision: p,
          batching: I,
          instancing: L,
          instancingColor: L && null !== v.instanceColor,
          instancingMorph: L && null !== v.morphTexture,
          supportsVertexTextures: d,
          outputColorSpace:
            null === P
              ? t.outputColorSpace
              : !0 === P.isXRRenderTarget
              ? P.texture.colorSpace
              : su,
          alphaToCoverage: !!s.alphaToCoverage,
          map: U,
          matcap: N,
          envMap: F,
          envMapMode: F && S.mapping,
          envMapCubeUVHeight: M,
          aoMap: O,
          lightMap: B,
          bumpMap: z,
          normalMap: k,
          displacementMap: d && V,
          emissiveMap: H,
          normalMapObjectSpace: k && 1 === s.normalMapType,
          normalMapTangentSpace: k && 0 === s.normalMapType,
          metalnessMap: G,
          roughnessMap: W,
          anisotropy: X,
          anisotropyMap: J,
          clearcoat: q,
          clearcoatMap: $,
          clearcoatNormalMap: Q,
          clearcoatRoughnessMap: tt,
          dispersion: j,
          iridescence: Y,
          iridescenceMap: et,
          iridescenceThicknessMap: nt,
          sheen: K,
          sheenColorMap: it,
          sheenRoughnessMap: rt,
          specularMap: st,
          specularColorMap: at,
          specularIntensityMap: ot,
          transmission: Z,
          transmissionMap: lt,
          thicknessMap: ct,
          gradientMap: ut,
          opaque:
            !1 === s.transparent &&
            1 === s.blending &&
            !1 === s.alphaToCoverage,
          alphaMap: ht,
          alphaTest: dt,
          alphaHash: pt,
          combine: s.combine,
          mapUv: U && m(s.map.channel),
          aoMapUv: O && m(s.aoMap.channel),
          lightMapUv: B && m(s.lightMap.channel),
          bumpMapUv: z && m(s.bumpMap.channel),
          normalMapUv: k && m(s.normalMap.channel),
          displacementMapUv: V && m(s.displacementMap.channel),
          emissiveMapUv: H && m(s.emissiveMap.channel),
          metalnessMapUv: G && m(s.metalnessMap.channel),
          roughnessMapUv: W && m(s.roughnessMap.channel),
          anisotropyMapUv: J && m(s.anisotropyMap.channel),
          clearcoatMapUv: $ && m(s.clearcoatMap.channel),
          clearcoatNormalMapUv: Q && m(s.clearcoatNormalMap.channel),
          clearcoatRoughnessMapUv: tt && m(s.clearcoatRoughnessMap.channel),
          iridescenceMapUv: et && m(s.iridescenceMap.channel),
          iridescenceThicknessMapUv: nt && m(s.iridescenceThicknessMap.channel),
          sheenColorMapUv: it && m(s.sheenColorMap.channel),
          sheenRoughnessMapUv: rt && m(s.sheenRoughnessMap.channel),
          specularMapUv: st && m(s.specularMap.channel),
          specularColorMapUv: at && m(s.specularColorMap.channel),
          specularIntensityMapUv: ot && m(s.specularIntensityMap.channel),
          transmissionMapUv: lt && m(s.transmissionMap.channel),
          thicknessMapUv: ct && m(s.thicknessMap.channel),
          alphaMapUv: ht && m(s.alphaMap.channel),
          vertexTangents: !!x.attributes.tangent && (k || X),
          vertexColors: s.vertexColors,
          vertexAlphas:
            !0 === s.vertexColors &&
            !!x.attributes.color &&
            4 === x.attributes.color.itemSize,
          pointsUvs: !0 === v.isPoints && !!x.attributes.uv && (U || ht),
          fog: !!_,
          useFog: !0 === s.fog,
          fogExp2: !!_ && _.isFogExp2,
          flatShading: !0 === s.flatShading,
          sizeAttenuation: !0 === s.sizeAttenuation,
          logarithmicDepthBuffer: h,
          skinning: !0 === v.isSkinnedMesh,
          morphTargets: void 0 !== x.morphAttributes.position,
          morphNormals: void 0 !== x.morphAttributes.normal,
          morphColors: void 0 !== x.morphAttributes.color,
          morphTargetsCount: b,
          morphTextureStride: R,
          numDirLights: o.directional.length,
          numPointLights: o.point.length,
          numSpotLights: o.spot.length,
          numSpotLightMaps: o.spotLightMap.length,
          numRectAreaLights: o.rectArea.length,
          numHemiLights: o.hemi.length,
          numDirLightShadows: o.directionalShadowMap.length,
          numPointLightShadows: o.pointShadowMap.length,
          numSpotLightShadows: o.spotShadowMap.length,
          numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
          numLightProbes: o.numLightProbes,
          numClippingPlanes: a.numPlanes,
          numClipIntersection: a.numIntersection,
          dithering: s.dithering,
          shadowMapEnabled: t.shadowMap.enabled && u.length > 0,
          shadowMapType: t.shadowMap.type,
          toneMapping: mt,
          useLegacyLights: t._useLegacyLights,
          decodeVideoTexture:
            U &&
            !0 === s.map.isVideoTexture &&
            Wu.getTransfer(s.map.colorSpace) === cu,
          premultipliedAlpha: s.premultipliedAlpha,
          doubleSided: 2 === s.side,
          flipSided: 1 === s.side,
          useDepthPacking: s.depthPacking >= 0,
          depthPacking: s.depthPacking || 0,
          index0AttributeName: s.index0AttributeName,
          extensionClipCullDistance:
            ft &&
            !0 === s.extensions.clipCullDistance &&
            i.has("WEBGL_clip_cull_distance"),
          extensionMultiDraw:
            ft && !0 === s.extensions.multiDraw && i.has("WEBGL_multi_draw"),
          rendererExtensionParallelShaderCompile: i.has(
            "KHR_parallel_shader_compile"
          ),
          customProgramCacheKey: s.customProgramCacheKey(),
        };
        return (
          (gt.vertexUv1s = c.has(1)),
          (gt.vertexUv2s = c.has(2)),
          (gt.vertexUv3s = c.has(3)),
          c.clear(),
          gt
        );
      },
      getProgramCacheKey: function (e) {
        const n = [];
        if (
          (e.shaderID
            ? n.push(e.shaderID)
            : (n.push(e.customVertexShaderID),
              n.push(e.customFragmentShaderID)),
          void 0 !== e.defines)
        )
          for (const t in e.defines) n.push(t), n.push(e.defines[t]);
        return (
          !1 === e.isRawShaderMaterial &&
            ((function (t, e) {
              t.push(e.precision),
                t.push(e.outputColorSpace),
                t.push(e.envMapMode),
                t.push(e.envMapCubeUVHeight),
                t.push(e.mapUv),
                t.push(e.alphaMapUv),
                t.push(e.lightMapUv),
                t.push(e.aoMapUv),
                t.push(e.bumpMapUv),
                t.push(e.normalMapUv),
                t.push(e.displacementMapUv),
                t.push(e.emissiveMapUv),
                t.push(e.metalnessMapUv),
                t.push(e.roughnessMapUv),
                t.push(e.anisotropyMapUv),
                t.push(e.clearcoatMapUv),
                t.push(e.clearcoatNormalMapUv),
                t.push(e.clearcoatRoughnessMapUv),
                t.push(e.iridescenceMapUv),
                t.push(e.iridescenceThicknessMapUv),
                t.push(e.sheenColorMapUv),
                t.push(e.sheenRoughnessMapUv),
                t.push(e.specularMapUv),
                t.push(e.specularColorMapUv),
                t.push(e.specularIntensityMapUv),
                t.push(e.transmissionMapUv),
                t.push(e.thicknessMapUv),
                t.push(e.combine),
                t.push(e.fogExp2),
                t.push(e.sizeAttenuation),
                t.push(e.morphTargetsCount),
                t.push(e.morphAttributeCount),
                t.push(e.numDirLights),
                t.push(e.numPointLights),
                t.push(e.numSpotLights),
                t.push(e.numSpotLightMaps),
                t.push(e.numHemiLights),
                t.push(e.numRectAreaLights),
                t.push(e.numDirLightShadows),
                t.push(e.numPointLightShadows),
                t.push(e.numSpotLightShadows),
                t.push(e.numSpotLightShadowsWithMaps),
                t.push(e.numLightProbes),
                t.push(e.shadowMapType),
                t.push(e.toneMapping),
                t.push(e.numClippingPlanes),
                t.push(e.numClipIntersection),
                t.push(e.depthPacking);
            })(n, e),
            (function (t, e) {
              o.disableAll(),
                e.supportsVertexTextures && o.enable(0),
                e.instancing && o.enable(1),
                e.instancingColor && o.enable(2),
                e.instancingMorph && o.enable(3),
                e.matcap && o.enable(4),
                e.envMap && o.enable(5),
                e.normalMapObjectSpace && o.enable(6),
                e.normalMapTangentSpace && o.enable(7),
                e.clearcoat && o.enable(8),
                e.iridescence && o.enable(9),
                e.alphaTest && o.enable(10),
                e.vertexColors && o.enable(11),
                e.vertexAlphas && o.enable(12),
                e.vertexUv1s && o.enable(13),
                e.vertexUv2s && o.enable(14),
                e.vertexUv3s && o.enable(15),
                e.vertexTangents && o.enable(16),
                e.anisotropy && o.enable(17),
                e.alphaHash && o.enable(18),
                e.batching && o.enable(19),
                e.dispersion && o.enable(20),
                t.push(o.mask),
                o.disableAll(),
                e.fog && o.enable(0),
                e.useFog && o.enable(1),
                e.flatShading && o.enable(2),
                e.logarithmicDepthBuffer && o.enable(3),
                e.skinning && o.enable(4),
                e.morphTargets && o.enable(5),
                e.morphNormals && o.enable(6),
                e.morphColors && o.enable(7),
                e.premultipliedAlpha && o.enable(8),
                e.shadowMapEnabled && o.enable(9),
                e.useLegacyLights && o.enable(10),
                e.doubleSided && o.enable(11),
                e.flipSided && o.enable(12),
                e.useDepthPacking && o.enable(13),
                e.dithering && o.enable(14),
                e.transmission && o.enable(15),
                e.sheen && o.enable(16),
                e.opaque && o.enable(17),
                e.pointsUvs && o.enable(18),
                e.decodeVideoTexture && o.enable(19),
                e.alphaToCoverage && o.enable(20),
                t.push(o.mask);
            })(n, e),
            n.push(t.outputColorSpace)),
          n.push(e.customProgramCacheKey),
          n.join()
        );
      },
      getUniforms: function (t) {
        const e = f[t.type];
        let n;
        if (e) {
          const t = Fp[e];
          n = pp.clone(t.uniforms);
        } else n = t.uniforms;
        return n;
      },
      acquireProgram: function (e, n) {
        let i;
        for (let t = 0, e = u.length; t < e; t++) {
          const e = u[t];
          if (e.cacheKey === n) {
            (i = e), ++i.usedTimes;
            break;
          }
        }
        return void 0 === i && ((i = new zm(t, n, e, s)), u.push(i)), i;
      },
      releaseProgram: function (t) {
        if (0 == --t.usedTimes) {
          const e = u.indexOf(t);
          (u[e] = u[u.length - 1]), u.pop(), t.destroy();
        }
      },
      releaseShaderCache: function (t) {
        l.remove(t);
      },
      programs: u,
      dispose: function () {
        l.dispose();
      },
    };
  }
  function Wm() {
    let t = new WeakMap();
    return {
      get: function (e) {
        let n = t.get(e);
        return void 0 === n && ((n = {}), t.set(e, n)), n;
      },
      remove: function (e) {
        t.delete(e);
      },
      update: function (e, n, i) {
        t.get(e)[n] = i;
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  function Xm(t, e) {
    return t.groupOrder !== e.groupOrder
      ? t.groupOrder - e.groupOrder
      : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.material.id !== e.material.id
      ? t.material.id - e.material.id
      : t.z !== e.z
      ? t.z - e.z
      : t.id - e.id;
  }
  function qm(t, e) {
    return t.groupOrder !== e.groupOrder
      ? t.groupOrder - e.groupOrder
      : t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.z !== e.z
      ? e.z - t.z
      : t.id - e.id;
  }
  function jm() {
    const t = [];
    let e = 0;
    const n = [],
      i = [],
      r = [];
    function s(n, i, r, s, a, o) {
      let l = t[e];
      return (
        void 0 === l
          ? ((l = {
              id: n.id,
              object: n,
              geometry: i,
              material: r,
              groupOrder: s,
              renderOrder: n.renderOrder,
              z: a,
              group: o,
            }),
            (t[e] = l))
          : ((l.id = n.id),
            (l.object = n),
            (l.geometry = i),
            (l.material = r),
            (l.groupOrder = s),
            (l.renderOrder = n.renderOrder),
            (l.z = a),
            (l.group = o)),
        e++,
        l
      );
    }
    return {
      opaque: n,
      transmissive: i,
      transparent: r,
      init: function () {
        (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
      },
      push: function (t, e, a, o, l, c) {
        const u = s(t, e, a, o, l, c);
        a.transmission > 0
          ? i.push(u)
          : !0 === a.transparent
          ? r.push(u)
          : n.push(u);
      },
      unshift: function (t, e, a, o, l, c) {
        const u = s(t, e, a, o, l, c);
        a.transmission > 0
          ? i.unshift(u)
          : !0 === a.transparent
          ? r.unshift(u)
          : n.unshift(u);
      },
      finish: function () {
        for (let n = e, i = t.length; n < i; n++) {
          const e = t[n];
          if (null === e.id) break;
          (e.id = null),
            (e.object = null),
            (e.geometry = null),
            (e.material = null),
            (e.group = null);
        }
      },
      sort: function (t, e) {
        n.length > 1 && n.sort(t || Xm),
          i.length > 1 && i.sort(e || qm),
          r.length > 1 && r.sort(e || qm);
      },
    };
  }
  function Ym() {
    let t = new WeakMap();
    return {
      get: function (e, n) {
        const i = t.get(e);
        let r;
        return (
          void 0 === i
            ? ((r = new jm()), t.set(e, [r]))
            : n >= i.length
            ? ((r = new jm()), i.push(r))
            : (r = i[n]),
          r
        );
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  function Km() {
    const t = {};
    return {
      get: function (e) {
        if (void 0 !== t[e.id]) return t[e.id];
        let n;
        switch (e.type) {
          case "DirectionalLight":
            n = { direction: new ah(), color: new bd() };
            break;
          case "SpotLight":
            n = {
              position: new ah(),
              direction: new ah(),
              color: new bd(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
            };
            break;
          case "PointLight":
            n = { position: new ah(), color: new bd(), distance: 0, decay: 0 };
            break;
          case "HemisphereLight":
            n = {
              direction: new ah(),
              skyColor: new bd(),
              groundColor: new bd(),
            };
            break;
          case "RectAreaLight":
            n = {
              color: new bd(),
              position: new ah(),
              halfWidth: new ah(),
              halfHeight: new ah(),
            };
        }
        return (t[e.id] = n), n;
      },
    };
  }
  let Zm = 0;
  function Jm(t, e) {
    return (
      (e.castShadow ? 2 : 0) -
      (t.castShadow ? 2 : 0) +
      (e.map ? 1 : 0) -
      (t.map ? 1 : 0)
    );
  }
  function $m(t) {
    const e = new Km(),
      n = (function () {
        const t = {};
        return {
          get: function (e) {
            if (void 0 !== t[e.id]) return t[e.id];
            let n;
            switch (e.type) {
              case "DirectionalLight":
              case "SpotLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Iu(),
                };
                break;
              case "PointLight":
                n = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Iu(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
            }
            return (t[e.id] = n), n;
          },
        };
      })(),
      i = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1,
          numSpotMaps: -1,
          numLightProbes: -1,
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0,
      };
    for (let t = 0; t < 9; t++) i.probe.push(new ah());
    const r = new ah(),
      s = new Fh(),
      a = new Fh();
    return {
      setup: function (r, s) {
        let a = 0,
          o = 0,
          l = 0;
        for (let t = 0; t < 9; t++) i.probe[t].set(0, 0, 0);
        let c = 0,
          u = 0,
          h = 0,
          d = 0,
          p = 0,
          f = 0,
          m = 0,
          g = 0,
          v = 0,
          _ = 0,
          x = 0;
        r.sort(Jm);
        const y = !0 === s ? Math.PI : 1;
        for (let t = 0, s = r.length; t < s; t++) {
          const s = r[t],
            S = s.color,
            M = s.intensity,
            E = s.distance,
            T = s.shadow && s.shadow.map ? s.shadow.map.texture : null;
          if (s.isAmbientLight)
            (a += S.r * M * y), (o += S.g * M * y), (l += S.b * M * y);
          else if (s.isLightProbe) {
            for (let t = 0; t < 9; t++)
              i.probe[t].addScaledVector(s.sh.coefficients[t], M);
            x++;
          } else if (s.isDirectionalLight) {
            const t = e.get(s);
            if (
              (t.color.copy(s.color).multiplyScalar(s.intensity * y),
              s.castShadow)
            ) {
              const t = s.shadow,
                e = n.get(s);
              (e.shadowBias = t.bias),
                (e.shadowNormalBias = t.normalBias),
                (e.shadowRadius = t.radius),
                (e.shadowMapSize = t.mapSize),
                (i.directionalShadow[c] = e),
                (i.directionalShadowMap[c] = T),
                (i.directionalShadowMatrix[c] = s.shadow.matrix),
                f++;
            }
            (i.directional[c] = t), c++;
          } else if (s.isSpotLight) {
            const t = e.get(s);
            t.position.setFromMatrixPosition(s.matrixWorld),
              t.color.copy(S).multiplyScalar(M * y),
              (t.distance = E),
              (t.coneCos = Math.cos(s.angle)),
              (t.penumbraCos = Math.cos(s.angle * (1 - s.penumbra))),
              (t.decay = s.decay),
              (i.spot[h] = t);
            const r = s.shadow;
            if (
              (s.map &&
                ((i.spotLightMap[v] = s.map),
                v++,
                r.updateMatrices(s),
                s.castShadow && _++),
              (i.spotLightMatrix[h] = r.matrix),
              s.castShadow)
            ) {
              const t = n.get(s);
              (t.shadowBias = r.bias),
                (t.shadowNormalBias = r.normalBias),
                (t.shadowRadius = r.radius),
                (t.shadowMapSize = r.mapSize),
                (i.spotShadow[h] = t),
                (i.spotShadowMap[h] = T),
                g++;
            }
            h++;
          } else if (s.isRectAreaLight) {
            const t = e.get(s);
            t.color.copy(S).multiplyScalar(M),
              t.halfWidth.set(0.5 * s.width, 0, 0),
              t.halfHeight.set(0, 0.5 * s.height, 0),
              (i.rectArea[d] = t),
              d++;
          } else if (s.isPointLight) {
            const t = e.get(s);
            if (
              (t.color.copy(s.color).multiplyScalar(s.intensity * y),
              (t.distance = s.distance),
              (t.decay = s.decay),
              s.castShadow)
            ) {
              const t = s.shadow,
                e = n.get(s);
              (e.shadowBias = t.bias),
                (e.shadowNormalBias = t.normalBias),
                (e.shadowRadius = t.radius),
                (e.shadowMapSize = t.mapSize),
                (e.shadowCameraNear = t.camera.near),
                (e.shadowCameraFar = t.camera.far),
                (i.pointShadow[u] = e),
                (i.pointShadowMap[u] = T),
                (i.pointShadowMatrix[u] = s.shadow.matrix),
                m++;
            }
            (i.point[u] = t), u++;
          } else if (s.isHemisphereLight) {
            const t = e.get(s);
            t.skyColor.copy(s.color).multiplyScalar(M * y),
              t.groundColor.copy(s.groundColor).multiplyScalar(M * y),
              (i.hemi[p] = t),
              p++;
          }
        }
        d > 0 &&
          (!0 === t.has("OES_texture_float_linear")
            ? ((i.rectAreaLTC1 = Np.LTC_FLOAT_1),
              (i.rectAreaLTC2 = Np.LTC_FLOAT_2))
            : ((i.rectAreaLTC1 = Np.LTC_HALF_1),
              (i.rectAreaLTC2 = Np.LTC_HALF_2))),
          (i.ambient[0] = a),
          (i.ambient[1] = o),
          (i.ambient[2] = l);
        const S = i.hash;
        (S.directionalLength === c &&
          S.pointLength === u &&
          S.spotLength === h &&
          S.rectAreaLength === d &&
          S.hemiLength === p &&
          S.numDirectionalShadows === f &&
          S.numPointShadows === m &&
          S.numSpotShadows === g &&
          S.numSpotMaps === v &&
          S.numLightProbes === x) ||
          ((i.directional.length = c),
          (i.spot.length = h),
          (i.rectArea.length = d),
          (i.point.length = u),
          (i.hemi.length = p),
          (i.directionalShadow.length = f),
          (i.directionalShadowMap.length = f),
          (i.pointShadow.length = m),
          (i.pointShadowMap.length = m),
          (i.spotShadow.length = g),
          (i.spotShadowMap.length = g),
          (i.directionalShadowMatrix.length = f),
          (i.pointShadowMatrix.length = m),
          (i.spotLightMatrix.length = g + v - _),
          (i.spotLightMap.length = v),
          (i.numSpotLightShadowsWithMaps = _),
          (i.numLightProbes = x),
          (S.directionalLength = c),
          (S.pointLength = u),
          (S.spotLength = h),
          (S.rectAreaLength = d),
          (S.hemiLength = p),
          (S.numDirectionalShadows = f),
          (S.numPointShadows = m),
          (S.numSpotShadows = g),
          (S.numSpotMaps = v),
          (S.numLightProbes = x),
          (i.version = Zm++));
      },
      setupView: function (t, e) {
        let n = 0,
          o = 0,
          l = 0,
          c = 0,
          u = 0;
        const h = e.matrixWorldInverse;
        for (let e = 0, d = t.length; e < d; e++) {
          const d = t[e];
          if (d.isDirectionalLight) {
            const t = i.directional[n];
            t.direction.setFromMatrixPosition(d.matrixWorld),
              r.setFromMatrixPosition(d.target.matrixWorld),
              t.direction.sub(r),
              t.direction.transformDirection(h),
              n++;
          } else if (d.isSpotLight) {
            const t = i.spot[l];
            t.position.setFromMatrixPosition(d.matrixWorld),
              t.position.applyMatrix4(h),
              t.direction.setFromMatrixPosition(d.matrixWorld),
              r.setFromMatrixPosition(d.target.matrixWorld),
              t.direction.sub(r),
              t.direction.transformDirection(h),
              l++;
          } else if (d.isRectAreaLight) {
            const t = i.rectArea[c];
            t.position.setFromMatrixPosition(d.matrixWorld),
              t.position.applyMatrix4(h),
              a.identity(),
              s.copy(d.matrixWorld),
              s.premultiply(h),
              a.extractRotation(s),
              t.halfWidth.set(0.5 * d.width, 0, 0),
              t.halfHeight.set(0, 0.5 * d.height, 0),
              t.halfWidth.applyMatrix4(a),
              t.halfHeight.applyMatrix4(a),
              c++;
          } else if (d.isPointLight) {
            const t = i.point[o];
            t.position.setFromMatrixPosition(d.matrixWorld),
              t.position.applyMatrix4(h),
              o++;
          } else if (d.isHemisphereLight) {
            const t = i.hemi[u];
            t.direction.setFromMatrixPosition(d.matrixWorld),
              t.direction.transformDirection(h),
              u++;
          }
        }
      },
      state: i,
    };
  }
  function Qm(t) {
    const e = new $m(t),
      n = [],
      i = [],
      r = {
        lightsArray: n,
        shadowsArray: i,
        camera: null,
        lights: e,
        transmissionRenderTarget: {},
      };
    return {
      init: function (t) {
        (r.camera = t), (n.length = 0), (i.length = 0);
      },
      state: r,
      setupLights: function (t) {
        e.setup(n, t);
      },
      setupLightsView: function (t) {
        e.setupView(n, t);
      },
      pushLight: function (t) {
        n.push(t);
      },
      pushShadow: function (t) {
        i.push(t);
      },
    };
  }
  function tg(t) {
    let e = new WeakMap();
    return {
      get: function (n, i = 0) {
        const r = e.get(n);
        let s;
        return (
          void 0 === r
            ? ((s = new Qm(t)), e.set(n, [s]))
            : i >= r.length
            ? ((s = new Qm(t)), r.push(s))
            : (s = r[i]),
          s
        );
      },
      dispose: function () {
        e = new WeakMap();
      },
    };
  }
  class eg extends Cd {
    constructor(t) {
      super(),
        (this.isMeshDepthMaterial = !0),
        (this.type = "MeshDepthMaterial"),
        (this.depthPacking = 3200),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.depthPacking = t.depthPacking),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        this
      );
    }
  }
  class ng extends Cd {
    constructor(t) {
      super(),
        (this.isMeshDistanceMaterial = !0),
        (this.type = "MeshDistanceMaterial"),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        this.setValues(t);
    }
    copy(t) {
      return (
        super.copy(t),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        this
      );
    }
  }
  function ig(t, e, n) {
    let i = new Rp();
    const r = new Iu(),
      s = new Iu(),
      a = new th(),
      o = new eg({ depthPacking: 3201 }),
      l = new ng(),
      c = {},
      u = n.maxTextureSize,
      h = { [Jl]: 1, [$l]: 0, [Ql]: 2 },
      d = new fp({
        defines: { VSM_SAMPLES: 8 },
        uniforms: {
          shadow_pass: { value: null },
          resolution: { value: new Iu() },
          radius: { value: 4 },
        },
        vertexShader:
          "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
        fragmentShader:
          "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
      }),
      p = d.clone();
    p.defines.HORIZONTAL_PASS = 1;
    const f = new Gd();
    f.setAttribute(
      "position",
      new Ld(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
    );
    const m = new op(f, d),
      g = this;
    (this.enabled = !1),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this.type = Yl);
    let v = this.type;
    function _(n, i) {
      const s = e.update(m);
      d.defines.VSM_SAMPLES !== n.blurSamples &&
        ((d.defines.VSM_SAMPLES = n.blurSamples),
        (p.defines.VSM_SAMPLES = n.blurSamples),
        (d.needsUpdate = !0),
        (p.needsUpdate = !0)),
        null === n.mapPass && (n.mapPass = new nh(r.x, r.y)),
        (d.uniforms.shadow_pass.value = n.map.texture),
        (d.uniforms.resolution.value = n.mapSize),
        (d.uniforms.radius.value = n.radius),
        t.setRenderTarget(n.mapPass),
        t.clear(),
        t.renderBufferDirect(i, null, s, d, m, null),
        (p.uniforms.shadow_pass.value = n.mapPass.texture),
        (p.uniforms.resolution.value = n.mapSize),
        (p.uniforms.radius.value = n.radius),
        t.setRenderTarget(n.map),
        t.clear(),
        t.renderBufferDirect(i, null, s, p, m, null);
    }
    function x(e, n, i, r) {
      let s = null;
      const a =
        !0 === i.isPointLight
          ? e.customDistanceMaterial
          : e.customDepthMaterial;
      if (void 0 !== a) s = a;
      else if (
        ((s = !0 === i.isPointLight ? l : o),
        (t.localClippingEnabled &&
          !0 === n.clipShadows &&
          Array.isArray(n.clippingPlanes) &&
          0 !== n.clippingPlanes.length) ||
          (n.displacementMap && 0 !== n.displacementScale) ||
          (n.alphaMap && n.alphaTest > 0) ||
          (n.map && n.alphaTest > 0))
      ) {
        const t = s.uuid,
          e = n.uuid;
        let i = c[t];
        void 0 === i && ((i = {}), (c[t] = i));
        let r = i[e];
        void 0 === r &&
          ((r = s.clone()), (i[e] = r), n.addEventListener("dispose", S)),
          (s = r);
      }
      return (
        (s.visible = n.visible),
        (s.wireframe = n.wireframe),
        (s.side =
          r === Zl
            ? null !== n.shadowSide
              ? n.shadowSide
              : n.side
            : null !== n.shadowSide
            ? n.shadowSide
            : h[n.side]),
        (s.alphaMap = n.alphaMap),
        (s.alphaTest = n.alphaTest),
        (s.map = n.map),
        (s.clipShadows = n.clipShadows),
        (s.clippingPlanes = n.clippingPlanes),
        (s.clipIntersection = n.clipIntersection),
        (s.displacementMap = n.displacementMap),
        (s.displacementScale = n.displacementScale),
        (s.displacementBias = n.displacementBias),
        (s.wireframeLinewidth = n.wireframeLinewidth),
        (s.linewidth = n.linewidth),
        !0 === i.isPointLight &&
          !0 === s.isMeshDistanceMaterial &&
          (t.properties.get(s).light = i),
        s
      );
    }
    function y(n, r, s, a, o) {
      if (!1 === n.visible) return;
      if (
        n.layers.test(r.layers) &&
        (n.isMesh || n.isLine || n.isPoints) &&
        (n.castShadow || (n.receiveShadow && o === Zl)) &&
        (!n.frustumCulled || i.intersectsObject(n))
      ) {
        n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
        const i = e.update(n),
          l = n.material;
        if (Array.isArray(l)) {
          const e = i.groups;
          for (let c = 0, u = e.length; c < u; c++) {
            const u = e[c],
              h = l[u.materialIndex];
            if (h && h.visible) {
              const e = x(n, h, a, o);
              n.onBeforeShadow(t, n, r, s, i, e, u),
                t.renderBufferDirect(s, null, i, e, n, u),
                n.onAfterShadow(t, n, r, s, i, e, u);
            }
          }
        } else if (l.visible) {
          const e = x(n, l, a, o);
          n.onBeforeShadow(t, n, r, s, i, e, null),
            t.renderBufferDirect(s, null, i, e, n, null),
            n.onAfterShadow(t, n, r, s, i, e, null);
        }
      }
      const l = n.children;
      for (let t = 0, e = l.length; t < e; t++) y(l[t], r, s, a, o);
    }
    function S(t) {
      t.target.removeEventListener("dispose", S);
      for (const e in c) {
        const n = c[e],
          i = t.target.uuid;
        i in n && (n[i].dispose(), delete n[i]);
      }
    }
    this.render = function (e, n, o) {
      if (!1 === g.enabled) return;
      if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
      if (0 === e.length) return;
      const l = t.getRenderTarget(),
        c = t.getActiveCubeFace(),
        h = t.getActiveMipmapLevel(),
        d = t.state;
      d.setBlending(0),
        d.buffers.color.setClear(1, 1, 1, 1),
        d.buffers.depth.setTest(!0),
        d.setScissorTest(!1);
      const p = v !== Zl && this.type === Zl,
        f = v === Zl && this.type !== Zl;
      for (let l = 0, c = e.length; l < c; l++) {
        const c = e[l],
          h = c.shadow;
        if (void 0 === h) {
          console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
          continue;
        }
        if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
        r.copy(h.mapSize);
        const m = h.getFrameExtents();
        if (
          (r.multiply(m),
          s.copy(h.mapSize),
          (r.x > u || r.y > u) &&
            (r.x > u &&
              ((s.x = Math.floor(u / m.x)),
              (r.x = s.x * m.x),
              (h.mapSize.x = s.x)),
            r.y > u &&
              ((s.y = Math.floor(u / m.y)),
              (r.y = s.y * m.y),
              (h.mapSize.y = s.y))),
          null === h.map || !0 === p || !0 === f)
        ) {
          const t = this.type !== Zl ? { minFilter: Nc, magFilter: Nc } : {};
          null !== h.map && h.map.dispose(),
            (h.map = new nh(r.x, r.y, t)),
            (h.map.texture.name = c.name + ".shadowMap"),
            h.camera.updateProjectionMatrix();
        }
        t.setRenderTarget(h.map), t.clear();
        const g = h.getViewportCount();
        for (let t = 0; t < g; t++) {
          const e = h.getViewport(t);
          a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
            d.viewport(a),
            h.updateMatrices(c, t),
            (i = h.getFrustum()),
            y(n, o, h.camera, c, this.type);
        }
        !0 !== h.isPointLightShadow && this.type === Zl && _(h, o),
          (h.needsUpdate = !1);
      }
      (v = this.type), (g.needsUpdate = !1), t.setRenderTarget(l, c, h);
    };
  }
  function rg(t) {
    const e = new (function () {
        let e = !1;
        const n = new th();
        let i = null;
        const r = new th(0, 0, 0, 0);
        return {
          setMask: function (n) {
            i === n || e || (t.colorMask(n, n, n, n), (i = n));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e, i, s, a, o) {
            !0 === o && ((e *= a), (i *= a), (s *= a)),
              n.set(e, i, s, a),
              !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n));
          },
          reset: function () {
            (e = !1), (i = null), r.set(-1, 0, 0, 0);
          },
        };
      })(),
      n = new (function () {
        let e = !1,
          n = null,
          i = null,
          r = null;
        return {
          setTest: function (e) {
            e ? z(t.DEPTH_TEST) : k(t.DEPTH_TEST);
          },
          setMask: function (i) {
            n === i || e || (t.depthMask(i), (n = i));
          },
          setFunc: function (e) {
            if (i !== e) {
              switch (e) {
                case 0:
                  t.depthFunc(t.NEVER);
                  break;
                case 1:
                  t.depthFunc(t.ALWAYS);
                  break;
                case 2:
                  t.depthFunc(t.LESS);
                  break;
                case 3:
                default:
                  t.depthFunc(t.LEQUAL);
                  break;
                case 4:
                  t.depthFunc(t.EQUAL);
                  break;
                case 5:
                  t.depthFunc(t.GEQUAL);
                  break;
                case 6:
                  t.depthFunc(t.GREATER);
                  break;
                case 7:
                  t.depthFunc(t.NOTEQUAL);
              }
              i = e;
            }
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e) {
            r !== e && (t.clearDepth(e), (r = e));
          },
          reset: function () {
            (e = !1), (n = null), (i = null), (r = null);
          },
        };
      })(),
      i = new (function () {
        let e = !1,
          n = null,
          i = null,
          r = null,
          s = null,
          a = null,
          o = null,
          l = null,
          c = null;
        return {
          setTest: function (n) {
            e || (n ? z(t.STENCIL_TEST) : k(t.STENCIL_TEST));
          },
          setMask: function (i) {
            n === i || e || (t.stencilMask(i), (n = i));
          },
          setFunc: function (e, n, a) {
            (i === e && r === n && s === a) ||
              (t.stencilFunc(e, n, a), (i = e), (r = n), (s = a));
          },
          setOp: function (e, n, i) {
            (a === e && o === n && l === i) ||
              (t.stencilOp(e, n, i), (a = e), (o = n), (l = i));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (e) {
            c !== e && (t.clearStencil(e), (c = e));
          },
          reset: function () {
            (e = !1),
              (n = null),
              (i = null),
              (r = null),
              (s = null),
              (a = null),
              (o = null),
              (l = null),
              (c = null);
          },
        };
      })(),
      r = new WeakMap(),
      s = new WeakMap();
    let a = {},
      o = {},
      l = new WeakMap(),
      c = [],
      u = null,
      h = !1,
      d = null,
      p = null,
      f = null,
      m = null,
      g = null,
      v = null,
      _ = null,
      x = new bd(0, 0, 0),
      y = 0,
      S = !1,
      M = null,
      E = null,
      T = null,
      b = null,
      D = null;
    const w = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let C = !1,
      A = 0;
    const R = t.getParameter(t.VERSION);
    -1 !== R.indexOf("WebGL")
      ? ((A = parseFloat(/^WebGL (\d)/.exec(R)[1])), (C = A >= 1))
      : -1 !== R.indexOf("OpenGL ES") &&
        ((A = parseFloat(/^OpenGL ES (\d)/.exec(R)[1])), (C = A >= 2));
    let P = null,
      L = {};
    const I = t.getParameter(t.SCISSOR_BOX),
      U = t.getParameter(t.VIEWPORT),
      N = new th().fromArray(I),
      F = new th().fromArray(U);
    function O(e, n, i, r) {
      const s = new Uint8Array(4),
        a = t.createTexture();
      t.bindTexture(e, a),
        t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
        t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
      for (let a = 0; a < i; a++)
        e === t.TEXTURE_3D || e === t.TEXTURE_2D_ARRAY
          ? t.texImage3D(n, 0, t.RGBA, 1, 1, r, 0, t.RGBA, t.UNSIGNED_BYTE, s)
          : t.texImage2D(n + a, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, s);
      return a;
    }
    const B = {};
    function z(e) {
      !0 !== a[e] && (t.enable(e), (a[e] = !0));
    }
    function k(e) {
      !1 !== a[e] && (t.disable(e), (a[e] = !1));
    }
    (B[t.TEXTURE_2D] = O(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
      (B[t.TEXTURE_CUBE_MAP] = O(
        t.TEXTURE_CUBE_MAP,
        t.TEXTURE_CUBE_MAP_POSITIVE_X,
        6
      )),
      (B[t.TEXTURE_2D_ARRAY] = O(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1)),
      (B[t.TEXTURE_3D] = O(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1)),
      e.setClear(0, 0, 0, 1),
      n.setClear(1),
      i.setClear(0),
      z(t.DEPTH_TEST),
      n.setFunc(3),
      W(!1),
      X(1),
      z(t.CULL_FACE),
      G(0);
    const V = {
      [tc]: t.FUNC_ADD,
      [ec]: t.FUNC_SUBTRACT,
      [nc]: t.FUNC_REVERSE_SUBTRACT,
    };
    (V[103] = t.MIN), (V[104] = t.MAX);
    const H = {
      [ic]: t.ZERO,
      [rc]: t.ONE,
      [sc]: t.SRC_COLOR,
      [oc]: t.SRC_ALPHA,
      [pc]: t.SRC_ALPHA_SATURATE,
      [hc]: t.DST_COLOR,
      [cc]: t.DST_ALPHA,
      [ac]: t.ONE_MINUS_SRC_COLOR,
      [lc]: t.ONE_MINUS_SRC_ALPHA,
      [dc]: t.ONE_MINUS_DST_COLOR,
      [uc]: t.ONE_MINUS_DST_ALPHA,
      [fc]: t.CONSTANT_COLOR,
      [mc]: t.ONE_MINUS_CONSTANT_COLOR,
      [gc]: t.CONSTANT_ALPHA,
      [vc]: t.ONE_MINUS_CONSTANT_ALPHA,
    };
    function G(e, n, i, r, s, a, o, l, c, u) {
      if (0 !== e) {
        if ((!1 === h && (z(t.BLEND), (h = !0)), 5 === e))
          (s = s || n),
            (a = a || i),
            (o = o || r),
            (n === p && s === g) ||
              (t.blendEquationSeparate(V[n], V[s]), (p = n), (g = s)),
            (i === f && r === m && a === v && o === _) ||
              (t.blendFuncSeparate(H[i], H[r], H[a], H[o]),
              (f = i),
              (m = r),
              (v = a),
              (_ = o)),
            (!1 !== l.equals(x) && c === y) ||
              (t.blendColor(l.r, l.g, l.b, c), x.copy(l), (y = c)),
            (d = e),
            (S = !1);
        else if (e !== d || u !== S) {
          if (
            ((p === tc && g === tc) ||
              (t.blendEquation(t.FUNC_ADD), (p = tc), (g = tc)),
            u)
          )
            switch (e) {
              case 1:
                t.blendFuncSeparate(
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA,
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA
                );
                break;
              case 2:
                t.blendFunc(t.ONE, t.ONE);
                break;
              case 3:
                t.blendFuncSeparate(
                  t.ZERO,
                  t.ONE_MINUS_SRC_COLOR,
                  t.ZERO,
                  t.ONE
                );
                break;
              case 4:
                t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e);
            }
          else
            switch (e) {
              case 1:
                t.blendFuncSeparate(
                  t.SRC_ALPHA,
                  t.ONE_MINUS_SRC_ALPHA,
                  t.ONE,
                  t.ONE_MINUS_SRC_ALPHA
                );
                break;
              case 2:
                t.blendFunc(t.SRC_ALPHA, t.ONE);
                break;
              case 3:
                t.blendFuncSeparate(
                  t.ZERO,
                  t.ONE_MINUS_SRC_COLOR,
                  t.ZERO,
                  t.ONE
                );
                break;
              case 4:
                t.blendFunc(t.ZERO, t.SRC_COLOR);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e);
            }
          (f = null),
            (m = null),
            (v = null),
            (_ = null),
            x.set(0, 0, 0),
            (y = 0),
            (d = e),
            (S = u);
        }
      } else !0 === h && (k(t.BLEND), (h = !1));
    }
    function W(e) {
      M !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (M = e));
    }
    function X(e) {
      0 !== e
        ? (z(t.CULL_FACE),
          e !== E &&
            (1 === e
              ? t.cullFace(t.BACK)
              : 2 === e
              ? t.cullFace(t.FRONT)
              : t.cullFace(t.FRONT_AND_BACK)))
        : k(t.CULL_FACE),
        (E = e);
    }
    function q(e, n, i) {
      e
        ? (z(t.POLYGON_OFFSET_FILL),
          (b === n && D === i) || (t.polygonOffset(n, i), (b = n), (D = i)))
        : k(t.POLYGON_OFFSET_FILL);
    }
    return {
      buffers: { color: e, depth: n, stencil: i },
      enable: z,
      disable: k,
      bindFramebuffer: function (e, n) {
        return (
          o[e] !== n &&
          (t.bindFramebuffer(e, n),
          (o[e] = n),
          e === t.DRAW_FRAMEBUFFER && (o[t.FRAMEBUFFER] = n),
          e === t.FRAMEBUFFER && (o[t.DRAW_FRAMEBUFFER] = n),
          !0)
        );
      },
      drawBuffers: function (e, n) {
        let i = c,
          r = !1;
        if (e) {
          (i = l.get(n)), void 0 === i && ((i = []), l.set(n, i));
          const s = e.textures;
          if (i.length !== s.length || i[0] !== t.COLOR_ATTACHMENT0) {
            for (let e = 0, n = s.length; e < n; e++)
              i[e] = t.COLOR_ATTACHMENT0 + e;
            (i.length = s.length), (r = !0);
          }
        } else i[0] !== t.BACK && ((i[0] = t.BACK), (r = !0));
        r && t.drawBuffers(i);
      },
      useProgram: function (e) {
        return u !== e && (t.useProgram(e), (u = e), !0);
      },
      setBlending: G,
      setMaterial: function (r, s) {
        2 === r.side ? k(t.CULL_FACE) : z(t.CULL_FACE);
        let a = 1 === r.side;
        s && (a = !a),
          W(a),
          1 === r.blending && !1 === r.transparent
            ? G(0)
            : G(
                r.blending,
                r.blendEquation,
                r.blendSrc,
                r.blendDst,
                r.blendEquationAlpha,
                r.blendSrcAlpha,
                r.blendDstAlpha,
                r.blendColor,
                r.blendAlpha,
                r.premultipliedAlpha
              ),
          n.setFunc(r.depthFunc),
          n.setTest(r.depthTest),
          n.setMask(r.depthWrite),
          e.setMask(r.colorWrite);
        const o = r.stencilWrite;
        i.setTest(o),
          o &&
            (i.setMask(r.stencilWriteMask),
            i.setFunc(r.stencilFunc, r.stencilRef, r.stencilFuncMask),
            i.setOp(r.stencilFail, r.stencilZFail, r.stencilZPass)),
          q(r.polygonOffset, r.polygonOffsetFactor, r.polygonOffsetUnits),
          !0 === r.alphaToCoverage
            ? z(t.SAMPLE_ALPHA_TO_COVERAGE)
            : k(t.SAMPLE_ALPHA_TO_COVERAGE);
      },
      setFlipSided: W,
      setCullFace: X,
      setLineWidth: function (e) {
        e !== T && (C && t.lineWidth(e), (T = e));
      },
      setPolygonOffset: q,
      setScissorTest: function (e) {
        e ? z(t.SCISSOR_TEST) : k(t.SCISSOR_TEST);
      },
      activeTexture: function (e) {
        void 0 === e && (e = t.TEXTURE0 + w - 1),
          P !== e && (t.activeTexture(e), (P = e));
      },
      bindTexture: function (e, n, i) {
        void 0 === i && (i = null === P ? t.TEXTURE0 + w - 1 : P);
        let r = L[i];
        void 0 === r && ((r = { type: void 0, texture: void 0 }), (L[i] = r)),
          (r.type === e && r.texture === n) ||
            (P !== i && (t.activeTexture(i), (P = i)),
            t.bindTexture(e, n || B[e]),
            (r.type = e),
            (r.texture = n));
      },
      unbindTexture: function () {
        const e = L[P];
        void 0 !== e &&
          void 0 !== e.type &&
          (t.bindTexture(e.type, null),
          (e.type = void 0),
          (e.texture = void 0));
      },
      compressedTexImage2D: function () {
        try {
          t.compressedTexImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      compressedTexImage3D: function () {
        try {
          t.compressedTexImage3D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      texImage2D: function () {
        try {
          t.texImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      texImage3D: function () {
        try {
          t.texImage3D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      updateUBOMapping: function (e, n) {
        let i = s.get(n);
        void 0 === i && ((i = new WeakMap()), s.set(n, i));
        let r = i.get(e);
        void 0 === r && ((r = t.getUniformBlockIndex(n, e.name)), i.set(e, r));
      },
      uniformBlockBinding: function (e, n) {
        const i = s.get(n).get(e);
        r.get(n) !== i &&
          (t.uniformBlockBinding(n, i, e.__bindingPointIndex), r.set(n, i));
      },
      texStorage2D: function () {
        try {
          t.texStorage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      texStorage3D: function () {
        try {
          t.texStorage3D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      texSubImage2D: function () {
        try {
          t.texSubImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      texSubImage3D: function () {
        try {
          t.texSubImage3D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      compressedTexSubImage2D: function () {
        try {
          t.compressedTexSubImage2D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      compressedTexSubImage3D: function () {
        try {
          t.compressedTexSubImage3D.apply(t, arguments);
        } catch (t) {
          console.error("THREE.WebGLState:", t);
        }
      },
      scissor: function (e) {
        !1 === N.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), N.copy(e));
      },
      viewport: function (e) {
        !1 === F.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), F.copy(e));
      },
      reset: function () {
        t.disable(t.BLEND),
          t.disable(t.CULL_FACE),
          t.disable(t.DEPTH_TEST),
          t.disable(t.POLYGON_OFFSET_FILL),
          t.disable(t.SCISSOR_TEST),
          t.disable(t.STENCIL_TEST),
          t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
          t.blendEquation(t.FUNC_ADD),
          t.blendFunc(t.ONE, t.ZERO),
          t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
          t.blendColor(0, 0, 0, 0),
          t.colorMask(!0, !0, !0, !0),
          t.clearColor(0, 0, 0, 0),
          t.depthMask(!0),
          t.depthFunc(t.LESS),
          t.clearDepth(1),
          t.stencilMask(4294967295),
          t.stencilFunc(t.ALWAYS, 0, 4294967295),
          t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
          t.clearStencil(0),
          t.cullFace(t.BACK),
          t.frontFace(t.CCW),
          t.polygonOffset(0, 0),
          t.activeTexture(t.TEXTURE0),
          t.bindFramebuffer(t.FRAMEBUFFER, null),
          t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
          t.bindFramebuffer(t.READ_FRAMEBUFFER, null),
          t.useProgram(null),
          t.lineWidth(1),
          t.scissor(0, 0, t.canvas.width, t.canvas.height),
          t.viewport(0, 0, t.canvas.width, t.canvas.height),
          (a = {}),
          (P = null),
          (L = {}),
          (o = {}),
          (l = new WeakMap()),
          (c = []),
          (u = null),
          (h = !1),
          (d = null),
          (p = null),
          (f = null),
          (m = null),
          (g = null),
          (v = null),
          (_ = null),
          (x = new bd(0, 0, 0)),
          (y = 0),
          (S = !1),
          (M = null),
          (E = null),
          (T = null),
          (b = null),
          (D = null),
          N.set(0, 0, t.canvas.width, t.canvas.height),
          F.set(0, 0, t.canvas.width, t.canvas.height),
          e.reset(),
          n.reset(),
          i.reset();
      },
    };
  }
  function sg(t, e, n, i, r, s, a) {
    const o = e.has("WEBGL_multisampled_render_to_texture")
        ? e.get("WEBGL_multisampled_render_to_texture")
        : null,
      l =
        "undefined" != typeof navigator &&
        /OculusBrowser/g.test(navigator.userAgent),
      c = new Iu(),
      u = new WeakMap();
    let h;
    const d = new WeakMap();
    let p = !1;
    try {
      p =
        "undefined" != typeof OffscreenCanvas &&
        null !== new OffscreenCanvas(1, 1).getContext("2d");
    } catch (t) {}
    function f(t, e) {
      return p ? new OffscreenCanvas(t, e) : Ou("canvas");
    }
    function m(t, e, n) {
      let i = 1;
      const r = z(t);
      if (
        ((r.width > n || r.height > n) && (i = n / Math.max(r.width, r.height)),
        i < 1)
      ) {
        if (
          ("undefined" != typeof HTMLImageElement &&
            t instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            t instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap) ||
          ("undefined" != typeof VideoFrame && t instanceof VideoFrame)
        ) {
          const n = Math.floor(i * r.width),
            s = Math.floor(i * r.height);
          void 0 === h && (h = f(n, s));
          const a = e ? f(n, s) : h;
          return (
            (a.width = n),
            (a.height = s),
            a.getContext("2d").drawImage(t, 0, 0, n, s),
            console.warn(
              "THREE.WebGLRenderer: Texture has been resized from (" +
                r.width +
                "x" +
                r.height +
                ") to (" +
                n +
                "x" +
                s +
                ")."
            ),
            a
          );
        }
        return (
          "data" in t &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                r.width +
                "x" +
                r.height +
                ")."
            ),
          t
        );
      }
      return t;
    }
    function g(t) {
      return t.generateMipmaps && t.minFilter !== Nc && t.minFilter !== Bc;
    }
    function v(e) {
      t.generateMipmap(e);
    }
    function _(n, i, r, s, a = !1) {
      if (null !== n) {
        if (void 0 !== t[n]) return t[n];
        console.warn(
          "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
            n +
            "'"
        );
      }
      let o = i;
      if (
        (i === t.RED &&
          (r === t.FLOAT && (o = t.R32F),
          r === t.HALF_FLOAT && (o = t.R16F),
          r === t.UNSIGNED_BYTE && (o = t.R8)),
        i === t.RED_INTEGER &&
          (r === t.UNSIGNED_BYTE && (o = t.R8UI),
          r === t.UNSIGNED_SHORT && (o = t.R16UI),
          r === t.UNSIGNED_INT && (o = t.R32UI),
          r === t.BYTE && (o = t.R8I),
          r === t.SHORT && (o = t.R16I),
          r === t.INT && (o = t.R32I)),
        i === t.RG &&
          (r === t.FLOAT && (o = t.RG32F),
          r === t.HALF_FLOAT && (o = t.RG16F),
          r === t.UNSIGNED_BYTE && (o = t.RG8)),
        i === t.RG_INTEGER &&
          (r === t.UNSIGNED_BYTE && (o = t.RG8UI),
          r === t.UNSIGNED_SHORT && (o = t.RG16UI),
          r === t.UNSIGNED_INT && (o = t.RG32UI),
          r === t.BYTE && (o = t.RG8I),
          r === t.SHORT && (o = t.RG16I),
          r === t.INT && (o = t.RG32I)),
        i === t.RGB && r === t.UNSIGNED_INT_5_9_9_9_REV && (o = t.RGB9_E5),
        i === t.RGBA)
      ) {
        const e = a ? lu : Wu.getTransfer(s);
        r === t.FLOAT && (o = t.RGBA32F),
          r === t.HALF_FLOAT && (o = t.RGBA16F),
          r === t.UNSIGNED_BYTE && (o = e === cu ? t.SRGB8_ALPHA8 : t.RGBA8),
          r === t.UNSIGNED_SHORT_4_4_4_4 && (o = t.RGBA4),
          r === t.UNSIGNED_SHORT_5_5_5_1 && (o = t.RGB5_A1);
      }
      return (
        (o !== t.R16F &&
          o !== t.R32F &&
          o !== t.RG16F &&
          o !== t.RG32F &&
          o !== t.RGBA16F &&
          o !== t.RGBA32F) ||
          e.get("EXT_color_buffer_float"),
        o
      );
    }
    function x(t, e) {
      return !0 === g(t) ||
        (t.isFramebufferTexture && t.minFilter !== Nc && t.minFilter !== Bc)
        ? Math.log2(Math.max(e.width, e.height)) + 1
        : void 0 !== t.mipmaps && t.mipmaps.length > 0
        ? t.mipmaps.length
        : t.isCompressedTexture && Array.isArray(t.image)
        ? e.mipmaps.length
        : 1;
    }
    function y(t) {
      const e = t.target;
      e.removeEventListener("dispose", y),
        (function (t) {
          const e = i.get(t);
          if (void 0 === e.__webglInit) return;
          const n = t.source,
            r = d.get(n);
          if (r) {
            const i = r[e.__cacheKey];
            i.usedTimes--,
              0 === i.usedTimes && M(t),
              0 === Object.keys(r).length && d.delete(n);
          }
          i.remove(t);
        })(e),
        e.isVideoTexture && u.delete(e);
    }
    function S(e) {
      const n = e.target;
      n.removeEventListener("dispose", S),
        (function (e) {
          const n = i.get(e);
          if (
            (e.depthTexture && e.depthTexture.dispose(),
            e.isWebGLCubeRenderTarget)
          )
            for (let e = 0; e < 6; e++) {
              if (Array.isArray(n.__webglFramebuffer[e]))
                for (let i = 0; i < n.__webglFramebuffer[e].length; i++)
                  t.deleteFramebuffer(n.__webglFramebuffer[e][i]);
              else t.deleteFramebuffer(n.__webglFramebuffer[e]);
              n.__webglDepthbuffer &&
                t.deleteRenderbuffer(n.__webglDepthbuffer[e]);
            }
          else {
            if (Array.isArray(n.__webglFramebuffer))
              for (let e = 0; e < n.__webglFramebuffer.length; e++)
                t.deleteFramebuffer(n.__webglFramebuffer[e]);
            else t.deleteFramebuffer(n.__webglFramebuffer);
            if (
              (n.__webglDepthbuffer &&
                t.deleteRenderbuffer(n.__webglDepthbuffer),
              n.__webglMultisampledFramebuffer &&
                t.deleteFramebuffer(n.__webglMultisampledFramebuffer),
              n.__webglColorRenderbuffer)
            )
              for (let e = 0; e < n.__webglColorRenderbuffer.length; e++)
                n.__webglColorRenderbuffer[e] &&
                  t.deleteRenderbuffer(n.__webglColorRenderbuffer[e]);
            n.__webglDepthRenderbuffer &&
              t.deleteRenderbuffer(n.__webglDepthRenderbuffer);
          }
          const r = e.textures;
          for (let e = 0, n = r.length; e < n; e++) {
            const n = i.get(r[e]);
            n.__webglTexture &&
              (t.deleteTexture(n.__webglTexture), a.memory.textures--),
              i.remove(r[e]);
          }
          i.remove(e);
        })(n);
    }
    function M(e) {
      const n = i.get(e);
      t.deleteTexture(n.__webglTexture);
      const r = e.source;
      delete d.get(r)[n.__cacheKey], a.memory.textures--;
    }
    let E = 0;
    function T(e, r) {
      const s = i.get(e);
      if (
        (e.isVideoTexture &&
          (function (t) {
            const e = a.render.frame;
            u.get(t) !== e && (u.set(t, e), t.update());
          })(e),
        !1 === e.isRenderTargetTexture &&
          e.version > 0 &&
          s.__version !== e.version)
      ) {
        const t = e.image;
        if (null === t)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but no image data found."
          );
        else {
          if (!1 !== t.complete) return void R(s, e, r);
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
          );
        }
      }
      n.bindTexture(t.TEXTURE_2D, s.__webglTexture, t.TEXTURE0 + r);
    }
    const b = {
        [Lc]: t.REPEAT,
        [Ic]: t.CLAMP_TO_EDGE,
        [Uc]: t.MIRRORED_REPEAT,
      },
      D = {
        [Nc]: t.NEAREST,
        [Fc]: t.NEAREST_MIPMAP_NEAREST,
        [Oc]: t.NEAREST_MIPMAP_LINEAR,
        [Bc]: t.LINEAR,
        [zc]: t.LINEAR_MIPMAP_NEAREST,
        [kc]: t.LINEAR_MIPMAP_LINEAR,
      },
      w = {
        [pu]: t.NEVER,
        [yu]: t.ALWAYS,
        [fu]: t.LESS,
        [gu]: t.LEQUAL,
        [mu]: t.EQUAL,
        [xu]: t.GEQUAL,
        [vu]: t.GREATER,
        [_u]: t.NOTEQUAL,
      };
    function C(n, s) {
      if (
        (s.type !== Gc ||
          !1 !== e.has("OES_texture_float_linear") ||
          (s.magFilter !== Bc &&
            s.magFilter !== zc &&
            s.magFilter !== Oc &&
            s.magFilter !== kc &&
            s.minFilter !== Bc &&
            s.minFilter !== zc &&
            s.minFilter !== Oc &&
            s.minFilter !== kc) ||
          console.warn(
            "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
          ),
        t.texParameteri(n, t.TEXTURE_WRAP_S, b[s.wrapS]),
        t.texParameteri(n, t.TEXTURE_WRAP_T, b[s.wrapT]),
        (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
          t.texParameteri(n, t.TEXTURE_WRAP_R, b[s.wrapR]),
        t.texParameteri(n, t.TEXTURE_MAG_FILTER, D[s.magFilter]),
        t.texParameteri(n, t.TEXTURE_MIN_FILTER, D[s.minFilter]),
        s.compareFunction &&
          (t.texParameteri(n, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
          t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, w[s.compareFunction])),
        !0 === e.has("EXT_texture_filter_anisotropic"))
      ) {
        if (s.magFilter === Nc) return;
        if (s.minFilter !== Oc && s.minFilter !== kc) return;
        if (s.type === Gc && !1 === e.has("OES_texture_float_linear")) return;
        if (s.anisotropy > 1 || i.get(s).__currentAnisotropy) {
          const a = e.get("EXT_texture_filter_anisotropic");
          t.texParameterf(
            n,
            a.TEXTURE_MAX_ANISOTROPY_EXT,
            Math.min(s.anisotropy, r.getMaxAnisotropy())
          ),
            (i.get(s).__currentAnisotropy = s.anisotropy);
        }
      }
    }
    function A(e, n) {
      let i = !1;
      void 0 === e.__webglInit &&
        ((e.__webglInit = !0), n.addEventListener("dispose", y));
      const r = n.source;
      let s = d.get(r);
      void 0 === s && ((s = {}), d.set(r, s));
      const o = (function (t) {
        const e = [];
        return (
          e.push(t.wrapS),
          e.push(t.wrapT),
          e.push(t.wrapR || 0),
          e.push(t.magFilter),
          e.push(t.minFilter),
          e.push(t.anisotropy),
          e.push(t.internalFormat),
          e.push(t.format),
          e.push(t.type),
          e.push(t.generateMipmaps),
          e.push(t.premultiplyAlpha),
          e.push(t.flipY),
          e.push(t.unpackAlignment),
          e.push(t.colorSpace),
          e.join()
        );
      })(n);
      if (o !== e.__cacheKey) {
        void 0 === s[o] &&
          ((s[o] = { texture: t.createTexture(), usedTimes: 0 }),
          a.memory.textures++,
          (i = !0)),
          s[o].usedTimes++;
        const r = s[e.__cacheKey];
        void 0 !== r &&
          (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && M(n)),
          (e.__cacheKey = o),
          (e.__webglTexture = s[o].texture);
      }
      return i;
    }
    function R(e, a, o) {
      let l = t.TEXTURE_2D;
      (a.isDataArrayTexture || a.isCompressedArrayTexture) &&
        (l = t.TEXTURE_2D_ARRAY),
        a.isData3DTexture && (l = t.TEXTURE_3D);
      const c = A(e, a),
        u = a.source;
      n.bindTexture(l, e.__webglTexture, t.TEXTURE0 + o);
      const h = i.get(u);
      if (u.version !== h.__version || !0 === c) {
        n.activeTexture(t.TEXTURE0 + o);
        const e = Wu.getPrimaries(Wu.workingColorSpace),
          i = a.colorSpace === iu ? null : Wu.getPrimaries(a.colorSpace),
          d = a.colorSpace === iu || e === i ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY),
          t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
          t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment),
          t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
        let p = m(a.image, !1, r.maxTextureSize);
        p = B(a, p);
        const f = s.convert(a.format, a.colorSpace),
          y = s.convert(a.type);
        let S,
          M = _(a.internalFormat, f, y, a.colorSpace, a.isVideoTexture);
        C(l, a);
        const E = a.mipmaps,
          T = !0 !== a.isVideoTexture,
          b = void 0 === h.__version || !0 === c,
          D = u.dataReady,
          w = x(a, p);
        if (a.isDepthTexture)
          (M = t.DEPTH_COMPONENT16),
            a.type === Gc
              ? (M = t.DEPTH_COMPONENT32F)
              : a.type === Hc
              ? (M = t.DEPTH_COMPONENT24)
              : a.type === Xc && (M = t.DEPTH24_STENCIL8),
            b &&
              (T
                ? n.texStorage2D(t.TEXTURE_2D, 1, M, p.width, p.height)
                : n.texImage2D(
                    t.TEXTURE_2D,
                    0,
                    M,
                    p.width,
                    p.height,
                    0,
                    f,
                    y,
                    null
                  ));
        else if (a.isDataTexture)
          if (E.length > 0) {
            T &&
              b &&
              n.texStorage2D(t.TEXTURE_2D, w, M, E[0].width, E[0].height);
            for (let e = 0, i = E.length; e < i; e++)
              (S = E[e]),
                T
                  ? D &&
                    n.texSubImage2D(
                      t.TEXTURE_2D,
                      e,
                      0,
                      0,
                      S.width,
                      S.height,
                      f,
                      y,
                      S.data
                    )
                  : n.texImage2D(
                      t.TEXTURE_2D,
                      e,
                      M,
                      S.width,
                      S.height,
                      0,
                      f,
                      y,
                      S.data
                    );
            a.generateMipmaps = !1;
          } else
            T
              ? (b && n.texStorage2D(t.TEXTURE_2D, w, M, p.width, p.height),
                D &&
                  n.texSubImage2D(
                    t.TEXTURE_2D,
                    0,
                    0,
                    0,
                    p.width,
                    p.height,
                    f,
                    y,
                    p.data
                  ))
              : n.texImage2D(
                  t.TEXTURE_2D,
                  0,
                  M,
                  p.width,
                  p.height,
                  0,
                  f,
                  y,
                  p.data
                );
        else if (a.isCompressedTexture)
          if (a.isCompressedArrayTexture) {
            T &&
              b &&
              n.texStorage3D(
                t.TEXTURE_2D_ARRAY,
                w,
                M,
                E[0].width,
                E[0].height,
                p.depth
              );
            for (let e = 0, i = E.length; e < i; e++)
              (S = E[e]),
                a.format !== qc
                  ? null !== f
                    ? T
                      ? D &&
                        n.compressedTexSubImage3D(
                          t.TEXTURE_2D_ARRAY,
                          e,
                          0,
                          0,
                          0,
                          S.width,
                          S.height,
                          p.depth,
                          f,
                          S.data,
                          0,
                          0
                        )
                      : n.compressedTexImage3D(
                          t.TEXTURE_2D_ARRAY,
                          e,
                          M,
                          S.width,
                          S.height,
                          p.depth,
                          0,
                          S.data,
                          0,
                          0
                        )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : T
                  ? D &&
                    n.texSubImage3D(
                      t.TEXTURE_2D_ARRAY,
                      e,
                      0,
                      0,
                      0,
                      S.width,
                      S.height,
                      p.depth,
                      f,
                      y,
                      S.data
                    )
                  : n.texImage3D(
                      t.TEXTURE_2D_ARRAY,
                      e,
                      M,
                      S.width,
                      S.height,
                      p.depth,
                      0,
                      f,
                      y,
                      S.data
                    );
          } else {
            T &&
              b &&
              n.texStorage2D(t.TEXTURE_2D, w, M, E[0].width, E[0].height);
            for (let e = 0, i = E.length; e < i; e++)
              (S = E[e]),
                a.format !== qc
                  ? null !== f
                    ? T
                      ? D &&
                        n.compressedTexSubImage2D(
                          t.TEXTURE_2D,
                          e,
                          0,
                          0,
                          S.width,
                          S.height,
                          f,
                          S.data
                        )
                      : n.compressedTexImage2D(
                          t.TEXTURE_2D,
                          e,
                          M,
                          S.width,
                          S.height,
                          0,
                          S.data
                        )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : T
                  ? D &&
                    n.texSubImage2D(
                      t.TEXTURE_2D,
                      e,
                      0,
                      0,
                      S.width,
                      S.height,
                      f,
                      y,
                      S.data
                    )
                  : n.texImage2D(
                      t.TEXTURE_2D,
                      e,
                      M,
                      S.width,
                      S.height,
                      0,
                      f,
                      y,
                      S.data
                    );
          }
        else if (a.isDataArrayTexture)
          T
            ? (b &&
                n.texStorage3D(
                  t.TEXTURE_2D_ARRAY,
                  w,
                  M,
                  p.width,
                  p.height,
                  p.depth
                ),
              D &&
                n.texSubImage3D(
                  t.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  0,
                  p.width,
                  p.height,
                  p.depth,
                  f,
                  y,
                  p.data
                ))
            : n.texImage3D(
                t.TEXTURE_2D_ARRAY,
                0,
                M,
                p.width,
                p.height,
                p.depth,
                0,
                f,
                y,
                p.data
              );
        else if (a.isData3DTexture)
          T
            ? (b &&
                n.texStorage3D(t.TEXTURE_3D, w, M, p.width, p.height, p.depth),
              D &&
                n.texSubImage3D(
                  t.TEXTURE_3D,
                  0,
                  0,
                  0,
                  0,
                  p.width,
                  p.height,
                  p.depth,
                  f,
                  y,
                  p.data
                ))
            : n.texImage3D(
                t.TEXTURE_3D,
                0,
                M,
                p.width,
                p.height,
                p.depth,
                0,
                f,
                y,
                p.data
              );
        else if (a.isFramebufferTexture) {
          if (b)
            if (T) n.texStorage2D(t.TEXTURE_2D, w, M, p.width, p.height);
            else {
              let e = p.width,
                i = p.height;
              for (let r = 0; r < w; r++)
                n.texImage2D(t.TEXTURE_2D, r, M, e, i, 0, f, y, null),
                  (e >>= 1),
                  (i >>= 1);
            }
        } else if (E.length > 0) {
          if (T && b) {
            const e = z(E[0]);
            n.texStorage2D(t.TEXTURE_2D, w, M, e.width, e.height);
          }
          for (let e = 0, i = E.length; e < i; e++)
            (S = E[e]),
              T
                ? D && n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, f, y, S)
                : n.texImage2D(t.TEXTURE_2D, e, M, f, y, S);
          a.generateMipmaps = !1;
        } else if (T) {
          if (b) {
            const e = z(p);
            n.texStorage2D(t.TEXTURE_2D, w, M, e.width, e.height);
          }
          D && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, f, y, p);
        } else n.texImage2D(t.TEXTURE_2D, 0, M, f, y, p);
        g(a) && v(l), (h.__version = u.version), a.onUpdate && a.onUpdate(a);
      }
      e.__version = a.version;
    }
    function P(e, r, a, l, c, u) {
      const h = s.convert(a.format, a.colorSpace),
        d = s.convert(a.type),
        p = _(a.internalFormat, h, d, a.colorSpace);
      if (!i.get(r).__hasExternalTextures) {
        const e = Math.max(1, r.width >> u),
          i = Math.max(1, r.height >> u);
        c === t.TEXTURE_3D || c === t.TEXTURE_2D_ARRAY
          ? n.texImage3D(c, u, p, e, i, r.depth, 0, h, d, null)
          : n.texImage2D(c, u, p, e, i, 0, h, d, null);
      }
      n.bindFramebuffer(t.FRAMEBUFFER, e),
        O(r)
          ? o.framebufferTexture2DMultisampleEXT(
              t.FRAMEBUFFER,
              l,
              c,
              i.get(a).__webglTexture,
              0,
              F(r)
            )
          : (c === t.TEXTURE_2D ||
              (c >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
                c <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
            t.framebufferTexture2D(
              t.FRAMEBUFFER,
              l,
              c,
              i.get(a).__webglTexture,
              u
            ),
        n.bindFramebuffer(t.FRAMEBUFFER, null);
    }
    function L(e, n, i) {
      if (
        (t.bindRenderbuffer(t.RENDERBUFFER, e),
        n.depthBuffer && !n.stencilBuffer)
      ) {
        let r = t.DEPTH_COMPONENT24;
        if (i || O(n)) {
          const e = n.depthTexture;
          e &&
            e.isDepthTexture &&
            (e.type === Gc
              ? (r = t.DEPTH_COMPONENT32F)
              : e.type === Hc && (r = t.DEPTH_COMPONENT24));
          const i = F(n);
          O(n)
            ? o.renderbufferStorageMultisampleEXT(
                t.RENDERBUFFER,
                i,
                r,
                n.width,
                n.height
              )
            : t.renderbufferStorageMultisample(
                t.RENDERBUFFER,
                i,
                r,
                n.width,
                n.height
              );
        } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
        t.framebufferRenderbuffer(
          t.FRAMEBUFFER,
          t.DEPTH_ATTACHMENT,
          t.RENDERBUFFER,
          e
        );
      } else if (n.depthBuffer && n.stencilBuffer) {
        const r = F(n);
        i && !1 === O(n)
          ? t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              r,
              t.DEPTH24_STENCIL8,
              n.width,
              n.height
            )
          : O(n)
          ? o.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              r,
              t.DEPTH24_STENCIL8,
              n.width,
              n.height
            )
          : t.renderbufferStorage(
              t.RENDERBUFFER,
              t.DEPTH_STENCIL,
              n.width,
              n.height
            ),
          t.framebufferRenderbuffer(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.RENDERBUFFER,
            e
          );
      } else {
        const e = n.textures;
        for (let r = 0; r < e.length; r++) {
          const a = e[r],
            l = s.convert(a.format, a.colorSpace),
            c = s.convert(a.type),
            u = _(a.internalFormat, l, c, a.colorSpace),
            h = F(n);
          i && !1 === O(n)
            ? t.renderbufferStorageMultisample(
                t.RENDERBUFFER,
                h,
                u,
                n.width,
                n.height
              )
            : O(n)
            ? o.renderbufferStorageMultisampleEXT(
                t.RENDERBUFFER,
                h,
                u,
                n.width,
                n.height
              )
            : t.renderbufferStorage(t.RENDERBUFFER, u, n.width, n.height);
        }
      }
      t.bindRenderbuffer(t.RENDERBUFFER, null);
    }
    function I(e) {
      const r = i.get(e),
        s = !0 === e.isWebGLCubeRenderTarget;
      if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
        if (s)
          throw new Error(
            "target.depthTexture not supported in Cube render targets"
          );
        !(function (e, r) {
          if (r && r.isWebGLCubeRenderTarget)
            throw new Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (
            (n.bindFramebuffer(t.FRAMEBUFFER, e),
            !r.depthTexture || !r.depthTexture.isDepthTexture)
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (i.get(r.depthTexture).__webglTexture &&
            r.depthTexture.image.width === r.width &&
            r.depthTexture.image.height === r.height) ||
            ((r.depthTexture.image.width = r.width),
            (r.depthTexture.image.height = r.height),
            (r.depthTexture.needsUpdate = !0)),
            T(r.depthTexture, 0);
          const s = i.get(r.depthTexture).__webglTexture,
            a = F(r);
          if (r.depthTexture.format === jc)
            O(r)
              ? o.framebufferTexture2DMultisampleEXT(
                  t.FRAMEBUFFER,
                  t.DEPTH_ATTACHMENT,
                  t.TEXTURE_2D,
                  s,
                  0,
                  a
                )
              : t.framebufferTexture2D(
                  t.FRAMEBUFFER,
                  t.DEPTH_ATTACHMENT,
                  t.TEXTURE_2D,
                  s,
                  0
                );
          else {
            if (r.depthTexture.format !== Yc)
              throw new Error("Unknown depthTexture format");
            O(r)
              ? o.framebufferTexture2DMultisampleEXT(
                  t.FRAMEBUFFER,
                  t.DEPTH_STENCIL_ATTACHMENT,
                  t.TEXTURE_2D,
                  s,
                  0,
                  a
                )
              : t.framebufferTexture2D(
                  t.FRAMEBUFFER,
                  t.DEPTH_STENCIL_ATTACHMENT,
                  t.TEXTURE_2D,
                  s,
                  0
                );
          }
        })(r.__webglFramebuffer, e);
      } else if (s) {
        r.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++)
          n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]),
            (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
            L(r.__webglDepthbuffer[i], e, !1);
      } else
        n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer),
          (r.__webglDepthbuffer = t.createRenderbuffer()),
          L(r.__webglDepthbuffer, e, !1);
      n.bindFramebuffer(t.FRAMEBUFFER, null);
    }
    const U = [],
      N = [];
    function F(t) {
      return Math.min(r.maxSamples, t.samples);
    }
    function O(t) {
      const n = i.get(t);
      return (
        t.samples > 0 &&
        !0 === e.has("WEBGL_multisampled_render_to_texture") &&
        !1 !== n.__useRenderToTexture
      );
    }
    function B(t, e) {
      const n = t.colorSpace,
        i = t.format,
        r = t.type;
      return (
        !0 === t.isCompressedTexture ||
          !0 === t.isVideoTexture ||
          (n !== su &&
            n !== iu &&
            (Wu.getTransfer(n) === cu
              ? (i === qc && r === Vc) ||
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
              : console.error(
                  "THREE.WebGLTextures: Unsupported texture color space:",
                  n
                ))),
        e
      );
    }
    function z(t) {
      return (
        "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement
          ? ((c.width = t.naturalWidth || t.width),
            (c.height = t.naturalHeight || t.height))
          : "undefined" != typeof VideoFrame && t instanceof VideoFrame
          ? ((c.width = t.displayWidth), (c.height = t.displayHeight))
          : ((c.width = t.width), (c.height = t.height)),
        c
      );
    }
    (this.allocateTextureUnit = function () {
      const t = E;
      return (
        t >= r.maxTextures &&
          console.warn(
            "THREE.WebGLTextures: Trying to use " +
              t +
              " texture units while this GPU supports only " +
              r.maxTextures
          ),
        (E += 1),
        t
      );
    }),
      (this.resetTextureUnits = function () {
        E = 0;
      }),
      (this.setTexture2D = T),
      (this.setTexture2DArray = function (e, r) {
        const s = i.get(e);
        e.version > 0 && s.__version !== e.version
          ? R(s, e, r)
          : n.bindTexture(t.TEXTURE_2D_ARRAY, s.__webglTexture, t.TEXTURE0 + r);
      }),
      (this.setTexture3D = function (e, r) {
        const s = i.get(e);
        e.version > 0 && s.__version !== e.version
          ? R(s, e, r)
          : n.bindTexture(t.TEXTURE_3D, s.__webglTexture, t.TEXTURE0 + r);
      }),
      (this.setTextureCube = function (e, a) {
        const o = i.get(e);
        e.version > 0 && o.__version !== e.version
          ? (function (e, a, o) {
              if (6 !== a.image.length) return;
              const l = A(e, a),
                c = a.source;
              n.bindTexture(
                t.TEXTURE_CUBE_MAP,
                e.__webglTexture,
                t.TEXTURE0 + o
              );
              const u = i.get(c);
              if (c.version !== u.__version || !0 === l) {
                n.activeTexture(t.TEXTURE0 + o);
                const e = Wu.getPrimaries(Wu.workingColorSpace),
                  i =
                    a.colorSpace === iu ? null : Wu.getPrimaries(a.colorSpace),
                  h =
                    a.colorSpace === iu || e === i
                      ? t.NONE
                      : t.BROWSER_DEFAULT_WEBGL;
                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, a.flipY),
                  t.pixelStorei(
                    t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                    a.premultiplyAlpha
                  ),
                  t.pixelStorei(t.UNPACK_ALIGNMENT, a.unpackAlignment),
                  t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, h);
                const d =
                    a.isCompressedTexture || a.image[0].isCompressedTexture,
                  p = a.image[0] && a.image[0].isDataTexture,
                  f = [];
                for (let t = 0; t < 6; t++)
                  (f[t] =
                    d || p
                      ? p
                        ? a.image[t].image
                        : a.image[t]
                      : m(a.image[t], !0, r.maxCubemapSize)),
                    (f[t] = B(a, f[t]));
                const y = f[0],
                  S = s.convert(a.format, a.colorSpace),
                  M = s.convert(a.type),
                  E = _(a.internalFormat, S, M, a.colorSpace),
                  T = !0 !== a.isVideoTexture,
                  b = void 0 === u.__version || !0 === l,
                  D = c.dataReady;
                let w,
                  A = x(a, y);
                if ((C(t.TEXTURE_CUBE_MAP, a), d)) {
                  T &&
                    b &&
                    n.texStorage2D(t.TEXTURE_CUBE_MAP, A, E, y.width, y.height);
                  for (let e = 0; e < 6; e++) {
                    w = f[e].mipmaps;
                    for (let i = 0; i < w.length; i++) {
                      const r = w[i];
                      a.format !== qc
                        ? null !== S
                          ? T
                            ? D &&
                              n.compressedTexSubImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                i,
                                0,
                                0,
                                r.width,
                                r.height,
                                S,
                                r.data
                              )
                            : n.compressedTexImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                i,
                                E,
                                r.width,
                                r.height,
                                0,
                                r.data
                              )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                            )
                        : T
                        ? D &&
                          n.texSubImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            i,
                            0,
                            0,
                            r.width,
                            r.height,
                            S,
                            M,
                            r.data
                          )
                        : n.texImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            i,
                            E,
                            r.width,
                            r.height,
                            0,
                            S,
                            M,
                            r.data
                          );
                    }
                  }
                } else {
                  if (((w = a.mipmaps), T && b)) {
                    w.length > 0 && A++;
                    const e = z(f[0]);
                    n.texStorage2D(t.TEXTURE_CUBE_MAP, A, E, e.width, e.height);
                  }
                  for (let e = 0; e < 6; e++)
                    if (p) {
                      T
                        ? D &&
                          n.texSubImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            0,
                            0,
                            0,
                            f[e].width,
                            f[e].height,
                            S,
                            M,
                            f[e].data
                          )
                        : n.texImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            0,
                            E,
                            f[e].width,
                            f[e].height,
                            0,
                            S,
                            M,
                            f[e].data
                          );
                      for (let i = 0; i < w.length; i++) {
                        const r = w[i].image[e].image;
                        T
                          ? D &&
                            n.texSubImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i + 1,
                              0,
                              0,
                              r.width,
                              r.height,
                              S,
                              M,
                              r.data
                            )
                          : n.texImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i + 1,
                              E,
                              r.width,
                              r.height,
                              0,
                              S,
                              M,
                              r.data
                            );
                      }
                    } else {
                      T
                        ? D &&
                          n.texSubImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            0,
                            0,
                            0,
                            S,
                            M,
                            f[e]
                          )
                        : n.texImage2D(
                            t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                            0,
                            E,
                            S,
                            M,
                            f[e]
                          );
                      for (let i = 0; i < w.length; i++) {
                        const r = w[i];
                        T
                          ? D &&
                            n.texSubImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i + 1,
                              0,
                              0,
                              S,
                              M,
                              r.image[e]
                            )
                          : n.texImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i + 1,
                              E,
                              S,
                              M,
                              r.image[e]
                            );
                      }
                    }
                }
                g(a) && v(t.TEXTURE_CUBE_MAP),
                  (u.__version = c.version),
                  a.onUpdate && a.onUpdate(a);
              }
              e.__version = a.version;
            })(o, e, a)
          : n.bindTexture(t.TEXTURE_CUBE_MAP, o.__webglTexture, t.TEXTURE0 + a);
      }),
      (this.rebindTextures = function (e, n, r) {
        const s = i.get(e);
        void 0 !== n &&
          P(
            s.__webglFramebuffer,
            e,
            e.texture,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_2D,
            0
          ),
          void 0 !== r && I(e);
      }),
      (this.setupRenderTarget = function (e) {
        const r = e.texture,
          o = i.get(e),
          l = i.get(r);
        e.addEventListener("dispose", S);
        const c = e.textures,
          u = !0 === e.isWebGLCubeRenderTarget,
          h = c.length > 1;
        if (
          (h ||
            (void 0 === l.__webglTexture &&
              (l.__webglTexture = t.createTexture()),
            (l.__version = r.version),
            a.memory.textures++),
          u)
        ) {
          o.__webglFramebuffer = [];
          for (let e = 0; e < 6; e++)
            if (r.mipmaps && r.mipmaps.length > 0) {
              o.__webglFramebuffer[e] = [];
              for (let n = 0; n < r.mipmaps.length; n++)
                o.__webglFramebuffer[e][n] = t.createFramebuffer();
            } else o.__webglFramebuffer[e] = t.createFramebuffer();
        } else {
          if (r.mipmaps && r.mipmaps.length > 0) {
            o.__webglFramebuffer = [];
            for (let e = 0; e < r.mipmaps.length; e++)
              o.__webglFramebuffer[e] = t.createFramebuffer();
          } else o.__webglFramebuffer = t.createFramebuffer();
          if (h)
            for (let e = 0, n = c.length; e < n; e++) {
              const n = i.get(c[e]);
              void 0 === n.__webglTexture &&
                ((n.__webglTexture = t.createTexture()), a.memory.textures++);
            }
          if (e.samples > 0 && !1 === O(e)) {
            (o.__webglMultisampledFramebuffer = t.createFramebuffer()),
              (o.__webglColorRenderbuffer = []),
              n.bindFramebuffer(
                t.FRAMEBUFFER,
                o.__webglMultisampledFramebuffer
              );
            for (let n = 0; n < c.length; n++) {
              const i = c[n];
              (o.__webglColorRenderbuffer[n] = t.createRenderbuffer()),
                t.bindRenderbuffer(
                  t.RENDERBUFFER,
                  o.__webglColorRenderbuffer[n]
                );
              const r = s.convert(i.format, i.colorSpace),
                a = s.convert(i.type),
                l = _(
                  i.internalFormat,
                  r,
                  a,
                  i.colorSpace,
                  !0 === e.isXRRenderTarget
                ),
                u = F(e);
              t.renderbufferStorageMultisample(
                t.RENDERBUFFER,
                u,
                l,
                e.width,
                e.height
              ),
                t.framebufferRenderbuffer(
                  t.FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0 + n,
                  t.RENDERBUFFER,
                  o.__webglColorRenderbuffer[n]
                );
            }
            t.bindRenderbuffer(t.RENDERBUFFER, null),
              e.depthBuffer &&
                ((o.__webglDepthRenderbuffer = t.createRenderbuffer()),
                L(o.__webglDepthRenderbuffer, e, !0)),
              n.bindFramebuffer(t.FRAMEBUFFER, null);
          }
        }
        if (u) {
          n.bindTexture(t.TEXTURE_CUBE_MAP, l.__webglTexture),
            C(t.TEXTURE_CUBE_MAP, r);
          for (let n = 0; n < 6; n++)
            if (r.mipmaps && r.mipmaps.length > 0)
              for (let i = 0; i < r.mipmaps.length; i++)
                P(
                  o.__webglFramebuffer[n][i],
                  e,
                  r,
                  t.COLOR_ATTACHMENT0,
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                  i
                );
            else
              P(
                o.__webglFramebuffer[n],
                e,
                r,
                t.COLOR_ATTACHMENT0,
                t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                0
              );
          g(r) && v(t.TEXTURE_CUBE_MAP), n.unbindTexture();
        } else if (h) {
          for (let r = 0, s = c.length; r < s; r++) {
            const s = c[r],
              a = i.get(s);
            n.bindTexture(t.TEXTURE_2D, a.__webglTexture),
              C(t.TEXTURE_2D, s),
              P(
                o.__webglFramebuffer,
                e,
                s,
                t.COLOR_ATTACHMENT0 + r,
                t.TEXTURE_2D,
                0
              ),
              g(s) && v(t.TEXTURE_2D);
          }
          n.unbindTexture();
        } else {
          let i = t.TEXTURE_2D;
          if (
            ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) &&
              (i = e.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY),
            n.bindTexture(i, l.__webglTexture),
            C(i, r),
            r.mipmaps && r.mipmaps.length > 0)
          )
            for (let n = 0; n < r.mipmaps.length; n++)
              P(o.__webglFramebuffer[n], e, r, t.COLOR_ATTACHMENT0, i, n);
          else P(o.__webglFramebuffer, e, r, t.COLOR_ATTACHMENT0, i, 0);
          g(r) && v(i), n.unbindTexture();
        }
        e.depthBuffer && I(e);
      }),
      (this.updateRenderTargetMipmap = function (e) {
        const r = e.textures;
        for (let s = 0, a = r.length; s < a; s++) {
          const a = r[s];
          if (g(a)) {
            const r = e.isWebGLCubeRenderTarget
                ? t.TEXTURE_CUBE_MAP
                : t.TEXTURE_2D,
              s = i.get(a).__webglTexture;
            n.bindTexture(r, s), v(r), n.unbindTexture();
          }
        }
      }),
      (this.updateMultisampleRenderTarget = function (e) {
        if (e.samples > 0)
          if (!1 === O(e)) {
            const r = e.textures,
              s = e.width,
              a = e.height;
            let o = t.COLOR_BUFFER_BIT;
            const c = e.stencilBuffer
                ? t.DEPTH_STENCIL_ATTACHMENT
                : t.DEPTH_ATTACHMENT,
              u = i.get(e),
              h = r.length > 1;
            if (h)
              for (let e = 0; e < r.length; e++)
                n.bindFramebuffer(
                  t.FRAMEBUFFER,
                  u.__webglMultisampledFramebuffer
                ),
                  t.framebufferRenderbuffer(
                    t.FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0 + e,
                    t.RENDERBUFFER,
                    null
                  ),
                  n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                  t.framebufferTexture2D(
                    t.DRAW_FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0 + e,
                    t.TEXTURE_2D,
                    null,
                    0
                  );
            n.bindFramebuffer(
              t.READ_FRAMEBUFFER,
              u.__webglMultisampledFramebuffer
            ),
              n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
            for (let n = 0; n < r.length; n++) {
              if (
                (e.resolveDepthBuffer &&
                  (e.depthBuffer && (o |= t.DEPTH_BUFFER_BIT),
                  e.stencilBuffer &&
                    e.resolveStencilBuffer &&
                    (o |= t.STENCIL_BUFFER_BIT)),
                h)
              ) {
                t.framebufferRenderbuffer(
                  t.READ_FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0,
                  t.RENDERBUFFER,
                  u.__webglColorRenderbuffer[n]
                );
                const e = i.get(r[n]).__webglTexture;
                t.framebufferTexture2D(
                  t.DRAW_FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0,
                  t.TEXTURE_2D,
                  e,
                  0
                );
              }
              t.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, t.NEAREST),
                !0 === l &&
                  ((U.length = 0),
                  (N.length = 0),
                  U.push(t.COLOR_ATTACHMENT0 + n),
                  e.depthBuffer &&
                    !1 === e.resolveDepthBuffer &&
                    (U.push(c),
                    N.push(c),
                    t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, N)),
                  t.invalidateFramebuffer(t.READ_FRAMEBUFFER, U));
            }
            if (
              (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
              n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
              h)
            )
              for (let e = 0; e < r.length; e++) {
                n.bindFramebuffer(
                  t.FRAMEBUFFER,
                  u.__webglMultisampledFramebuffer
                ),
                  t.framebufferRenderbuffer(
                    t.FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0 + e,
                    t.RENDERBUFFER,
                    u.__webglColorRenderbuffer[e]
                  );
                const s = i.get(r[e]).__webglTexture;
                n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                  t.framebufferTexture2D(
                    t.DRAW_FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0 + e,
                    t.TEXTURE_2D,
                    s,
                    0
                  );
              }
            n.bindFramebuffer(
              t.DRAW_FRAMEBUFFER,
              u.__webglMultisampledFramebuffer
            );
          } else if (e.depthBuffer && !1 === e.resolveDepthBuffer && l) {
            const n = e.stencilBuffer
              ? t.DEPTH_STENCIL_ATTACHMENT
              : t.DEPTH_ATTACHMENT;
            t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [n]);
          }
      }),
      (this.setupDepthRenderbuffer = I),
      (this.setupFrameBufferTexture = P),
      (this.useMultisampledRTT = O);
  }
  function ag(t, e) {
    return {
      convert: function (n, i = "") {
        let r;
        const s = Wu.getTransfer(i);
        if (n === Vc) return t.UNSIGNED_BYTE;
        if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
        if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
        if (35902 === n) return t.UNSIGNED_INT_5_9_9_9_REV;
        if (1010 === n) return t.BYTE;
        if (1011 === n) return t.SHORT;
        if (1012 === n) return t.UNSIGNED_SHORT;
        if (1013 === n) return t.INT;
        if (n === Hc) return t.UNSIGNED_INT;
        if (n === Gc) return t.FLOAT;
        if (n === Wc) return t.HALF_FLOAT;
        if (1021 === n) return t.ALPHA;
        if (1022 === n) return t.RGB;
        if (n === qc) return t.RGBA;
        if (1024 === n) return t.LUMINANCE;
        if (1025 === n) return t.LUMINANCE_ALPHA;
        if (n === jc) return t.DEPTH_COMPONENT;
        if (n === Yc) return t.DEPTH_STENCIL;
        if (1028 === n) return t.RED;
        if (1029 === n) return t.RED_INTEGER;
        if (1030 === n) return t.RG;
        if (1031 === n) return t.RG_INTEGER;
        if (1033 === n) return t.RGBA_INTEGER;
        if (n === Kc || n === Zc || n === Jc || n === $c)
          if (s === cu) {
            if (((r = e.get("WEBGL_compressed_texture_s3tc_srgb")), null === r))
              return null;
            if (n === Kc) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (n === Zc) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (n === Jc) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (n === $c) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            if (((r = e.get("WEBGL_compressed_texture_s3tc")), null === r))
              return null;
            if (n === Kc) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (n === Zc) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (n === Jc) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (n === $c) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
        if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
          if (((r = e.get("WEBGL_compressed_texture_pvrtc")), null === r))
            return null;
          if (35840 === n) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (35841 === n) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (35842 === n) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (35843 === n) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (36196 === n || 37492 === n || 37496 === n) {
          if (((r = e.get("WEBGL_compressed_texture_etc")), null === r))
            return null;
          if (36196 === n || 37492 === n)
            return s === cu ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
          if (37496 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
              : r.COMPRESSED_RGBA8_ETC2_EAC;
        }
        if (
          37808 === n ||
          37809 === n ||
          37810 === n ||
          37811 === n ||
          37812 === n ||
          37813 === n ||
          37814 === n ||
          37815 === n ||
          37816 === n ||
          37817 === n ||
          37818 === n ||
          37819 === n ||
          37820 === n ||
          37821 === n
        ) {
          if (((r = e.get("WEBGL_compressed_texture_astc")), null === r))
            return null;
          if (37808 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
              : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (37809 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
              : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (37810 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
              : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (37811 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
              : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (37812 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
              : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (37813 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
              : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (37814 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
              : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (37815 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
              : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (37816 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
              : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (37817 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
              : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (37818 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
              : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (37819 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
              : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (37820 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
              : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (37821 === n)
            return s === cu
              ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
              : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
        }
        if (n === Qc || 36494 === n || 36495 === n) {
          if (((r = e.get("EXT_texture_compression_bptc")), null === r))
            return null;
          if (n === Qc)
            return s === cu
              ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
              : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          if (36494 === n) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
          if (36495 === n) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
        }
        if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
          if (((r = e.get("EXT_texture_compression_rgtc")), null === r))
            return null;
          if (n === Qc) return r.COMPRESSED_RED_RGTC1_EXT;
          if (36284 === n) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
          if (36285 === n) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
          if (36286 === n) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
        }
        return n === Xc ? t.UNSIGNED_INT_24_8 : void 0 !== t[n] ? t[n] : null;
      },
    };
  }
  class og extends xp {
    constructor(t = []) {
      super(), (this.isArrayCamera = !0), (this.cameras = t);
    }
  }
  class lg extends cd {
    constructor() {
      super(), (this.isGroup = !0), (this.type = "Group");
    }
  }
  const cg = { type: "move" };
  class ug {
    constructor() {
      (this._targetRay = null), (this._grip = null), (this._hand = null);
    }
    getHandSpace() {
      return (
        null === this._hand &&
          ((this._hand = new lg()),
          (this._hand.matrixAutoUpdate = !1),
          (this._hand.visible = !1),
          (this._hand.joints = {}),
          (this._hand.inputState = { pinching: !1 })),
        this._hand
      );
    }
    getTargetRaySpace() {
      return (
        null === this._targetRay &&
          ((this._targetRay = new lg()),
          (this._targetRay.matrixAutoUpdate = !1),
          (this._targetRay.visible = !1),
          (this._targetRay.hasLinearVelocity = !1),
          (this._targetRay.linearVelocity = new ah()),
          (this._targetRay.hasAngularVelocity = !1),
          (this._targetRay.angularVelocity = new ah())),
        this._targetRay
      );
    }
    getGripSpace() {
      return (
        null === this._grip &&
          ((this._grip = new lg()),
          (this._grip.matrixAutoUpdate = !1),
          (this._grip.visible = !1),
          (this._grip.hasLinearVelocity = !1),
          (this._grip.linearVelocity = new ah()),
          (this._grip.hasAngularVelocity = !1),
          (this._grip.angularVelocity = new ah())),
        this._grip
      );
    }
    dispatchEvent(t) {
      return (
        null !== this._targetRay && this._targetRay.dispatchEvent(t),
        null !== this._grip && this._grip.dispatchEvent(t),
        null !== this._hand && this._hand.dispatchEvent(t),
        this
      );
    }
    connect(t) {
      if (t && t.hand) {
        const e = this._hand;
        if (e) for (const n of t.hand.values()) this._getHandJoint(e, n);
      }
      return this.dispatchEvent({ type: "connected", data: t }), this;
    }
    disconnect(t) {
      return (
        this.dispatchEvent({ type: "disconnected", data: t }),
        null !== this._targetRay && (this._targetRay.visible = !1),
        null !== this._grip && (this._grip.visible = !1),
        null !== this._hand && (this._hand.visible = !1),
        this
      );
    }
    update(t, e, n) {
      let i = null,
        r = null,
        s = null;
      const a = this._targetRay,
        o = this._grip,
        l = this._hand;
      if (t && "visible-blurred" !== e.session.visibilityState) {
        if (l && t.hand) {
          s = !0;
          for (const i of t.hand.values()) {
            const t = e.getJointPose(i, n),
              r = this._getHandJoint(l, i);
            null !== t &&
              (r.matrix.fromArray(t.transform.matrix),
              r.matrix.decompose(r.position, r.rotation, r.scale),
              (r.matrixWorldNeedsUpdate = !0),
              (r.jointRadius = t.radius)),
              (r.visible = null !== t);
          }
          const i = l.joints["index-finger-tip"],
            r = l.joints["thumb-tip"],
            a = i.position.distanceTo(r.position),
            o = 0.02,
            c = 0.005;
          l.inputState.pinching && a > o + c
            ? ((l.inputState.pinching = !1),
              this.dispatchEvent({
                type: "pinchend",
                handedness: t.handedness,
                target: this,
              }))
            : !l.inputState.pinching &&
              a <= o - c &&
              ((l.inputState.pinching = !0),
              this.dispatchEvent({
                type: "pinchstart",
                handedness: t.handedness,
                target: this,
              }));
        } else
          null !== o &&
            t.gripSpace &&
            ((r = e.getPose(t.gripSpace, n)),
            null !== r &&
              (o.matrix.fromArray(r.transform.matrix),
              o.matrix.decompose(o.position, o.rotation, o.scale),
              (o.matrixWorldNeedsUpdate = !0),
              r.linearVelocity
                ? ((o.hasLinearVelocity = !0),
                  o.linearVelocity.copy(r.linearVelocity))
                : (o.hasLinearVelocity = !1),
              r.angularVelocity
                ? ((o.hasAngularVelocity = !0),
                  o.angularVelocity.copy(r.angularVelocity))
                : (o.hasAngularVelocity = !1)));
        null !== a &&
          ((i = e.getPose(t.targetRaySpace, n)),
          null === i && null !== r && (i = r),
          null !== i &&
            (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            (a.matrixWorldNeedsUpdate = !0),
            i.linearVelocity
              ? ((a.hasLinearVelocity = !0),
                a.linearVelocity.copy(i.linearVelocity))
              : (a.hasLinearVelocity = !1),
            i.angularVelocity
              ? ((a.hasAngularVelocity = !0),
                a.angularVelocity.copy(i.angularVelocity))
              : (a.hasAngularVelocity = !1),
            this.dispatchEvent(cg)));
      }
      return (
        null !== a && (a.visible = null !== i),
        null !== o && (o.visible = null !== r),
        null !== l && (l.visible = null !== s),
        this
      );
    }
    _getHandJoint(t, e) {
      if (void 0 === t.joints[e.jointName]) {
        const n = new lg();
        (n.matrixAutoUpdate = !1),
          (n.visible = !1),
          (t.joints[e.jointName] = n),
          t.add(n);
      }
      return t.joints[e.jointName];
    }
  }
  class hg {
    constructor() {
      (this.texture = null),
        (this.mesh = null),
        (this.depthNear = 0),
        (this.depthFar = 0);
    }
    init(t, e, n) {
      if (null === this.texture) {
        const i = new Qu();
        (t.properties.get(i).__webglTexture = e.texture),
          (e.depthNear == n.depthNear && e.depthFar == n.depthFar) ||
            ((this.depthNear = e.depthNear), (this.depthFar = e.depthFar)),
          (this.texture = i);
      }
    }
    render(t, e) {
      if (null !== this.texture) {
        if (null === this.mesh) {
          const t = e.cameras[0].viewport,
            n = new fp({
              vertexShader:
                "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
              fragmentShader:
                "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
              uniforms: {
                depthColor: { value: this.texture },
                depthWidth: { value: t.z },
                depthHeight: { value: t.w },
              },
            });
          this.mesh = new op(new Ip(20, 20), n);
        }
        t.render(this.mesh, e);
      }
    }
    reset() {
      (this.texture = null), (this.mesh = null);
    }
  }
  class dg extends Tu {
    constructor(t, e) {
      super();
      const n = this;
      let i = null,
        r = 1,
        s = null,
        a = "local-floor",
        o = 1,
        l = null,
        c = null,
        u = null,
        h = null,
        d = null,
        p = null;
      const f = new hg(),
        m = e.getContextAttributes();
      let g = null,
        v = null;
      const _ = [],
        x = [],
        y = new Iu();
      let S = null;
      const M = new xp();
      M.layers.enable(1), (M.viewport = new th());
      const E = new xp();
      E.layers.enable(2), (E.viewport = new th());
      const T = [M, E],
        b = new og();
      b.layers.enable(1), b.layers.enable(2);
      let D = null,
        w = null;
      function C(t) {
        const e = x.indexOf(t.inputSource);
        if (-1 === e) return;
        const n = _[e];
        void 0 !== n &&
          (n.update(t.inputSource, t.frame, l || s),
          n.dispatchEvent({ type: t.type, data: t.inputSource }));
      }
      function A() {
        i.removeEventListener("select", C),
          i.removeEventListener("selectstart", C),
          i.removeEventListener("selectend", C),
          i.removeEventListener("squeeze", C),
          i.removeEventListener("squeezestart", C),
          i.removeEventListener("squeezeend", C),
          i.removeEventListener("end", A),
          i.removeEventListener("inputsourceschange", R);
        for (let t = 0; t < _.length; t++) {
          const e = x[t];
          null !== e && ((x[t] = null), _[t].disconnect(e));
        }
        (D = null),
          (w = null),
          f.reset(),
          t.setRenderTarget(g),
          (d = null),
          (h = null),
          (u = null),
          (i = null),
          (v = null),
          N.stop(),
          (n.isPresenting = !1),
          t.setPixelRatio(S),
          t.setSize(y.width, y.height, !1),
          n.dispatchEvent({ type: "sessionend" });
      }
      function R(t) {
        for (let e = 0; e < t.removed.length; e++) {
          const n = t.removed[e],
            i = x.indexOf(n);
          i >= 0 && ((x[i] = null), _[i].disconnect(n));
        }
        for (let e = 0; e < t.added.length; e++) {
          const n = t.added[e];
          let i = x.indexOf(n);
          if (-1 === i) {
            for (let t = 0; t < _.length; t++) {
              if (t >= x.length) {
                x.push(n), (i = t);
                break;
              }
              if (null === x[t]) {
                (x[t] = n), (i = t);
                break;
              }
            }
            if (-1 === i) break;
          }
          const r = _[i];
          r && r.connect(n);
        }
      }
      (this.cameraAutoUpdate = !0),
        (this.enabled = !1),
        (this.isPresenting = !1),
        (this.getController = function (t) {
          let e = _[t];
          return (
            void 0 === e && ((e = new ug()), (_[t] = e)), e.getTargetRaySpace()
          );
        }),
        (this.getControllerGrip = function (t) {
          let e = _[t];
          return void 0 === e && ((e = new ug()), (_[t] = e)), e.getGripSpace();
        }),
        (this.getHand = function (t) {
          let e = _[t];
          return void 0 === e && ((e = new ug()), (_[t] = e)), e.getHandSpace();
        }),
        (this.setFramebufferScaleFactor = function (t) {
          (r = t),
            !0 === n.isPresenting &&
              console.warn(
                "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
              );
        }),
        (this.setReferenceSpaceType = function (t) {
          (a = t),
            !0 === n.isPresenting &&
              console.warn(
                "THREE.WebXRManager: Cannot change reference space type while presenting."
              );
        }),
        (this.getReferenceSpace = function () {
          return l || s;
        }),
        (this.setReferenceSpace = function (t) {
          l = t;
        }),
        (this.getBaseLayer = function () {
          return null !== h ? h : d;
        }),
        (this.getBinding = function () {
          return u;
        }),
        (this.getFrame = function () {
          return p;
        }),
        (this.getSession = function () {
          return i;
        }),
        (this.setSession = async function (c) {
          if (((i = c), null !== i)) {
            if (
              ((g = t.getRenderTarget()),
              i.addEventListener("select", C),
              i.addEventListener("selectstart", C),
              i.addEventListener("selectend", C),
              i.addEventListener("squeeze", C),
              i.addEventListener("squeezestart", C),
              i.addEventListener("squeezeend", C),
              i.addEventListener("end", A),
              i.addEventListener("inputsourceschange", R),
              !0 !== m.xrCompatible && (await e.makeXRCompatible()),
              (S = t.getPixelRatio()),
              t.getSize(y),
              void 0 === i.renderState.layers)
            ) {
              const n = {
                antialias: m.antialias,
                alpha: !0,
                depth: m.depth,
                stencil: m.stencil,
                framebufferScaleFactor: r,
              };
              (d = new XRWebGLLayer(i, e, n)),
                i.updateRenderState({ baseLayer: d }),
                t.setPixelRatio(1),
                t.setSize(d.framebufferWidth, d.framebufferHeight, !1),
                (v = new nh(d.framebufferWidth, d.framebufferHeight, {
                  format: qc,
                  type: Vc,
                  colorSpace: t.outputColorSpace,
                  stencilBuffer: m.stencil,
                }));
            } else {
              let n = null,
                s = null,
                a = null;
              m.depth &&
                ((a = m.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24),
                (n = m.stencil ? Yc : jc),
                (s = m.stencil ? Xc : Hc));
              const o = {
                colorFormat: e.RGBA8,
                depthFormat: a,
                scaleFactor: r,
              };
              (u = new XRWebGLBinding(i, e)),
                (h = u.createProjectionLayer(o)),
                i.updateRenderState({ layers: [h] }),
                t.setPixelRatio(1),
                t.setSize(h.textureWidth, h.textureHeight, !1),
                (v = new nh(h.textureWidth, h.textureHeight, {
                  format: qc,
                  type: Vc,
                  depthTexture: new gf(
                    h.textureWidth,
                    h.textureHeight,
                    s,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    n
                  ),
                  stencilBuffer: m.stencil,
                  colorSpace: t.outputColorSpace,
                  samples: m.antialias ? 4 : 0,
                  resolveDepthBuffer: !1 === h.ignoreDepthValues,
                }));
            }
            (v.isXRRenderTarget = !0),
              this.setFoveation(o),
              (l = null),
              (s = await i.requestReferenceSpace(a)),
              N.setContext(i),
              N.start(),
              (n.isPresenting = !0),
              n.dispatchEvent({ type: "sessionstart" });
          }
        }),
        (this.getEnvironmentBlendMode = function () {
          if (null !== i) return i.environmentBlendMode;
        });
      const P = new ah(),
        L = new ah();
      function I(t, e) {
        null === e
          ? t.matrixWorld.copy(t.matrix)
          : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
          t.matrixWorldInverse.copy(t.matrixWorld).invert();
      }
      (this.updateCamera = function (t) {
        if (null === i) return;
        null !== f.texture && ((t.near = f.depthNear), (t.far = f.depthFar)),
          (b.near = E.near = M.near = t.near),
          (b.far = E.far = M.far = t.far),
          (D === b.near && w === b.far) ||
            (i.updateRenderState({ depthNear: b.near, depthFar: b.far }),
            (D = b.near),
            (w = b.far),
            (M.near = D),
            (M.far = w),
            (E.near = D),
            (E.far = w),
            M.updateProjectionMatrix(),
            E.updateProjectionMatrix(),
            t.updateProjectionMatrix());
        const e = t.parent,
          n = b.cameras;
        I(b, e);
        for (let t = 0; t < n.length; t++) I(n[t], e);
        2 === n.length
          ? (function (t, e, n) {
              P.setFromMatrixPosition(e.matrixWorld),
                L.setFromMatrixPosition(n.matrixWorld);
              const i = P.distanceTo(L),
                r = e.projectionMatrix.elements,
                s = n.projectionMatrix.elements,
                a = r[14] / (r[10] - 1),
                o = r[14] / (r[10] + 1),
                l = (r[9] + 1) / r[5],
                c = (r[9] - 1) / r[5],
                u = (r[8] - 1) / r[0],
                h = (s[8] + 1) / s[0],
                d = a * u,
                p = a * h,
                f = i / (-u + h),
                m = f * -u;
              e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                t.translateX(m),
                t.translateZ(f),
                t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                t.matrixWorldInverse.copy(t.matrixWorld).invert();
              const g = a + f,
                v = o + f,
                _ = d - m,
                x = p + (i - m),
                y = ((l * o) / v) * g,
                S = ((c * o) / v) * g;
              t.projectionMatrix.makePerspective(_, x, y, S, g, v),
                t.projectionMatrixInverse.copy(t.projectionMatrix).invert();
            })(b, M, E)
          : b.projectionMatrix.copy(M.projectionMatrix),
          (function (t, e, n) {
            null === n
              ? t.matrix.copy(e.matrixWorld)
              : (t.matrix.copy(n.matrixWorld),
                t.matrix.invert(),
                t.matrix.multiply(e.matrixWorld)),
              t.matrix.decompose(t.position, t.quaternion, t.scale),
              t.updateMatrixWorld(!0),
              t.projectionMatrix.copy(e.projectionMatrix),
              t.projectionMatrixInverse.copy(e.projectionMatrixInverse),
              t.isPerspectiveCamera &&
                ((t.fov =
                  2 * wu * Math.atan(1 / t.projectionMatrix.elements[5])),
                (t.zoom = 1));
          })(t, b, e);
      }),
        (this.getCamera = function () {
          return b;
        }),
        (this.getFoveation = function () {
          if (null !== h || null !== d) return o;
        }),
        (this.setFoveation = function (t) {
          (o = t),
            null !== h && (h.fixedFoveation = t),
            null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t);
        }),
        (this.hasDepthSensing = function () {
          return null !== f.texture;
        });
      let U = null;
      const N = new Pp();
      N.setAnimationLoop(function (e, r) {
        if (((c = r.getViewerPose(l || s)), (p = r), null !== c)) {
          const e = c.views;
          null !== d &&
            (t.setRenderTargetFramebuffer(v, d.framebuffer),
            t.setRenderTarget(v));
          let n = !1;
          e.length !== b.cameras.length && ((b.cameras.length = 0), (n = !0));
          for (let i = 0; i < e.length; i++) {
            const r = e[i];
            let s = null;
            if (null !== d) s = d.getViewport(r);
            else {
              const e = u.getViewSubImage(h, r);
              (s = e.viewport),
                0 === i &&
                  (t.setRenderTargetTextures(
                    v,
                    e.colorTexture,
                    h.ignoreDepthValues ? void 0 : e.depthStencilTexture
                  ),
                  t.setRenderTarget(v));
            }
            let a = T[i];
            void 0 === a &&
              ((a = new xp()),
              a.layers.enable(i),
              (a.viewport = new th()),
              (T[i] = a)),
              a.matrix.fromArray(r.transform.matrix),
              a.matrix.decompose(a.position, a.quaternion, a.scale),
              a.projectionMatrix.fromArray(r.projectionMatrix),
              a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
              a.viewport.set(s.x, s.y, s.width, s.height),
              0 === i &&
                (b.matrix.copy(a.matrix),
                b.matrix.decompose(b.position, b.quaternion, b.scale)),
              !0 === n && b.cameras.push(a);
          }
          const r = i.enabledFeatures;
          if (r && r.includes("depth-sensing")) {
            const n = u.getDepthInformation(e[0]);
            n && n.isValid && n.texture && f.init(t, n, i.renderState);
          }
        }
        for (let t = 0; t < _.length; t++) {
          const e = x[t],
            n = _[t];
          null !== e && void 0 !== n && n.update(e, r, l || s);
        }
        f.render(t, b),
          U && U(e, r),
          r.detectedPlanes &&
            n.dispatchEvent({ type: "planesdetected", data: r }),
          (p = null);
      }),
        (this.setAnimationLoop = function (t) {
          U = t;
        }),
        (this.dispose = function () {});
    }
  }
  const pg = new qh(),
    fg = new Fh();
  function mg(t, e) {
    function n(t, e) {
      !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix);
    }
    function i(i, r) {
      (i.opacity.value = r.opacity),
        r.color && i.diffuse.value.copy(r.color),
        r.emissive &&
          i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),
        r.map && ((i.map.value = r.map), n(r.map, i.mapTransform)),
        r.alphaMap &&
          ((i.alphaMap.value = r.alphaMap), n(r.alphaMap, i.alphaMapTransform)),
        r.bumpMap &&
          ((i.bumpMap.value = r.bumpMap),
          n(r.bumpMap, i.bumpMapTransform),
          (i.bumpScale.value = r.bumpScale),
          1 === r.side && (i.bumpScale.value *= -1)),
        r.normalMap &&
          ((i.normalMap.value = r.normalMap),
          n(r.normalMap, i.normalMapTransform),
          i.normalScale.value.copy(r.normalScale),
          1 === r.side && i.normalScale.value.negate()),
        r.displacementMap &&
          ((i.displacementMap.value = r.displacementMap),
          n(r.displacementMap, i.displacementMapTransform),
          (i.displacementScale.value = r.displacementScale),
          (i.displacementBias.value = r.displacementBias)),
        r.emissiveMap &&
          ((i.emissiveMap.value = r.emissiveMap),
          n(r.emissiveMap, i.emissiveMapTransform)),
        r.specularMap &&
          ((i.specularMap.value = r.specularMap),
          n(r.specularMap, i.specularMapTransform)),
        r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
      const s = e.get(r),
        a = s.envMap,
        o = s.envMapRotation;
      if (
        (a &&
          ((i.envMap.value = a),
          pg.copy(o),
          (pg.x *= -1),
          (pg.y *= -1),
          (pg.z *= -1),
          a.isCubeTexture &&
            !1 === a.isRenderTargetTexture &&
            ((pg.y *= -1), (pg.z *= -1)),
          i.envMapRotation.value.setFromMatrix4(fg.makeRotationFromEuler(pg)),
          (i.flipEnvMap.value =
            a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1),
          (i.reflectivity.value = r.reflectivity),
          (i.ior.value = r.ior),
          (i.refractionRatio.value = r.refractionRatio)),
        r.lightMap)
      ) {
        i.lightMap.value = r.lightMap;
        const e = !0 === t._useLegacyLights ? Math.PI : 1;
        (i.lightMapIntensity.value = r.lightMapIntensity * e),
          n(r.lightMap, i.lightMapTransform);
      }
      r.aoMap &&
        ((i.aoMap.value = r.aoMap),
        (i.aoMapIntensity.value = r.aoMapIntensity),
        n(r.aoMap, i.aoMapTransform));
    }
    return {
      refreshFogUniforms: function (e, n) {
        n.color.getRGB(e.fogColor.value, dp(t)),
          n.isFog
            ? ((e.fogNear.value = n.near), (e.fogFar.value = n.far))
            : n.isFogExp2 && (e.fogDensity.value = n.density);
      },
      refreshMaterialUniforms: function (t, r, s, a, o) {
        r.isMeshBasicMaterial || r.isMeshLambertMaterial
          ? i(t, r)
          : r.isMeshToonMaterial
          ? (i(t, r),
            (function (t, e) {
              e.gradientMap && (t.gradientMap.value = e.gradientMap);
            })(t, r))
          : r.isMeshPhongMaterial
          ? (i(t, r),
            (function (t, e) {
              t.specular.value.copy(e.specular),
                (t.shininess.value = Math.max(e.shininess, 1e-4));
            })(t, r))
          : r.isMeshStandardMaterial
          ? (i(t, r),
            (function (t, e) {
              (t.metalness.value = e.metalness),
                e.metalnessMap &&
                  ((t.metalnessMap.value = e.metalnessMap),
                  n(e.metalnessMap, t.metalnessMapTransform)),
                (t.roughness.value = e.roughness),
                e.roughnessMap &&
                  ((t.roughnessMap.value = e.roughnessMap),
                  n(e.roughnessMap, t.roughnessMapTransform)),
                e.envMap && (t.envMapIntensity.value = e.envMapIntensity);
            })(t, r),
            r.isMeshPhysicalMaterial &&
              (function (t, e, i) {
                (t.ior.value = e.ior),
                  e.sheen > 0 &&
                    (t.sheenColor.value
                      .copy(e.sheenColor)
                      .multiplyScalar(e.sheen),
                    (t.sheenRoughness.value = e.sheenRoughness),
                    e.sheenColorMap &&
                      ((t.sheenColorMap.value = e.sheenColorMap),
                      n(e.sheenColorMap, t.sheenColorMapTransform)),
                    e.sheenRoughnessMap &&
                      ((t.sheenRoughnessMap.value = e.sheenRoughnessMap),
                      n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform))),
                  e.clearcoat > 0 &&
                    ((t.clearcoat.value = e.clearcoat),
                    (t.clearcoatRoughness.value = e.clearcoatRoughness),
                    e.clearcoatMap &&
                      ((t.clearcoatMap.value = e.clearcoatMap),
                      n(e.clearcoatMap, t.clearcoatMapTransform)),
                    e.clearcoatRoughnessMap &&
                      ((t.clearcoatRoughnessMap.value =
                        e.clearcoatRoughnessMap),
                      n(
                        e.clearcoatRoughnessMap,
                        t.clearcoatRoughnessMapTransform
                      )),
                    e.clearcoatNormalMap &&
                      ((t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                      n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform),
                      t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                      1 === e.side && t.clearcoatNormalScale.value.negate())),
                  e.dispersion > 0 && (t.dispersion.value = e.dispersion),
                  e.iridescence > 0 &&
                    ((t.iridescence.value = e.iridescence),
                    (t.iridescenceIOR.value = e.iridescenceIOR),
                    (t.iridescenceThicknessMinimum.value =
                      e.iridescenceThicknessRange[0]),
                    (t.iridescenceThicknessMaximum.value =
                      e.iridescenceThicknessRange[1]),
                    e.iridescenceMap &&
                      ((t.iridescenceMap.value = e.iridescenceMap),
                      n(e.iridescenceMap, t.iridescenceMapTransform)),
                    e.iridescenceThicknessMap &&
                      ((t.iridescenceThicknessMap.value =
                        e.iridescenceThicknessMap),
                      n(
                        e.iridescenceThicknessMap,
                        t.iridescenceThicknessMapTransform
                      ))),
                  e.transmission > 0 &&
                    ((t.transmission.value = e.transmission),
                    (t.transmissionSamplerMap.value = i.texture),
                    t.transmissionSamplerSize.value.set(i.width, i.height),
                    e.transmissionMap &&
                      ((t.transmissionMap.value = e.transmissionMap),
                      n(e.transmissionMap, t.transmissionMapTransform)),
                    (t.thickness.value = e.thickness),
                    e.thicknessMap &&
                      ((t.thicknessMap.value = e.thicknessMap),
                      n(e.thicknessMap, t.thicknessMapTransform)),
                    (t.attenuationDistance.value = e.attenuationDistance),
                    t.attenuationColor.value.copy(e.attenuationColor)),
                  e.anisotropy > 0 &&
                    (t.anisotropyVector.value.set(
                      e.anisotropy * Math.cos(e.anisotropyRotation),
                      e.anisotropy * Math.sin(e.anisotropyRotation)
                    ),
                    e.anisotropyMap &&
                      ((t.anisotropyMap.value = e.anisotropyMap),
                      n(e.anisotropyMap, t.anisotropyMapTransform))),
                  (t.specularIntensity.value = e.specularIntensity),
                  t.specularColor.value.copy(e.specularColor),
                  e.specularColorMap &&
                    ((t.specularColorMap.value = e.specularColorMap),
                    n(e.specularColorMap, t.specularColorMapTransform)),
                  e.specularIntensityMap &&
                    ((t.specularIntensityMap.value = e.specularIntensityMap),
                    n(e.specularIntensityMap, t.specularIntensityMapTransform));
              })(t, r, o))
          : r.isMeshMatcapMaterial
          ? (i(t, r),
            (function (t, e) {
              e.matcap && (t.matcap.value = e.matcap);
            })(t, r))
          : r.isMeshDepthMaterial
          ? i(t, r)
          : r.isMeshDistanceMaterial
          ? (i(t, r),
            (function (t, n) {
              const i = e.get(n).light;
              t.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
                (t.nearDistance.value = i.shadow.camera.near),
                (t.farDistance.value = i.shadow.camera.far);
            })(t, r))
          : r.isMeshNormalMaterial
          ? i(t, r)
          : r.isLineBasicMaterial
          ? ((function (t, e) {
              t.diffuse.value.copy(e.color),
                (t.opacity.value = e.opacity),
                e.map && ((t.map.value = e.map), n(e.map, t.mapTransform));
            })(t, r),
            r.isLineDashedMaterial &&
              (function (t, e) {
                (t.dashSize.value = e.dashSize),
                  (t.totalSize.value = e.dashSize + e.gapSize),
                  (t.scale.value = e.scale);
              })(t, r))
          : r.isPointsMaterial
          ? (function (t, e, i, r) {
              t.diffuse.value.copy(e.color),
                (t.opacity.value = e.opacity),
                (t.size.value = e.size * i),
                (t.scale.value = 0.5 * r),
                e.map && ((t.map.value = e.map), n(e.map, t.uvTransform)),
                e.alphaMap &&
                  ((t.alphaMap.value = e.alphaMap),
                  n(e.alphaMap, t.alphaMapTransform)),
                e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
            })(t, r, s, a)
          : r.isSpriteMaterial
          ? (function (t, e) {
              t.diffuse.value.copy(e.color),
                (t.opacity.value = e.opacity),
                (t.rotation.value = e.rotation),
                e.map && ((t.map.value = e.map), n(e.map, t.mapTransform)),
                e.alphaMap &&
                  ((t.alphaMap.value = e.alphaMap),
                  n(e.alphaMap, t.alphaMapTransform)),
                e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
            })(t, r)
          : r.isShadowMaterial
          ? (t.color.value.copy(r.color), (t.opacity.value = r.opacity))
          : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
      },
    };
  }
  function gg(t, e, n, i) {
    let r = {},
      s = {},
      a = [];
    const o = t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);
    function l(t, e, n, i) {
      const r = t.value,
        s = e + "_" + n;
      if (void 0 === i[s])
        return (
          (i[s] =
            "number" == typeof r || "boolean" == typeof r ? r : r.clone()),
          !0
        );
      {
        const t = i[s];
        if ("number" == typeof r || "boolean" == typeof r) {
          if (t !== r) return (i[s] = r), !0;
        } else if (!1 === t.equals(r)) return t.copy(r), !0;
      }
      return !1;
    }
    function c(t) {
      const e = { boundary: 0, storage: 0 };
      return (
        "number" == typeof t || "boolean" == typeof t
          ? ((e.boundary = 4), (e.storage = 4))
          : t.isVector2
          ? ((e.boundary = 8), (e.storage = 8))
          : t.isVector3 || t.isColor
          ? ((e.boundary = 16), (e.storage = 12))
          : t.isVector4
          ? ((e.boundary = 16), (e.storage = 16))
          : t.isMatrix3
          ? ((e.boundary = 48), (e.storage = 48))
          : t.isMatrix4
          ? ((e.boundary = 64), (e.storage = 64))
          : t.isTexture
          ? console.warn(
              "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
            )
          : console.warn(
              "THREE.WebGLRenderer: Unsupported uniform value type.",
              t
            ),
        e
      );
    }
    function u(e) {
      const n = e.target;
      n.removeEventListener("dispose", u);
      const i = a.indexOf(n.__bindingPointIndex);
      a.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id];
    }
    return {
      bind: function (t, e) {
        const n = e.program;
        i.uniformBlockBinding(t, n);
      },
      update: function (n, h) {
        let d = r[n.id];
        void 0 === d &&
          ((function (t) {
            const e = t.uniforms;
            let n = 0;
            for (let t = 0, i = e.length; t < i; t++) {
              const i = Array.isArray(e[t]) ? e[t] : [e[t]];
              for (let t = 0, e = i.length; t < e; t++) {
                const e = i[t],
                  r = Array.isArray(e.value) ? e.value : [e.value];
                for (let t = 0, i = r.length; t < i; t++) {
                  const i = c(r[t]),
                    s = n % 16;
                  0 !== s && 16 - s < i.boundary && (n += 16 - s),
                    (e.__data = new Float32Array(
                      i.storage / Float32Array.BYTES_PER_ELEMENT
                    )),
                    (e.__offset = n),
                    (n += i.storage);
                }
              }
            }
            const i = n % 16;
            i > 0 && (n += 16 - i), (t.__size = n), (t.__cache = {});
          })(n),
          (d = (function (e) {
            const n = (function () {
              for (let t = 0; t < o; t++)
                if (-1 === a.indexOf(t)) return a.push(t), t;
              return (
                console.error(
                  "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                ),
                0
              );
            })();
            e.__bindingPointIndex = n;
            const i = t.createBuffer(),
              r = e.__size,
              s = e.usage;
            return (
              t.bindBuffer(t.UNIFORM_BUFFER, i),
              t.bufferData(t.UNIFORM_BUFFER, r, s),
              t.bindBuffer(t.UNIFORM_BUFFER, null),
              t.bindBufferBase(t.UNIFORM_BUFFER, n, i),
              i
            );
          })(n)),
          (r[n.id] = d),
          n.addEventListener("dispose", u));
        const p = h.program;
        i.updateUBOMapping(n, p);
        const f = e.render.frame;
        s[n.id] !== f &&
          ((function (e) {
            const n = r[e.id],
              i = e.uniforms,
              s = e.__cache;
            t.bindBuffer(t.UNIFORM_BUFFER, n);
            for (let e = 0, n = i.length; e < n; e++) {
              const n = Array.isArray(i[e]) ? i[e] : [i[e]];
              for (let i = 0, r = n.length; i < r; i++) {
                const r = n[i];
                if (!0 === l(r, e, i, s)) {
                  const e = r.__offset,
                    n = Array.isArray(r.value) ? r.value : [r.value];
                  let i = 0;
                  for (let s = 0; s < n.length; s++) {
                    const a = n[s],
                      o = c(a);
                    "number" == typeof a || "boolean" == typeof a
                      ? ((r.__data[0] = a),
                        t.bufferSubData(t.UNIFORM_BUFFER, e + i, r.__data))
                      : a.isMatrix3
                      ? ((r.__data[0] = a.elements[0]),
                        (r.__data[1] = a.elements[1]),
                        (r.__data[2] = a.elements[2]),
                        (r.__data[3] = 0),
                        (r.__data[4] = a.elements[3]),
                        (r.__data[5] = a.elements[4]),
                        (r.__data[6] = a.elements[5]),
                        (r.__data[7] = 0),
                        (r.__data[8] = a.elements[6]),
                        (r.__data[9] = a.elements[7]),
                        (r.__data[10] = a.elements[8]),
                        (r.__data[11] = 0))
                      : (a.toArray(r.__data, i),
                        (i += o.storage / Float32Array.BYTES_PER_ELEMENT));
                  }
                  t.bufferSubData(t.UNIFORM_BUFFER, e, r.__data);
                }
              }
            }
            t.bindBuffer(t.UNIFORM_BUFFER, null);
          })(n),
          (s[n.id] = f));
      },
      dispose: function () {
        for (const e in r) t.deleteBuffer(r[e]);
        (a = []), (r = {}), (s = {});
      },
    };
  }
  class vg {
    constructor(t = {}) {
      const {
        canvas: e = Bu(),
        context: n = null,
        depth: i = !0,
        stencil: r = !1,
        alpha: s = !1,
        antialias: a = !1,
        premultipliedAlpha: o = !0,
        preserveDrawingBuffer: l = !1,
        powerPreference: c = "default",
        failIfMajorPerformanceCaveat: u = !1,
      } = t;
      let h;
      if (((this.isWebGLRenderer = !0), null !== n)) {
        if (
          "undefined" != typeof WebGLRenderingContext &&
          n instanceof WebGLRenderingContext
        )
          throw new Error(
            "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
          );
        h = n.getContextAttributes().alpha;
      } else h = s;
      const d = new Uint32Array(4),
        p = new Int32Array(4);
      let f = null,
        m = null;
      const g = [],
        v = [];
      (this.domElement = e),
        (this.debug = { checkShaderErrors: !0, onShaderError: null }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this._outputColorSpace = ru),
        (this._useLegacyLights = !1),
        (this.toneMapping = Sc),
        (this.toneMappingExposure = 1);
      const _ = this;
      let x = !1,
        y = 0,
        S = 0,
        M = null,
        E = -1,
        T = null;
      const b = new th(),
        D = new th();
      let w = null;
      const C = new bd(0);
      let A = 0,
        R = e.width,
        P = e.height,
        L = 1,
        I = null,
        U = null;
      const N = new th(0, 0, R, P),
        F = new th(0, 0, R, P);
      let O = !1;
      const B = new Rp();
      let z = !1,
        k = !1;
      const V = new Fh(),
        H = new ah(),
        G = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: !0,
        };
      function W() {
        return null === M ? L : 1;
      }
      let X,
        q,
        j,
        Y,
        K,
        Z,
        J,
        $,
        Q,
        tt,
        et,
        nt,
        it,
        rt,
        st,
        at,
        ot,
        lt,
        ct,
        ut,
        ht,
        dt,
        pt,
        ft,
        mt = n;
      function gt(t, n) {
        return e.getContext(t, n);
      }
      try {
        const t = {
          alpha: !0,
          depth: i,
          stencil: r,
          antialias: a,
          premultipliedAlpha: o,
          preserveDrawingBuffer: l,
          powerPreference: c,
          failIfMajorPerformanceCaveat: u,
        };
        if (
          ("setAttribute" in e &&
            e.setAttribute("data-engine", `three.js r${jl}`),
          e.addEventListener("webglcontextlost", xt, !1),
          e.addEventListener("webglcontextrestored", yt, !1),
          e.addEventListener("webglcontextcreationerror", St, !1),
          null === mt)
        ) {
          const e = "webgl2";
          if (((mt = gt(e, t)), null === mt))
            throw gt(e)
              ? new Error(
                  "Error creating WebGL context with your selected attributes."
                )
              : new Error("Error creating WebGL context.");
        }
      } catch (t) {
        throw (console.error("THREE.WebGLRenderer: " + t.message), t);
      }
      function vt() {
        (X = new uf(mt)),
          X.init(),
          (dt = new ag(mt, X)),
          (q = new Gp(mt, X, t, dt)),
          (j = new rg(mt)),
          (Y = new pf(mt)),
          (K = new Wm()),
          (Z = new sg(mt, X, j, K, q, dt, Y)),
          (J = new Xp(_)),
          ($ = new cf(_)),
          (Q = new Lp(mt)),
          (pt = new Vp(mt, Q)),
          (tt = new hf(mt, Q, Y, pt)),
          (et = new mf(mt, tt, Q, Y)),
          (ct = new ff(mt, q, Z)),
          (at = new Wp(K)),
          (nt = new Gm(_, J, $, X, q, pt, at)),
          (it = new mg(_, K)),
          (rt = new Ym()),
          (st = new tg(X)),
          (lt = new kp(_, J, $, j, et, h, o)),
          (ot = new ig(_, et, q)),
          (ft = new gg(mt, Y, q, j)),
          (ut = new Hp(mt, X, Y)),
          (ht = new df(mt, X, Y)),
          (Y.programs = nt.programs),
          (_.capabilities = q),
          (_.extensions = X),
          (_.properties = K),
          (_.renderLists = rt),
          (_.shadowMap = ot),
          (_.state = j),
          (_.info = Y);
      }
      vt();
      const _t = new dg(_, mt);
      function xt(t) {
        t.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (x = !0);
      }
      function yt() {
        console.log("THREE.WebGLRenderer: Context Restored."), (x = !1);
        const t = Y.autoReset,
          e = ot.enabled,
          n = ot.autoUpdate,
          i = ot.needsUpdate,
          r = ot.type;
        vt(),
          (Y.autoReset = t),
          (ot.enabled = e),
          (ot.autoUpdate = n),
          (ot.needsUpdate = i),
          (ot.type = r);
      }
      function St(t) {
        console.error(
          "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
          t.statusMessage
        );
      }
      function Mt(t) {
        const e = t.target;
        e.removeEventListener("dispose", Mt),
          (function (t) {
            (function (t) {
              const e = K.get(t).programs;
              void 0 !== e &&
                (e.forEach(function (t) {
                  nt.releaseProgram(t);
                }),
                t.isShaderMaterial && nt.releaseShaderCache(t));
            })(t),
              K.remove(t);
          })(e);
      }
      function Et(t, e, n) {
        !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass
          ? ((t.side = 1),
            (t.needsUpdate = !0),
            It(t, e, n),
            (t.side = 0),
            (t.needsUpdate = !0),
            It(t, e, n),
            (t.side = 2))
          : It(t, e, n);
      }
      (this.xr = _t),
        (this.getContext = function () {
          return mt;
        }),
        (this.getContextAttributes = function () {
          return mt.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          const t = X.get("WEBGL_lose_context");
          t && t.loseContext();
        }),
        (this.forceContextRestore = function () {
          const t = X.get("WEBGL_lose_context");
          t && t.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return L;
        }),
        (this.setPixelRatio = function (t) {
          void 0 !== t && ((L = t), this.setSize(R, P, !1));
        }),
        (this.getSize = function (t) {
          return t.set(R, P);
        }),
        (this.setSize = function (t, n, i = !0) {
          _t.isPresenting
            ? console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              )
            : ((R = t),
              (P = n),
              (e.width = Math.floor(t * L)),
              (e.height = Math.floor(n * L)),
              !0 === i &&
                ((e.style.width = t + "px"), (e.style.height = n + "px")),
              this.setViewport(0, 0, t, n));
        }),
        (this.getDrawingBufferSize = function (t) {
          return t.set(R * L, P * L).floor();
        }),
        (this.setDrawingBufferSize = function (t, n, i) {
          (R = t),
            (P = n),
            (L = i),
            (e.width = Math.floor(t * i)),
            (e.height = Math.floor(n * i)),
            this.setViewport(0, 0, t, n);
        }),
        (this.getCurrentViewport = function (t) {
          return t.copy(b);
        }),
        (this.getViewport = function (t) {
          return t.copy(N);
        }),
        (this.setViewport = function (t, e, n, i) {
          t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i),
            j.viewport(b.copy(N).multiplyScalar(L).round());
        }),
        (this.getScissor = function (t) {
          return t.copy(F);
        }),
        (this.setScissor = function (t, e, n, i) {
          t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, i),
            j.scissor(D.copy(F).multiplyScalar(L).round());
        }),
        (this.getScissorTest = function () {
          return O;
        }),
        (this.setScissorTest = function (t) {
          j.setScissorTest((O = t));
        }),
        (this.setOpaqueSort = function (t) {
          I = t;
        }),
        (this.setTransparentSort = function (t) {
          U = t;
        }),
        (this.getClearColor = function (t) {
          return t.copy(lt.getClearColor());
        }),
        (this.setClearColor = function () {
          lt.setClearColor.apply(lt, arguments);
        }),
        (this.getClearAlpha = function () {
          return lt.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          lt.setClearAlpha.apply(lt, arguments);
        }),
        (this.clear = function (t = !0, e = !0, n = !0) {
          let i = 0;
          if (t) {
            let t = !1;
            if (null !== M) {
              const e = M.texture.format;
              t = 1033 === e || 1031 === e || 1029 === e;
            }
            if (t) {
              const t = M.texture.type,
                e =
                  t === Vc ||
                  t === Hc ||
                  1012 === t ||
                  t === Xc ||
                  1017 === t ||
                  1018 === t,
                n = lt.getClearColor(),
                i = lt.getClearAlpha(),
                r = n.r,
                s = n.g,
                a = n.b;
              e
                ? ((d[0] = r),
                  (d[1] = s),
                  (d[2] = a),
                  (d[3] = i),
                  mt.clearBufferuiv(mt.COLOR, 0, d))
                : ((p[0] = r),
                  (p[1] = s),
                  (p[2] = a),
                  (p[3] = i),
                  mt.clearBufferiv(mt.COLOR, 0, p));
            } else i |= mt.COLOR_BUFFER_BIT;
          }
          e && (i |= mt.DEPTH_BUFFER_BIT),
            n &&
              ((i |= mt.STENCIL_BUFFER_BIT),
              this.state.buffers.stencil.setMask(4294967295)),
            mt.clear(i);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          e.removeEventListener("webglcontextlost", xt, !1),
            e.removeEventListener("webglcontextrestored", yt, !1),
            e.removeEventListener("webglcontextcreationerror", St, !1),
            rt.dispose(),
            st.dispose(),
            K.dispose(),
            J.dispose(),
            $.dispose(),
            et.dispose(),
            pt.dispose(),
            ft.dispose(),
            nt.dispose(),
            _t.dispose(),
            _t.removeEventListener("sessionstart", bt),
            _t.removeEventListener("sessionend", Dt),
            wt.stop();
        }),
        (this.renderBufferDirect = function (t, e, n, i, r, s) {
          null === e && (e = G);
          const a = r.isMesh && r.matrixWorld.determinant() < 0,
            o = (function (t, e, n, i, r) {
              !0 !== e.isScene && (e = G), Z.resetTextureUnits();
              const s = e.fog,
                a = i.isMeshStandardMaterial ? e.environment : null,
                o =
                  null === M
                    ? _.outputColorSpace
                    : !0 === M.isXRRenderTarget
                    ? M.texture.colorSpace
                    : su,
                l = (i.isMeshStandardMaterial ? $ : J).get(i.envMap || a),
                c =
                  !0 === i.vertexColors &&
                  !!n.attributes.color &&
                  4 === n.attributes.color.itemSize,
                u =
                  !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
                h = !!n.morphAttributes.position,
                d = !!n.morphAttributes.normal,
                p = !!n.morphAttributes.color;
              let f = Sc;
              i.toneMapped &&
                ((null !== M && !0 !== M.isXRRenderTarget) ||
                  (f = _.toneMapping));
              const g =
                  n.morphAttributes.position ||
                  n.morphAttributes.normal ||
                  n.morphAttributes.color,
                v = void 0 !== g ? g.length : 0,
                x = K.get(i),
                y = m.state.lights;
              if (!0 === z && (!0 === k || t !== T)) {
                const e = t === T && i.id === E;
                at.setState(i, t, e);
              }
              let S = !1;
              i.version === x.__version
                ? (x.needsLights && x.lightsStateVersion !== y.state.version) ||
                  x.outputColorSpace !== o ||
                  (r.isBatchedMesh && !1 === x.batching)
                  ? (S = !0)
                  : r.isBatchedMesh || !0 !== x.batching
                  ? r.isInstancedMesh && !1 === x.instancing
                    ? (S = !0)
                    : r.isInstancedMesh || !0 !== x.instancing
                    ? r.isSkinnedMesh && !1 === x.skinning
                      ? (S = !0)
                      : r.isSkinnedMesh || !0 !== x.skinning
                      ? (r.isInstancedMesh &&
                          !0 === x.instancingColor &&
                          null === r.instanceColor) ||
                        (r.isInstancedMesh &&
                          !1 === x.instancingColor &&
                          null !== r.instanceColor) ||
                        (r.isInstancedMesh &&
                          !0 === x.instancingMorph &&
                          null === r.morphTexture) ||
                        (r.isInstancedMesh &&
                          !1 === x.instancingMorph &&
                          null !== r.morphTexture) ||
                        x.envMap !== l ||
                        (!0 === i.fog && x.fog !== s)
                        ? (S = !0)
                        : void 0 === x.numClippingPlanes ||
                          (x.numClippingPlanes === at.numPlanes &&
                            x.numIntersection === at.numIntersection)
                        ? (x.vertexAlphas !== c ||
                            x.vertexTangents !== u ||
                            x.morphTargets !== h ||
                            x.morphNormals !== d ||
                            x.morphColors !== p ||
                            x.toneMapping !== f ||
                            x.morphTargetsCount !== v) &&
                          (S = !0)
                        : (S = !0)
                      : (S = !0)
                    : (S = !0)
                  : (S = !0)
                : ((S = !0), (x.__version = i.version));
              let b = x.currentProgram;
              !0 === S && (b = It(i, e, r));
              let D = !1,
                w = !1,
                C = !1;
              const A = b.getUniforms(),
                R = x.uniforms;
              if (
                (j.useProgram(b.program) && ((D = !0), (w = !0), (C = !0)),
                i.id !== E && ((E = i.id), (w = !0)),
                D || T !== t)
              ) {
                A.setValue(mt, "projectionMatrix", t.projectionMatrix),
                  A.setValue(mt, "viewMatrix", t.matrixWorldInverse);
                const e = A.map.cameraPosition;
                void 0 !== e &&
                  e.setValue(mt, H.setFromMatrixPosition(t.matrixWorld)),
                  q.logarithmicDepthBuffer &&
                    A.setValue(
                      mt,
                      "logDepthBufFC",
                      2 / (Math.log(t.far + 1) / Math.LN2)
                    ),
                  (i.isMeshPhongMaterial ||
                    i.isMeshToonMaterial ||
                    i.isMeshLambertMaterial ||
                    i.isMeshBasicMaterial ||
                    i.isMeshStandardMaterial ||
                    i.isShaderMaterial) &&
                    A.setValue(
                      mt,
                      "isOrthographic",
                      !0 === t.isOrthographicCamera
                    ),
                  T !== t && ((T = t), (w = !0), (C = !0));
              }
              if (r.isSkinnedMesh) {
                A.setOptional(mt, r, "bindMatrix"),
                  A.setOptional(mt, r, "bindMatrixInverse");
                const t = r.skeleton;
                t &&
                  (null === t.boneTexture && t.computeBoneTexture(),
                  A.setValue(mt, "boneTexture", t.boneTexture, Z));
              }
              r.isBatchedMesh &&
                (A.setOptional(mt, r, "batchingTexture"),
                A.setValue(mt, "batchingTexture", r._matricesTexture, Z));
              const I = n.morphAttributes;
              var U, N;
              if (
                ((void 0 === I.position &&
                  void 0 === I.normal &&
                  void 0 === I.color) ||
                  ct.update(r, n, b),
                (w || x.receiveShadow !== r.receiveShadow) &&
                  ((x.receiveShadow = r.receiveShadow),
                  A.setValue(mt, "receiveShadow", r.receiveShadow)),
                i.isMeshGouraudMaterial &&
                  null !== i.envMap &&
                  ((R.envMap.value = l),
                  (R.flipEnvMap.value =
                    l.isCubeTexture && !1 === l.isRenderTargetTexture
                      ? -1
                      : 1)),
                i.isMeshStandardMaterial &&
                  null === i.envMap &&
                  null !== e.environment &&
                  (R.envMapIntensity.value = e.environmentIntensity),
                w &&
                  (A.setValue(mt, "toneMappingExposure", _.toneMappingExposure),
                  x.needsLights &&
                    ((N = C),
                    ((U = R).ambientLightColor.needsUpdate = N),
                    (U.lightProbe.needsUpdate = N),
                    (U.directionalLights.needsUpdate = N),
                    (U.directionalLightShadows.needsUpdate = N),
                    (U.pointLights.needsUpdate = N),
                    (U.pointLightShadows.needsUpdate = N),
                    (U.spotLights.needsUpdate = N),
                    (U.spotLightShadows.needsUpdate = N),
                    (U.rectAreaLights.needsUpdate = N),
                    (U.hemisphereLights.needsUpdate = N)),
                  s && !0 === i.fog && it.refreshFogUniforms(R, s),
                  it.refreshMaterialUniforms(
                    R,
                    i,
                    L,
                    P,
                    m.state.transmissionRenderTarget[t.id]
                  ),
                  Sm.upload(mt, Ut(x), R, Z)),
                i.isShaderMaterial &&
                  !0 === i.uniformsNeedUpdate &&
                  (Sm.upload(mt, Ut(x), R, Z), (i.uniformsNeedUpdate = !1)),
                i.isSpriteMaterial && A.setValue(mt, "center", r.center),
                A.setValue(mt, "modelViewMatrix", r.modelViewMatrix),
                A.setValue(mt, "normalMatrix", r.normalMatrix),
                A.setValue(mt, "modelMatrix", r.matrixWorld),
                i.isShaderMaterial || i.isRawShaderMaterial)
              ) {
                const t = i.uniformsGroups;
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e];
                  ft.update(n, b), ft.bind(n, b);
                }
              }
              return b;
            })(t, e, n, i, r);
          j.setMaterial(i, a);
          let l = n.index,
            c = 1;
          if (!0 === i.wireframe) {
            if (((l = tt.getWireframeAttribute(n)), void 0 === l)) return;
            c = 2;
          }
          const u = n.drawRange,
            h = n.attributes.position;
          let d = u.start * c,
            p = (u.start + u.count) * c;
          null !== s &&
            ((d = Math.max(d, s.start * c)),
            (p = Math.min(p, (s.start + s.count) * c))),
            null !== l
              ? ((d = Math.max(d, 0)), (p = Math.min(p, l.count)))
              : null != h && ((d = Math.max(d, 0)), (p = Math.min(p, h.count)));
          const f = p - d;
          if (f < 0 || f === 1 / 0) return;
          let g;
          pt.setup(r, i, o, n, l);
          let v = ut;
          if (
            (null !== l && ((g = Q.get(l)), (v = ht), v.setIndex(g)), r.isMesh)
          )
            !0 === i.wireframe
              ? (j.setLineWidth(i.wireframeLinewidth * W()),
                v.setMode(mt.LINES))
              : v.setMode(mt.TRIANGLES);
          else if (r.isLine) {
            let t = i.linewidth;
            void 0 === t && (t = 1),
              j.setLineWidth(t * W()),
              r.isLineSegments
                ? v.setMode(mt.LINES)
                : r.isLineLoop
                ? v.setMode(mt.LINE_LOOP)
                : v.setMode(mt.LINE_STRIP);
          } else
            r.isPoints
              ? v.setMode(mt.POINTS)
              : r.isSprite && v.setMode(mt.TRIANGLES);
          if (r.isBatchedMesh)
            null !== r._multiDrawInstances
              ? v.renderMultiDrawInstances(
                  r._multiDrawStarts,
                  r._multiDrawCounts,
                  r._multiDrawCount,
                  r._multiDrawInstances
                )
              : v.renderMultiDraw(
                  r._multiDrawStarts,
                  r._multiDrawCounts,
                  r._multiDrawCount
                );
          else if (r.isInstancedMesh) v.renderInstances(d, f, r.count);
          else if (n.isInstancedBufferGeometry) {
            const t =
                void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
              e = Math.min(n.instanceCount, t);
            v.renderInstances(d, f, e);
          } else v.render(d, f);
        }),
        (this.compile = function (t, e, n = null) {
          null === n && (n = t),
            (m = st.get(n)),
            m.init(e),
            v.push(m),
            n.traverseVisible(function (t) {
              t.isLight &&
                t.layers.test(e.layers) &&
                (m.pushLight(t), t.castShadow && m.pushShadow(t));
            }),
            t !== n &&
              t.traverseVisible(function (t) {
                t.isLight &&
                  t.layers.test(e.layers) &&
                  (m.pushLight(t), t.castShadow && m.pushShadow(t));
              }),
            m.setupLights(_._useLegacyLights);
          const i = new Set();
          return (
            t.traverse(function (t) {
              const e = t.material;
              if (e)
                if (Array.isArray(e))
                  for (let r = 0; r < e.length; r++) {
                    const s = e[r];
                    Et(s, n, t), i.add(s);
                  }
                else Et(e, n, t), i.add(e);
            }),
            v.pop(),
            (m = null),
            i
          );
        }),
        (this.compileAsync = function (t, e, n = null) {
          const i = this.compile(t, e, n);
          return new Promise((e) => {
            function n() {
              i.forEach(function (t) {
                K.get(t).currentProgram.isReady() && i.delete(t);
              }),
                0 !== i.size ? setTimeout(n, 10) : e(t);
            }
            null !== X.get("KHR_parallel_shader_compile")
              ? n()
              : setTimeout(n, 10);
          });
        });
      let Tt = null;
      function bt() {
        wt.stop();
      }
      function Dt() {
        wt.start();
      }
      const wt = new Pp();
      function Ct(t, e, n, i) {
        if (!1 === t.visible) return;
        if (t.layers.test(e.layers))
          if (t.isGroup) n = t.renderOrder;
          else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
          else if (t.isLight) m.pushLight(t), t.castShadow && m.pushShadow(t);
          else if (t.isSprite) {
            if (!t.frustumCulled || B.intersectsSprite(t)) {
              i && H.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V);
              const e = et.update(t),
                r = t.material;
              r.visible && f.push(t, e, r, n, H.z, null);
            }
          } else if (
            (t.isMesh || t.isLine || t.isPoints) &&
            (!t.frustumCulled || B.intersectsObject(t))
          ) {
            const e = et.update(t),
              r = t.material;
            if (
              (i &&
                (void 0 !== t.boundingSphere
                  ? (null === t.boundingSphere && t.computeBoundingSphere(),
                    H.copy(t.boundingSphere.center))
                  : (null === e.boundingSphere && e.computeBoundingSphere(),
                    H.copy(e.boundingSphere.center)),
                H.applyMatrix4(t.matrixWorld).applyMatrix4(V)),
              Array.isArray(r))
            ) {
              const i = e.groups;
              for (let s = 0, a = i.length; s < a; s++) {
                const a = i[s],
                  o = r[a.materialIndex];
                o && o.visible && f.push(t, e, o, n, H.z, a);
              }
            } else r.visible && f.push(t, e, r, n, H.z, null);
          }
        const r = t.children;
        for (let t = 0, s = r.length; t < s; t++) Ct(r[t], e, n, i);
      }
      function At(t, e, n, i) {
        const r = t.opaque,
          s = t.transmissive,
          a = t.transparent;
        m.setupLightsView(n),
          !0 === z && at.setGlobalState(_.clippingPlanes, n),
          i && j.viewport(b.copy(i)),
          r.length > 0 && Pt(r, e, n),
          s.length > 0 && Pt(s, e, n),
          a.length > 0 && Pt(a, e, n),
          j.buffers.depth.setTest(!0),
          j.buffers.depth.setMask(!0),
          j.buffers.color.setMask(!0),
          j.setPolygonOffset(!1);
      }
      function Rt(t, e, n, i) {
        if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return;
        void 0 === m.state.transmissionRenderTarget[i.id] &&
          (m.state.transmissionRenderTarget[i.id] = new nh(1, 1, {
            generateMipmaps: !0,
            type:
              X.has("EXT_color_buffer_half_float") ||
              X.has("EXT_color_buffer_float")
                ? Wc
                : Vc,
            minFilter: kc,
            samples: 4,
            stencilBuffer: r,
            resolveDepthBuffer: !1,
            resolveStencilBuffer: !1,
          }));
        const s = m.state.transmissionRenderTarget[i.id],
          a = i.viewport || b;
        s.setSize(a.z, a.w);
        const o = _.getRenderTarget();
        _.setRenderTarget(s),
          _.getClearColor(C),
          (A = _.getClearAlpha()),
          A < 1 && _.setClearColor(16777215, 0.5),
          _.clear();
        const l = _.toneMapping;
        _.toneMapping = Sc;
        const c = i.viewport;
        if (
          (void 0 !== i.viewport && (i.viewport = void 0),
          m.setupLightsView(i),
          !0 === z && at.setGlobalState(_.clippingPlanes, i),
          Pt(t, n, i),
          Z.updateMultisampleRenderTarget(s),
          Z.updateRenderTargetMipmap(s),
          !1 === X.has("WEBGL_multisampled_render_to_texture"))
        ) {
          let t = !1;
          for (let r = 0, s = e.length; r < s; r++) {
            const s = e[r],
              a = s.object,
              o = s.geometry,
              l = s.material,
              c = s.group;
            if (2 === l.side && a.layers.test(i.layers)) {
              const e = l.side;
              (l.side = 1),
                (l.needsUpdate = !0),
                Lt(a, n, i, o, l, c),
                (l.side = e),
                (l.needsUpdate = !0),
                (t = !0);
            }
          }
          !0 === t &&
            (Z.updateMultisampleRenderTarget(s), Z.updateRenderTargetMipmap(s));
        }
        _.setRenderTarget(o),
          _.setClearColor(C, A),
          void 0 !== c && (i.viewport = c),
          (_.toneMapping = l);
      }
      function Pt(t, e, n) {
        const i = !0 === e.isScene ? e.overrideMaterial : null;
        for (let r = 0, s = t.length; r < s; r++) {
          const s = t[r],
            a = s.object,
            o = s.geometry,
            l = null === i ? s.material : i,
            c = s.group;
          a.layers.test(n.layers) && Lt(a, e, n, o, l, c);
        }
      }
      function Lt(t, e, n, i, r, s) {
        t.onBeforeRender(_, e, n, i, r, s),
          t.modelViewMatrix.multiplyMatrices(
            n.matrixWorldInverse,
            t.matrixWorld
          ),
          t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
          r.onBeforeRender(_, e, n, i, t, s),
          !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass
            ? ((r.side = 1),
              (r.needsUpdate = !0),
              _.renderBufferDirect(n, e, i, r, t, s),
              (r.side = 0),
              (r.needsUpdate = !0),
              _.renderBufferDirect(n, e, i, r, t, s),
              (r.side = 2))
            : _.renderBufferDirect(n, e, i, r, t, s),
          t.onAfterRender(_, e, n, i, r, s);
      }
      function It(t, e, n) {
        !0 !== e.isScene && (e = G);
        const i = K.get(t),
          r = m.state.lights,
          s = m.state.shadowsArray,
          a = r.state.version,
          o = nt.getParameters(t, r.state, s, e, n),
          l = nt.getProgramCacheKey(o);
        let c = i.programs;
        (i.environment = t.isMeshStandardMaterial ? e.environment : null),
          (i.fog = e.fog),
          (i.envMap = (t.isMeshStandardMaterial ? $ : J).get(
            t.envMap || i.environment
          )),
          (i.envMapRotation =
            null !== i.environment && null === t.envMap
              ? e.environmentRotation
              : t.envMapRotation),
          void 0 === c &&
            (t.addEventListener("dispose", Mt),
            (c = new Map()),
            (i.programs = c));
        let u = c.get(l);
        if (void 0 !== u) {
          if (i.currentProgram === u && i.lightsStateVersion === a)
            return Nt(t, o), u;
        } else
          (o.uniforms = nt.getUniforms(t)),
            t.onBuild(n, o, _),
            t.onBeforeCompile(o, _),
            (u = nt.acquireProgram(o, l)),
            c.set(l, u),
            (i.uniforms = o.uniforms);
        const h = i.uniforms;
        return (
          ((t.isShaderMaterial || t.isRawShaderMaterial) &&
            !0 !== t.clipping) ||
            (h.clippingPlanes = at.uniform),
          Nt(t, o),
          (i.needsLights = (function (t) {
            return (
              t.isMeshLambertMaterial ||
              t.isMeshToonMaterial ||
              t.isMeshPhongMaterial ||
              t.isMeshStandardMaterial ||
              t.isShadowMaterial ||
              (t.isShaderMaterial && !0 === t.lights)
            );
          })(t)),
          (i.lightsStateVersion = a),
          i.needsLights &&
            ((h.ambientLightColor.value = r.state.ambient),
            (h.lightProbe.value = r.state.probe),
            (h.directionalLights.value = r.state.directional),
            (h.directionalLightShadows.value = r.state.directionalShadow),
            (h.spotLights.value = r.state.spot),
            (h.spotLightShadows.value = r.state.spotShadow),
            (h.rectAreaLights.value = r.state.rectArea),
            (h.ltc_1.value = r.state.rectAreaLTC1),
            (h.ltc_2.value = r.state.rectAreaLTC2),
            (h.pointLights.value = r.state.point),
            (h.pointLightShadows.value = r.state.pointShadow),
            (h.hemisphereLights.value = r.state.hemi),
            (h.directionalShadowMap.value = r.state.directionalShadowMap),
            (h.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
            (h.spotShadowMap.value = r.state.spotShadowMap),
            (h.spotLightMatrix.value = r.state.spotLightMatrix),
            (h.spotLightMap.value = r.state.spotLightMap),
            (h.pointShadowMap.value = r.state.pointShadowMap),
            (h.pointShadowMatrix.value = r.state.pointShadowMatrix)),
          (i.currentProgram = u),
          (i.uniformsList = null),
          u
        );
      }
      function Ut(t) {
        if (null === t.uniformsList) {
          const e = t.currentProgram.getUniforms();
          t.uniformsList = Sm.seqWithValue(e.seq, t.uniforms);
        }
        return t.uniformsList;
      }
      function Nt(t, e) {
        const n = K.get(t);
        (n.outputColorSpace = e.outputColorSpace),
          (n.batching = e.batching),
          (n.instancing = e.instancing),
          (n.instancingColor = e.instancingColor),
          (n.instancingMorph = e.instancingMorph),
          (n.skinning = e.skinning),
          (n.morphTargets = e.morphTargets),
          (n.morphNormals = e.morphNormals),
          (n.morphColors = e.morphColors),
          (n.morphTargetsCount = e.morphTargetsCount),
          (n.numClippingPlanes = e.numClippingPlanes),
          (n.numIntersection = e.numClipIntersection),
          (n.vertexAlphas = e.vertexAlphas),
          (n.vertexTangents = e.vertexTangents),
          (n.toneMapping = e.toneMapping);
      }
      wt.setAnimationLoop(function (t) {
        Tt && Tt(t);
      }),
        "undefined" != typeof self && wt.setContext(self),
        (this.setAnimationLoop = function (t) {
          (Tt = t), _t.setAnimationLoop(t), null === t ? wt.stop() : wt.start();
        }),
        _t.addEventListener("sessionstart", bt),
        _t.addEventListener("sessionend", Dt),
        (this.render = function (t, e) {
          if (void 0 !== e && !0 !== e.isCamera)
            return void console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
            );
          if (!0 === x) return;
          !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
            null === e.parent &&
              !0 === e.matrixWorldAutoUpdate &&
              e.updateMatrixWorld(),
            !0 === _t.enabled &&
              !0 === _t.isPresenting &&
              (!0 === _t.cameraAutoUpdate && _t.updateCamera(e),
              (e = _t.getCamera())),
            !0 === t.isScene && t.onBeforeRender(_, t, e, M),
            (m = st.get(t, v.length)),
            m.init(e),
            v.push(m),
            V.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            B.setFromProjectionMatrix(V),
            (k = this.localClippingEnabled),
            (z = at.init(this.clippingPlanes, k)),
            (f = rt.get(t, g.length)),
            f.init(),
            g.push(f),
            Ct(t, e, 0, _.sortObjects),
            f.finish(),
            !0 === _.sortObjects && f.sort(I, U);
          const n =
            !1 === _t.enabled ||
            !1 === _t.isPresenting ||
            !1 === _t.hasDepthSensing();
          n && lt.addToRenderList(f, t),
            this.info.render.frame++,
            !0 === z && at.beginShadows();
          const i = m.state.shadowsArray;
          ot.render(i, t, e),
            !0 === z && at.endShadows(),
            !0 === this.info.autoReset && this.info.reset();
          const r = f.opaque,
            s = f.transmissive;
          if ((m.setupLights(_._useLegacyLights), e.isArrayCamera)) {
            const i = e.cameras;
            if (s.length > 0)
              for (let e = 0, n = i.length; e < n; e++) Rt(r, s, t, i[e]);
            n && lt.render(t);
            for (let e = 0, n = i.length; e < n; e++) {
              const n = i[e];
              At(f, t, n, n.viewport);
            }
          } else s.length > 0 && Rt(r, s, t, e), n && lt.render(t), At(f, t, e);
          null !== M &&
            (Z.updateMultisampleRenderTarget(M), Z.updateRenderTargetMipmap(M)),
            !0 === t.isScene && t.onAfterRender(_, t, e),
            pt.resetDefaultState(),
            (E = -1),
            (T = null),
            v.pop(),
            v.length > 0
              ? ((m = v[v.length - 1]),
                !0 === z && at.setGlobalState(_.clippingPlanes, m.state.camera))
              : (m = null),
            g.pop(),
            (f = g.length > 0 ? g[g.length - 1] : null);
        }),
        (this.getActiveCubeFace = function () {
          return y;
        }),
        (this.getActiveMipmapLevel = function () {
          return S;
        }),
        (this.getRenderTarget = function () {
          return M;
        }),
        (this.setRenderTargetTextures = function (t, e, n) {
          (K.get(t.texture).__webglTexture = e),
            (K.get(t.depthTexture).__webglTexture = n);
          const i = K.get(t);
          (i.__hasExternalTextures = !0),
            (i.__autoAllocateDepthBuffer = void 0 === n),
            i.__autoAllocateDepthBuffer ||
              (!0 === X.has("WEBGL_multisampled_render_to_texture") &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (i.__useRenderToTexture = !1)));
        }),
        (this.setRenderTargetFramebuffer = function (t, e) {
          const n = K.get(t);
          (n.__webglFramebuffer = e),
            (n.__useDefaultFramebuffer = void 0 === e);
        }),
        (this.setRenderTarget = function (t, e = 0, n = 0) {
          (M = t), (y = e), (S = n);
          let i = !0,
            r = null,
            s = !1,
            a = !1;
          if (t) {
            const o = K.get(t);
            void 0 !== o.__useDefaultFramebuffer
              ? (j.bindFramebuffer(mt.FRAMEBUFFER, null), (i = !1))
              : void 0 === o.__webglFramebuffer
              ? Z.setupRenderTarget(t)
              : o.__hasExternalTextures &&
                Z.rebindTextures(
                  t,
                  K.get(t.texture).__webglTexture,
                  K.get(t.depthTexture).__webglTexture
                );
            const l = t.texture;
            (l.isData3DTexture ||
              l.isDataArrayTexture ||
              l.isCompressedArrayTexture) &&
              (a = !0);
            const c = K.get(t).__webglFramebuffer;
            t.isWebGLCubeRenderTarget
              ? ((r = Array.isArray(c[e]) ? c[e][n] : c[e]), (s = !0))
              : (r =
                  t.samples > 0 && !1 === Z.useMultisampledRTT(t)
                    ? K.get(t).__webglMultisampledFramebuffer
                    : Array.isArray(c)
                    ? c[n]
                    : c),
              b.copy(t.viewport),
              D.copy(t.scissor),
              (w = t.scissorTest);
          } else
            b.copy(N).multiplyScalar(L).floor(),
              D.copy(F).multiplyScalar(L).floor(),
              (w = O);
          if (
            (j.bindFramebuffer(mt.FRAMEBUFFER, r) && i && j.drawBuffers(t, r),
            j.viewport(b),
            j.scissor(D),
            j.setScissorTest(w),
            s)
          ) {
            const i = K.get(t.texture);
            mt.framebufferTexture2D(
              mt.FRAMEBUFFER,
              mt.COLOR_ATTACHMENT0,
              mt.TEXTURE_CUBE_MAP_POSITIVE_X + e,
              i.__webglTexture,
              n
            );
          } else if (a) {
            const i = K.get(t.texture),
              r = e || 0;
            mt.framebufferTextureLayer(
              mt.FRAMEBUFFER,
              mt.COLOR_ATTACHMENT0,
              i.__webglTexture,
              n || 0,
              r
            );
          }
          E = -1;
        }),
        (this.readRenderTargetPixels = function (t, e, n, i, r, s, a) {
          if (!t || !t.isWebGLRenderTarget)
            return void console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
          let o = K.get(t).__webglFramebuffer;
          if ((t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
            j.bindFramebuffer(mt.FRAMEBUFFER, o);
            try {
              const a = t.texture,
                o = a.format,
                l = a.type;
              if (!q.textureFormatReadable(o))
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                );
              if (!q.textureTypeReadable(l))
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                );
              e >= 0 &&
                e <= t.width - i &&
                n >= 0 &&
                n <= t.height - r &&
                mt.readPixels(e, n, i, r, dt.convert(o), dt.convert(l), s);
            } finally {
              const t = null !== M ? K.get(M).__webglFramebuffer : null;
              j.bindFramebuffer(mt.FRAMEBUFFER, t);
            }
          }
        }),
        (this.copyFramebufferToTexture = function (t, e, n = 0) {
          const i = Math.pow(2, -n),
            r = Math.floor(e.image.width * i),
            s = Math.floor(e.image.height * i);
          Z.setTexture2D(e, 0),
            mt.copyTexSubImage2D(mt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s),
            j.unbindTexture();
        }),
        (this.copyTextureToTexture = function (t, e, n, i = 0) {
          const r = e.image.width,
            s = e.image.height,
            a = dt.convert(n.format),
            o = dt.convert(n.type);
          Z.setTexture2D(n, 0),
            mt.pixelStorei(mt.UNPACK_FLIP_Y_WEBGL, n.flipY),
            mt.pixelStorei(
              mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              n.premultiplyAlpha
            ),
            mt.pixelStorei(mt.UNPACK_ALIGNMENT, n.unpackAlignment),
            e.isDataTexture
              ? mt.texSubImage2D(
                  mt.TEXTURE_2D,
                  i,
                  t.x,
                  t.y,
                  r,
                  s,
                  a,
                  o,
                  e.image.data
                )
              : e.isCompressedTexture
              ? mt.compressedTexSubImage2D(
                  mt.TEXTURE_2D,
                  i,
                  t.x,
                  t.y,
                  e.mipmaps[0].width,
                  e.mipmaps[0].height,
                  a,
                  e.mipmaps[0].data
                )
              : mt.texSubImage2D(mt.TEXTURE_2D, i, t.x, t.y, a, o, e.image),
            0 === i && n.generateMipmaps && mt.generateMipmap(mt.TEXTURE_2D),
            j.unbindTexture();
        }),
        (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
          const s = t.max.x - t.min.x,
            a = t.max.y - t.min.y,
            o = t.max.z - t.min.z,
            l = dt.convert(i.format),
            c = dt.convert(i.type);
          let u;
          if (i.isData3DTexture) Z.setTexture3D(i, 0), (u = mt.TEXTURE_3D);
          else {
            if (!i.isDataArrayTexture && !i.isCompressedArrayTexture)
              return void console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
            Z.setTexture2DArray(i, 0), (u = mt.TEXTURE_2D_ARRAY);
          }
          mt.pixelStorei(mt.UNPACK_FLIP_Y_WEBGL, i.flipY),
            mt.pixelStorei(
              mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              i.premultiplyAlpha
            ),
            mt.pixelStorei(mt.UNPACK_ALIGNMENT, i.unpackAlignment);
          const h = mt.getParameter(mt.UNPACK_ROW_LENGTH),
            d = mt.getParameter(mt.UNPACK_IMAGE_HEIGHT),
            p = mt.getParameter(mt.UNPACK_SKIP_PIXELS),
            f = mt.getParameter(mt.UNPACK_SKIP_ROWS),
            m = mt.getParameter(mt.UNPACK_SKIP_IMAGES),
            g = n.isCompressedTexture ? n.mipmaps[r] : n.image;
          mt.pixelStorei(mt.UNPACK_ROW_LENGTH, g.width),
            mt.pixelStorei(mt.UNPACK_IMAGE_HEIGHT, g.height),
            mt.pixelStorei(mt.UNPACK_SKIP_PIXELS, t.min.x),
            mt.pixelStorei(mt.UNPACK_SKIP_ROWS, t.min.y),
            mt.pixelStorei(mt.UNPACK_SKIP_IMAGES, t.min.z),
            n.isDataTexture || n.isData3DTexture
              ? mt.texSubImage3D(u, r, e.x, e.y, e.z, s, a, o, l, c, g.data)
              : i.isCompressedArrayTexture
              ? mt.compressedTexSubImage3D(
                  u,
                  r,
                  e.x,
                  e.y,
                  e.z,
                  s,
                  a,
                  o,
                  l,
                  g.data
                )
              : mt.texSubImage3D(u, r, e.x, e.y, e.z, s, a, o, l, c, g),
            mt.pixelStorei(mt.UNPACK_ROW_LENGTH, h),
            mt.pixelStorei(mt.UNPACK_IMAGE_HEIGHT, d),
            mt.pixelStorei(mt.UNPACK_SKIP_PIXELS, p),
            mt.pixelStorei(mt.UNPACK_SKIP_ROWS, f),
            mt.pixelStorei(mt.UNPACK_SKIP_IMAGES, m),
            0 === r && i.generateMipmaps && mt.generateMipmap(u),
            j.unbindTexture();
        }),
        (this.initTexture = function (t) {
          t.isCubeTexture
            ? Z.setTextureCube(t, 0)
            : t.isData3DTexture
            ? Z.setTexture3D(t, 0)
            : t.isDataArrayTexture || t.isCompressedArrayTexture
            ? Z.setTexture2DArray(t, 0)
            : Z.setTexture2D(t, 0),
            j.unbindTexture();
        }),
        (this.resetState = function () {
          (y = 0), (S = 0), (M = null), j.reset(), pt.reset();
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    get coordinateSystem() {
      return Mu;
    }
    get outputColorSpace() {
      return this._outputColorSpace;
    }
    set outputColorSpace(t) {
      this._outputColorSpace = t;
      const e = this.getContext();
      (e.drawingBufferColorSpace = t === au ? "display-p3" : "srgb"),
        (e.unpackColorSpace =
          Wu.workingColorSpace === ou ? "display-p3" : "srgb");
    }
    get useLegacyLights() {
      return (
        console.warn(
          "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
        ),
        this._useLegacyLights
      );
    }
    set useLegacyLights(t) {
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
        (this._useLegacyLights = t);
    }
  }
  class _g extends cd {
    constructor() {
      super(),
        (this.isScene = !0),
        (this.type = "Scene"),
        (this.background = null),
        (this.environment = null),
        (this.fog = null),
        (this.backgroundBlurriness = 0),
        (this.backgroundIntensity = 1),
        (this.backgroundRotation = new qh()),
        (this.environmentIntensity = 1),
        (this.environmentRotation = new qh()),
        (this.overrideMaterial = null),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    copy(t, e) {
      return (
        super.copy(t, e),
        null !== t.background && (this.background = t.background.clone()),
        null !== t.environment && (this.environment = t.environment.clone()),
        null !== t.fog && (this.fog = t.fog.clone()),
        (this.backgroundBlurriness = t.backgroundBlurriness),
        (this.backgroundIntensity = t.backgroundIntensity),
        this.backgroundRotation.copy(t.backgroundRotation),
        (this.environmentIntensity = t.environmentIntensity),
        this.environmentRotation.copy(t.environmentRotation),
        null !== t.overrideMaterial &&
          (this.overrideMaterial = t.overrideMaterial.clone()),
        (this.matrixAutoUpdate = t.matrixAutoUpdate),
        this
      );
    }
    toJSON(t) {
      const e = super.toJSON(t);
      return (
        null !== this.fog && (e.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 &&
          (e.object.backgroundBlurriness = this.backgroundBlurriness),
        1 !== this.backgroundIntensity &&
          (e.object.backgroundIntensity = this.backgroundIntensity),
        (e.object.backgroundRotation = this.backgroundRotation.toArray()),
        1 !== this.environmentIntensity &&
          (e.object.environmentIntensity = this.environmentIntensity),
        (e.object.environmentRotation = this.environmentRotation.toArray()),
        e
      );
    }
  }
  class xg extends Qu {
    constructor(t, e, n, i, r, s, a, o, l) {
      super(t, e, n, i, r, s, a, o, l),
        (this.isVideoTexture = !0),
        (this.minFilter = void 0 !== s ? s : Bc),
        (this.magFilter = void 0 !== r ? r : Bc),
        (this.generateMipmaps = !1);
      const c = this;
      "requestVideoFrameCallback" in t &&
        t.requestVideoFrameCallback(function e() {
          (c.needsUpdate = !0), t.requestVideoFrameCallback(e);
        });
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      const t = this.image;
      !1 == "requestVideoFrameCallback" in t &&
        t.readyState >= t.HAVE_CURRENT_DATA &&
        (this.needsUpdate = !0);
    }
  }
  function yg(t, e, n) {
    return !t || (!n && t.constructor === e)
      ? t
      : "number" == typeof e.BYTES_PER_ELEMENT
      ? new e(t)
      : Array.prototype.slice.call(t);
  }
  class Sg {
    constructor(t, e, n, i) {
      (this.parameterPositions = t),
        (this._cachedIndex = 0),
        (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
        (this.sampleValues = e),
        (this.valueSize = n),
        (this.settings = null),
        (this.DefaultSettings_ = {});
    }
    evaluate(t) {
      const e = this.parameterPositions;
      let n = this._cachedIndex,
        i = e[n],
        r = e[n - 1];
      t: {
        e: {
          let s;
          n: {
            i: if (!(t < i)) {
              for (let s = n + 2; ; ) {
                if (void 0 === i) {
                  if (t < r) break i;
                  return (
                    (n = e.length),
                    (this._cachedIndex = n),
                    this.copySampleValue_(n - 1)
                  );
                }
                if (n === s) break;
                if (((r = i), (i = e[++n]), t < i)) break e;
              }
              s = e.length;
              break n;
            }
            if (t >= r) break t;
            {
              const a = e[1];
              t < a && ((n = 2), (r = a));
              for (let s = n - 2; ; ) {
                if (void 0 === r)
                  return (this._cachedIndex = 0), this.copySampleValue_(0);
                if (n === s) break;
                if (((i = r), (r = e[--n - 1]), t >= r)) break e;
              }
              (s = n), (n = 0);
            }
          }
          for (; n < s; ) {
            const i = (n + s) >>> 1;
            t < e[i] ? (s = i) : (n = i + 1);
          }
          if (((i = e[n]), (r = e[n - 1]), void 0 === r))
            return (this._cachedIndex = 0), this.copySampleValue_(0);
          if (void 0 === i)
            return (
              (n = e.length),
              (this._cachedIndex = n),
              this.copySampleValue_(n - 1)
            );
        }
        (this._cachedIndex = n), this.intervalChanged_(n, r, i);
      }
      return this.interpolate_(n, r, t, i);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(t) {
      const e = this.resultBuffer,
        n = this.sampleValues,
        i = this.valueSize,
        r = t * i;
      for (let t = 0; t !== i; ++t) e[t] = n[r + t];
      return e;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {}
  }
  class Mg extends Sg {
    constructor(t, e, n, i) {
      super(t, e, n, i),
        (this._weightPrev = -0),
        (this._offsetPrev = -0),
        (this._weightNext = -0),
        (this._offsetNext = -0),
        (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
    }
    intervalChanged_(t, e, n) {
      const i = this.parameterPositions;
      let r = t - 2,
        s = t + 1,
        a = i[r],
        o = i[s];
      if (void 0 === a)
        switch (this.getSettings_().endingStart) {
          case 2401:
            (r = t), (a = 2 * e - n);
            break;
          case 2402:
            (r = i.length - 2), (a = e + i[r] - i[r + 1]);
            break;
          default:
            (r = t), (a = n);
        }
      if (void 0 === o)
        switch (this.getSettings_().endingEnd) {
          case 2401:
            (s = t), (o = 2 * n - e);
            break;
          case 2402:
            (s = 1), (o = n + i[1] - i[0]);
            break;
          default:
            (s = t - 1), (o = e);
        }
      const l = 0.5 * (n - e),
        c = this.valueSize;
      (this._weightPrev = l / (e - a)),
        (this._weightNext = l / (o - n)),
        (this._offsetPrev = r * c),
        (this._offsetNext = s * c);
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = t * a,
        l = o - a,
        c = this._offsetPrev,
        u = this._offsetNext,
        h = this._weightPrev,
        d = this._weightNext,
        p = (n - e) / (i - e),
        f = p * p,
        m = f * p,
        g = -h * m + 2 * h * f - h * p,
        v = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
        _ = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
        x = d * m - d * f;
      for (let t = 0; t !== a; ++t)
        r[t] = g * s[c + t] + v * s[l + t] + _ * s[o + t] + x * s[u + t];
      return r;
    }
  }
  class Eg extends Sg {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = t * a,
        l = o - a,
        c = (n - e) / (i - e),
        u = 1 - c;
      for (let t = 0; t !== a; ++t) r[t] = s[l + t] * u + s[o + t] * c;
      return r;
    }
  }
  class Tg extends Sg {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t) {
      return this.copySampleValue_(t - 1);
    }
  }
  class bg {
    constructor(t, e, n, i) {
      if (void 0 === t)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (void 0 === e || 0 === e.length)
        throw new Error(
          "THREE.KeyframeTrack: no keyframes in track named " + t
        );
      (this.name = t),
        (this.times = yg(e, this.TimeBufferType)),
        (this.values = yg(n, this.ValueBufferType)),
        this.setInterpolation(i || this.DefaultInterpolation);
    }
    static toJSON(t) {
      const e = t.constructor;
      let n;
      if (e.toJSON !== this.toJSON) n = e.toJSON(t);
      else {
        n = {
          name: t.name,
          times: yg(t.times, Array),
          values: yg(t.values, Array),
        };
        const e = t.getInterpolation();
        e !== t.DefaultInterpolation && (n.interpolation = e);
      }
      return (n.type = t.ValueTypeName), n;
    }
    InterpolantFactoryMethodDiscrete(t) {
      return new Tg(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodLinear(t) {
      return new Eg(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodSmooth(t) {
      return new Mg(this.times, this.values, this.getValueSize(), t);
    }
    setInterpolation(t) {
      let e;
      switch (t) {
        case tu:
          e = this.InterpolantFactoryMethodDiscrete;
          break;
        case eu:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case nu:
          e = this.InterpolantFactoryMethodSmooth;
      }
      if (void 0 === e) {
        const e =
          "unsupported interpolation for " +
          this.ValueTypeName +
          " keyframe track named " +
          this.name;
        if (void 0 === this.createInterpolant) {
          if (t === this.DefaultInterpolation) throw new Error(e);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", e), this;
      }
      return (this.createInterpolant = e), this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return tu;
        case this.InterpolantFactoryMethodLinear:
          return eu;
        case this.InterpolantFactoryMethodSmooth:
          return nu;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(t) {
      if (0 !== t) {
        const e = this.times;
        for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
      }
      return this;
    }
    scale(t) {
      if (1 !== t) {
        const e = this.times;
        for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
      }
      return this;
    }
    trim(t, e) {
      const n = this.times,
        i = n.length;
      let r = 0,
        s = i - 1;
      for (; r !== i && n[r] < t; ) ++r;
      for (; -1 !== s && n[s] > e; ) --s;
      if ((++s, 0 !== r || s !== i)) {
        r >= s && ((s = Math.max(s, 1)), (r = s - 1));
        const t = this.getValueSize();
        (this.times = n.slice(r, s)),
          (this.values = this.values.slice(r * t, s * t));
      }
      return this;
    }
    validate() {
      let t = !0;
      const e = this.getValueSize();
      e - Math.floor(e) != 0 &&
        (console.error(
          "THREE.KeyframeTrack: Invalid value size in track.",
          this
        ),
        (t = !1));
      const n = this.times,
        i = this.values,
        r = n.length;
      0 === r &&
        (console.error("THREE.KeyframeTrack: Track is empty.", this), (t = !1));
      let s = null;
      for (let e = 0; e !== r; e++) {
        const i = n[e];
        if ("number" == typeof i && isNaN(i)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            e,
            i
          ),
            (t = !1);
          break;
        }
        if (null !== s && s > i) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            e,
            i,
            s
          ),
            (t = !1);
          break;
        }
        s = i;
      }
      if (
        void 0 !== i &&
        ((a = i), ArrayBuffer.isView(a) && !(a instanceof DataView))
      )
        for (let e = 0, n = i.length; e !== n; ++e) {
          const n = i[e];
          if (isNaN(n)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              e,
              n
            ),
              (t = !1);
            break;
          }
        }
      var a;
      return t;
    }
    optimize() {
      const t = this.times.slice(),
        e = this.values.slice(),
        n = this.getValueSize(),
        i = this.getInterpolation() === nu,
        r = t.length - 1;
      let s = 1;
      for (let a = 1; a < r; ++a) {
        let r = !1;
        const o = t[a];
        if (o !== t[a + 1] && (1 !== a || o !== t[0]))
          if (i) r = !0;
          else {
            const t = a * n,
              i = t - n,
              s = t + n;
            for (let a = 0; a !== n; ++a) {
              const n = e[t + a];
              if (n !== e[i + a] || n !== e[s + a]) {
                r = !0;
                break;
              }
            }
          }
        if (r) {
          if (a !== s) {
            t[s] = t[a];
            const i = a * n,
              r = s * n;
            for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
          }
          ++s;
        }
      }
      if (r > 0) {
        t[s] = t[r];
        for (let t = r * n, i = s * n, a = 0; a !== n; ++a) e[i + a] = e[t + a];
        ++s;
      }
      return (
        s !== t.length
          ? ((this.times = t.slice(0, s)), (this.values = e.slice(0, s * n)))
          : ((this.times = t), (this.values = e)),
        this
      );
    }
    clone() {
      const t = this.times.slice(),
        e = this.values.slice(),
        n = new (0, this.constructor)(this.name, t, e);
      return (n.createInterpolant = this.createInterpolant), n;
    }
  }
  (bg.prototype.TimeBufferType = Float32Array),
    (bg.prototype.ValueBufferType = Float32Array),
    (bg.prototype.DefaultInterpolation = eu);
  class Dg extends bg {}
  (Dg.prototype.ValueTypeName = "bool"),
    (Dg.prototype.ValueBufferType = Array),
    (Dg.prototype.DefaultInterpolation = tu),
    (Dg.prototype.InterpolantFactoryMethodLinear = void 0),
    (Dg.prototype.InterpolantFactoryMethodSmooth = void 0);
  (class extends bg {}).prototype.ValueTypeName = "color";
  (class extends bg {}).prototype.ValueTypeName = "number";
  class wg extends Sg {
    constructor(t, e, n, i) {
      super(t, e, n, i);
    }
    interpolate_(t, e, n, i) {
      const r = this.resultBuffer,
        s = this.sampleValues,
        a = this.valueSize,
        o = (n - e) / (i - e);
      let l = t * a;
      for (let t = l + a; l !== t; l += 4)
        sh.slerpFlat(r, 0, s, l - a, s, l, o);
      return r;
    }
  }
  class Cg extends bg {
    InterpolantFactoryMethodLinear(t) {
      return new wg(this.times, this.values, this.getValueSize(), t);
    }
  }
  (Cg.prototype.ValueTypeName = "quaternion"),
    (Cg.prototype.DefaultInterpolation = eu),
    (Cg.prototype.InterpolantFactoryMethodSmooth = void 0);
  class Ag extends bg {}
  (Ag.prototype.ValueTypeName = "string"),
    (Ag.prototype.ValueBufferType = Array),
    (Ag.prototype.DefaultInterpolation = tu),
    (Ag.prototype.InterpolantFactoryMethodLinear = void 0),
    (Ag.prototype.InterpolantFactoryMethodSmooth = void 0);
  (class extends bg {}).prototype.ValueTypeName = "vector";
  Error;
  class Rg {
    constructor(t = !0) {
      (this.autoStart = t),
        (this.startTime = 0),
        (this.oldTime = 0),
        (this.elapsedTime = 0),
        (this.running = !1);
    }
    start() {
      (this.startTime = Pg()),
        (this.oldTime = this.startTime),
        (this.elapsedTime = 0),
        (this.running = !0);
    }
    stop() {
      this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let t = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        const e = Pg();
        (t = (e - this.oldTime) / 1e3),
          (this.oldTime = e),
          (this.elapsedTime += t);
      }
      return t;
    }
  }
  function Pg() {
    return ("undefined" == typeof performance ? Date : performance).now();
  }
  const Lg = "\\[\\]\\.:\\/",
    Ig = new RegExp("[" + Lg + "]", "g"),
    Ug = "[^" + Lg + "]",
    Ng = "[^" + Lg.replace("\\.", "") + "]",
    Fg = new RegExp(
      "^" +
        /((?:WC+[\/:])*)/.source.replace("WC", Ug) +
        /(WCOD+)?/.source.replace("WCOD", Ng) +
        /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Ug) +
        /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Ug) +
        "$"
    ),
    Og = ["material", "materials", "bones", "map"];
  class Bg {
    constructor(t, e, n) {
      (this.path = e),
        (this.parsedPath = n || Bg.parseTrackName(e)),
        (this.node = Bg.findNode(t, this.parsedPath.nodeName)),
        (this.rootNode = t),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
    static create(t, e, n) {
      return t && t.isAnimationObjectGroup
        ? new Bg.Composite(t, e, n)
        : new Bg(t, e, n);
    }
    static sanitizeNodeName(t) {
      return t.replace(/\s/g, "_").replace(Ig, "");
    }
    static parseTrackName(t) {
      const e = Fg.exec(t);
      if (null === e)
        throw new Error("PropertyBinding: Cannot parse trackName: " + t);
      const n = {
          nodeName: e[2],
          objectName: e[3],
          objectIndex: e[4],
          propertyName: e[5],
          propertyIndex: e[6],
        },
        i = n.nodeName && n.nodeName.lastIndexOf(".");
      if (void 0 !== i && -1 !== i) {
        const t = n.nodeName.substring(i + 1);
        -1 !== Og.indexOf(t) &&
          ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
      }
      if (null === n.propertyName || 0 === n.propertyName.length)
        throw new Error(
          "PropertyBinding: can not parse propertyName from trackName: " + t
        );
      return n;
    }
    static findNode(t, e) {
      if (
        void 0 === e ||
        "" === e ||
        "." === e ||
        -1 === e ||
        e === t.name ||
        e === t.uuid
      )
        return t;
      if (t.skeleton) {
        const n = t.skeleton.getBoneByName(e);
        if (void 0 !== n) return n;
      }
      if (t.children) {
        const n = function (t) {
            for (let i = 0; i < t.length; i++) {
              const r = t[i];
              if (r.name === e || r.uuid === e) return r;
              const s = n(r.children);
              if (s) return s;
            }
            return null;
          },
          i = n(t.children);
        if (i) return i;
      }
      return null;
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(t, e) {
      t[e] = this.targetObject[this.propertyName];
    }
    _getValue_array(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
    }
    _getValue_arrayElement(t, e) {
      t[e] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(t, e) {
      this.resolvedProperty.toArray(t, e);
    }
    _setValue_direct(t, e) {
      this.targetObject[this.propertyName] = t[e];
    }
    _setValue_direct_setNeedsUpdate(t, e) {
      (this.targetObject[this.propertyName] = t[e]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
      (this.targetObject[this.propertyName] = t[e]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_array(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
    }
    _setValue_array_setNeedsUpdate(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
      this.targetObject.needsUpdate = !0;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
      const n = this.resolvedProperty;
      for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
      this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_arrayElement(t, e) {
      this.resolvedProperty[this.propertyIndex] = t[e];
    }
    _setValue_arrayElement_setNeedsUpdate(t, e) {
      (this.resolvedProperty[this.propertyIndex] = t[e]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
      (this.resolvedProperty[this.propertyIndex] = t[e]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_fromArray(t, e) {
      this.resolvedProperty.fromArray(t, e);
    }
    _setValue_fromArray_setNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
      this.resolvedProperty.fromArray(t, e),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _getValue_unbound(t, e) {
      this.bind(), this.getValue(t, e);
    }
    _setValue_unbound(t, e) {
      this.bind(), this.setValue(t, e);
    }
    bind() {
      let t = this.node;
      const e = this.parsedPath,
        n = e.objectName,
        i = e.propertyName;
      let r = e.propertyIndex;
      if (
        (t || ((t = Bg.findNode(this.rootNode, e.nodeName)), (this.node = t)),
        (this.getValue = this._getValue_unavailable),
        (this.setValue = this._setValue_unavailable),
        !t)
      )
        return void console.warn(
          "THREE.PropertyBinding: No target node found for track: " +
            this.path +
            "."
        );
      if (n) {
        let i = e.objectIndex;
        switch (n) {
          case "materials":
            if (!t.material)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this
              );
            if (!t.material.materials)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                this
              );
            t = t.material.materials;
            break;
          case "bones":
            if (!t.skeleton)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                this
              );
            t = t.skeleton.bones;
            for (let e = 0; e < t.length; e++)
              if (t[e].name === i) {
                i = e;
                break;
              }
            break;
          case "map":
            if ("map" in t) {
              t = t.map;
              break;
            }
            if (!t.material)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this
              );
            if (!t.material.map)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                this
              );
            t = t.material.map;
            break;
          default:
            if (void 0 === t[n])
              return void console.error(
                "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                this
              );
            t = t[n];
        }
        if (void 0 !== i) {
          if (void 0 === t[i])
            return void console.error(
              "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
              this,
              t
            );
          t = t[i];
        }
      }
      const s = t[i];
      if (void 0 === s) {
        const n = e.nodeName;
        return void console.error(
          "THREE.PropertyBinding: Trying to update property for track: " +
            n +
            "." +
            i +
            " but it wasn't found.",
          t
        );
      }
      let a = this.Versioning.None;
      (this.targetObject = t),
        void 0 !== t.needsUpdate
          ? (a = this.Versioning.NeedsUpdate)
          : void 0 !== t.matrixWorldNeedsUpdate &&
            (a = this.Versioning.MatrixWorldNeedsUpdate);
      let o = this.BindingType.Direct;
      if (void 0 !== r) {
        if ("morphTargetInfluences" === i) {
          if (!t.geometry)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
              this
            );
          if (!t.geometry.morphAttributes)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
              this
            );
          void 0 !== t.morphTargetDictionary[r] &&
            (r = t.morphTargetDictionary[r]);
        }
        (o = this.BindingType.ArrayElement),
          (this.resolvedProperty = s),
          (this.propertyIndex = r);
      } else
        void 0 !== s.fromArray && void 0 !== s.toArray
          ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
          : Array.isArray(s)
          ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = s))
          : (this.propertyName = i);
      (this.getValue = this.GetterByBindingType[o]),
        (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
    }
    unbind() {
      (this.node = null),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
  }
  (Bg.Composite = class {
    constructor(t, e, n) {
      const i = n || Bg.parseTrackName(e);
      (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
    }
    getValue(t, e) {
      this.bind();
      const n = this._targetGroup.nCachedObjects_,
        i = this._bindings[n];
      void 0 !== i && i.getValue(t, e);
    }
    setValue(t, e) {
      const n = this._bindings;
      for (
        let i = this._targetGroup.nCachedObjects_, r = n.length;
        i !== r;
        ++i
      )
        n[i].setValue(t, e);
    }
    bind() {
      const t = this._bindings;
      for (
        let e = this._targetGroup.nCachedObjects_, n = t.length;
        e !== n;
        ++e
      )
        t[e].bind();
    }
    unbind() {
      const t = this._bindings;
      for (
        let e = this._targetGroup.nCachedObjects_, n = t.length;
        e !== n;
        ++e
      )
        t[e].unbind();
    }
  }),
    (Bg.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3,
    }),
    (Bg.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2,
    }),
    (Bg.prototype.GetterByBindingType = [
      Bg.prototype._getValue_direct,
      Bg.prototype._getValue_array,
      Bg.prototype._getValue_arrayElement,
      Bg.prototype._getValue_toArray,
    ]),
    (Bg.prototype.SetterByBindingTypeAndVersioning = [
      [
        Bg.prototype._setValue_direct,
        Bg.prototype._setValue_direct_setNeedsUpdate,
        Bg.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
      ],
      [
        Bg.prototype._setValue_array,
        Bg.prototype._setValue_array_setNeedsUpdate,
        Bg.prototype._setValue_array_setMatrixWorldNeedsUpdate,
      ],
      [
        Bg.prototype._setValue_arrayElement,
        Bg.prototype._setValue_arrayElement_setNeedsUpdate,
        Bg.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
      ],
      [
        Bg.prototype._setValue_fromArray,
        Bg.prototype._setValue_fromArray_setNeedsUpdate,
        Bg.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
      ],
    ]),
    new Float32Array(1),
    "undefined" != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("register", { detail: { revision: jl } })
      ),
    "undefined" != typeof window &&
      (window.__THREE__
        ? console.warn(
            "WARNING: Multiple instances of Three.js being imported."
          )
        : (window.__THREE__ = jl));
  const zg = Math.PI / 180,
    kg = 180 / Math.PI;
  const Vg = {
    name: "CopyShader",
    uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
    vertexShader:
      "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader:
      "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}",
  };
  class Hg {
    constructor() {
      (this.isPass = !0),
        (this.enabled = !0),
        (this.needsSwap = !0),
        (this.clear = !1),
        (this.renderToScreen = !1);
    }
    setSize() {}
    render() {
      console.error(
        "THREE.Pass: .render() must be implemented in derived pass."
      );
    }
    dispose() {}
  }
  const Gg = new qp(-1, 1, 1, -1, 0, 1),
    Wg = new (class extends Gd {
      constructor() {
        super(),
          this.setAttribute(
            "position",
            new Nd([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)
          ),
          this.setAttribute("uv", new Nd([0, 2, 0, 0, 2, 0], 2));
      }
    })();
  class Xg {
    constructor(t) {
      this._mesh = new op(Wg, t);
    }
    dispose() {
      this._mesh.geometry.dispose();
    }
    render(t) {
      t.render(this._mesh, Gg);
    }
    get material() {
      return this._mesh.material;
    }
    set material(t) {
      this._mesh.material = t;
    }
  }
  class qg extends Hg {
    constructor(t, e) {
      super(),
        (this.textureID = void 0 !== e ? e : "tDiffuse"),
        t instanceof fp
          ? ((this.uniforms = t.uniforms), (this.material = t))
          : t &&
            ((this.uniforms = pp.clone(t.uniforms)),
            (this.material = new fp({
              name: void 0 !== t.name ? t.name : "unspecified",
              defines: Object.assign({}, t.defines),
              uniforms: this.uniforms,
              vertexShader: t.vertexShader,
              fragmentShader: t.fragmentShader,
            }))),
        (this.fsQuad = new Xg(this.material));
    }
    render(t, e, n) {
      this.uniforms[this.textureID] &&
        (this.uniforms[this.textureID].value = n.texture),
        (this.fsQuad.material = this.material),
        this.renderToScreen
          ? (t.setRenderTarget(null), this.fsQuad.render(t))
          : (t.setRenderTarget(e),
            this.clear &&
              t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
            this.fsQuad.render(t));
    }
    dispose() {
      this.material.dispose(), this.fsQuad.dispose();
    }
  }
  class jg extends Hg {
    constructor(t, e) {
      super(),
        (this.scene = t),
        (this.camera = e),
        (this.clear = !0),
        (this.needsSwap = !1),
        (this.inverse = !1);
    }
    render(t, e, n) {
      const i = t.getContext(),
        r = t.state;
      let s, a;
      r.buffers.color.setMask(!1),
        r.buffers.depth.setMask(!1),
        r.buffers.color.setLocked(!0),
        r.buffers.depth.setLocked(!0),
        this.inverse ? ((s = 0), (a = 1)) : ((s = 1), (a = 0)),
        r.buffers.stencil.setTest(!0),
        r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE),
        r.buffers.stencil.setFunc(i.ALWAYS, s, 4294967295),
        r.buffers.stencil.setClear(a),
        r.buffers.stencil.setLocked(!0),
        t.setRenderTarget(n),
        this.clear && t.clear(),
        t.render(this.scene, this.camera),
        t.setRenderTarget(e),
        this.clear && t.clear(),
        t.render(this.scene, this.camera),
        r.buffers.color.setLocked(!1),
        r.buffers.depth.setLocked(!1),
        r.buffers.color.setMask(!0),
        r.buffers.depth.setMask(!0),
        r.buffers.stencil.setLocked(!1),
        r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295),
        r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP),
        r.buffers.stencil.setLocked(!0);
    }
  }
  class Yg extends Hg {
    constructor() {
      super(), (this.needsSwap = !1);
    }
    render(t) {
      t.state.buffers.stencil.setLocked(!1),
        t.state.buffers.stencil.setTest(!1);
    }
  }
  class Kg {
    constructor(t, e) {
      if (
        ((this.renderer = t),
        (this._pixelRatio = t.getPixelRatio()),
        void 0 === e)
      ) {
        const n = t.getSize(new Iu());
        (this._width = n.width),
          (this._height = n.height),
          ((e = new nh(
            this._width * this._pixelRatio,
            this._height * this._pixelRatio,
            { type: Wc }
          )).texture.name = "EffectComposer.rt1");
      } else (this._width = e.width), (this._height = e.height);
      (this.renderTarget1 = e),
        (this.renderTarget2 = e.clone()),
        (this.renderTarget2.texture.name = "EffectComposer.rt2"),
        (this.writeBuffer = this.renderTarget1),
        (this.readBuffer = this.renderTarget2),
        (this.renderToScreen = !0),
        (this.passes = []),
        (this.copyPass = new qg(Vg)),
        (this.copyPass.material.blending = 0),
        (this.clock = new Rg());
    }
    swapBuffers() {
      const t = this.readBuffer;
      (this.readBuffer = this.writeBuffer), (this.writeBuffer = t);
    }
    addPass(t) {
      this.passes.push(t),
        t.setSize(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio
        );
    }
    insertPass(t, e) {
      this.passes.splice(e, 0, t),
        t.setSize(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio
        );
    }
    removePass(t) {
      const e = this.passes.indexOf(t);
      -1 !== e && this.passes.splice(e, 1);
    }
    isLastEnabledPass(t) {
      for (let e = t + 1; e < this.passes.length; e++)
        if (this.passes[e].enabled) return !1;
      return !0;
    }
    render(t) {
      void 0 === t && (t = this.clock.getDelta());
      const e = this.renderer.getRenderTarget();
      let n = !1;
      for (let e = 0, i = this.passes.length; e < i; e++) {
        const i = this.passes[e];
        if (!1 !== i.enabled) {
          if (
            ((i.renderToScreen =
              this.renderToScreen && this.isLastEnabledPass(e)),
            i.render(this.renderer, this.writeBuffer, this.readBuffer, t, n),
            i.needsSwap)
          ) {
            if (n) {
              const e = this.renderer.getContext(),
                n = this.renderer.state.buffers.stencil;
              n.setFunc(e.NOTEQUAL, 1, 4294967295),
                this.copyPass.render(
                  this.renderer,
                  this.writeBuffer,
                  this.readBuffer,
                  t
                ),
                n.setFunc(e.EQUAL, 1, 4294967295);
            }
            this.swapBuffers();
          }
          void 0 !== jg &&
            (i instanceof jg ? (n = !0) : i instanceof Yg && (n = !1));
        }
      }
      this.renderer.setRenderTarget(e);
    }
    reset(t) {
      if (void 0 === t) {
        const e = this.renderer.getSize(new Iu());
        (this._pixelRatio = this.renderer.getPixelRatio()),
          (this._width = e.width),
          (this._height = e.height),
          (t = this.renderTarget1.clone()).setSize(
            this._width * this._pixelRatio,
            this._height * this._pixelRatio
          );
      }
      this.renderTarget1.dispose(),
        this.renderTarget2.dispose(),
        (this.renderTarget1 = t),
        (this.renderTarget2 = t.clone()),
        (this.writeBuffer = this.renderTarget1),
        (this.readBuffer = this.renderTarget2);
    }
    setSize(t, e) {
      (this._width = t), (this._height = e);
      const n = this._width * this._pixelRatio,
        i = this._height * this._pixelRatio;
      this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
      for (let t = 0; t < this.passes.length; t++) this.passes[t].setSize(n, i);
    }
    setPixelRatio(t) {
      (this._pixelRatio = t), this.setSize(this._width, this._height);
    }
    dispose() {
      this.renderTarget1.dispose(),
        this.renderTarget2.dispose(),
        this.copyPass.dispose();
    }
  }
  class Zg extends Hg {
    constructor(t, e, n = null, i = null, r = null) {
      super(),
        (this.scene = t),
        (this.camera = e),
        (this.overrideMaterial = n),
        (this.clearColor = i),
        (this.clearAlpha = r),
        (this.clear = !0),
        (this.clearDepth = !1),
        (this.needsSwap = !1),
        (this._oldClearColor = new bd());
    }
    render(t, e, n) {
      const i = t.autoClear;
      let r, s;
      (t.autoClear = !1),
        null !== this.overrideMaterial &&
          ((s = this.scene.overrideMaterial),
          (this.scene.overrideMaterial = this.overrideMaterial)),
        null !== this.clearColor &&
          (t.getClearColor(this._oldClearColor),
          t.setClearColor(this.clearColor)),
        null !== this.clearAlpha &&
          ((r = t.getClearAlpha()), t.setClearAlpha(this.clearAlpha)),
        1 == this.clearDepth && t.clearDepth(),
        t.setRenderTarget(this.renderToScreen ? null : n),
        !0 === this.clear &&
          t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
        t.render(this.scene, this.camera),
        null !== this.clearColor && t.setClearColor(this._oldClearColor),
        null !== this.clearAlpha && t.setClearAlpha(r),
        null !== this.overrideMaterial && (this.scene.overrideMaterial = s),
        (t.autoClear = i);
    }
  }
  const Jg = {
      uniforms: {
        tDiffuse: { type: "t", value: null },
        time: { type: "f", value: 0 },
        distortion: { type: "f", value: 3 },
        distortion2: { type: "f", value: 5 },
        speed: { type: "f", value: 0.2 },
        rollSpeed: { type: "f", value: 0.1 },
      },
      vertexShader: [
        "varying vec2 vUv;",
        "void main() {",
        "vUv = uv;",
        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
        "}",
      ].join("\n"),
      fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "uniform float time;",
        "uniform float distortion;",
        "uniform float distortion2;",
        "uniform float speed;",
        "uniform float rollSpeed;",
        "varying vec2 vUv;",
        "vec3 mod289(vec3 x) {",
        "  return x - floor(x * (1.0 / 289.0)) * 289.0;",
        "}",
        "vec2 mod289(vec2 x) {",
        "  return x - floor(x * (1.0 / 289.0)) * 289.0;",
        "}",
        "vec3 permute(vec3 x) {",
        "  return mod289(((x*34.0)+1.0)*x);",
        "}",
        "float snoise(vec2 v)",
        "  {",
        "  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0",
        "                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)",
        "                     -0.577350269189626,  // -1.0 + 2.0 * C.x",
        "                      0.024390243902439); // 1.0 / 41.0",
        "  vec2 i  = floor(v + dot(v, C.yy) );",
        "  vec2 x0 = v -   i + dot(i, C.xx);",
        "  vec2 i1;",
        "  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);",
        "  vec4 x12 = x0.xyxy + C.xxzz;",
        " x12.xy -= i1;",
        "  i = mod289(i); // Avoid truncation effects in permutation",
        "  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))",
        "\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));",
        "  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);",
        "  m = m*m ;",
        "  m = m*m ;",
        "  vec3 x = 2.0 * fract(p * C.www) - 1.0;",
        "  vec3 h = abs(x) - 0.5;",
        "  vec3 ox = floor(x + 0.5);",
        "  vec3 a0 = x - ox;",
        "  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );",
        "  vec3 g;",
        "  g.x  = a0.x  * x0.x  + h.x  * x0.y;",
        "  g.yz = a0.yz * x12.xz + h.yz * x12.yw;",
        "  return 130.0 * dot(m, g);",
        "}",
        "void main() {",
        "vec2 p = vUv;",
        "p -= vec2(0.5);",
        "p *= 1. - (distortion * 0.03);",
        "p += vec2(0.5);",
        "float ty = time*speed;",
        "float yt = p.y - ty;",
        "float offset = snoise(vec2(yt*3.0,0.0))*0.2;",
        "offset = offset * distortion * offset * distortion * offset;",
        "offset += snoise(vec2(yt*50.0,0.0))*distortion2*0.001;",
        "gl_FragColor = texture2D(tDiffuse, vec2(fract(p.x + offset), fract(p.y+ offset)));",
        "}",
      ].join("\n"),
    },
    $g = {
      uniforms: {
        tDiffuse: { type: "t", value: null },
        time: { type: "f", value: 0 },
        amount: { type: "f", value: 0.5 },
        size: { type: "f", value: 4 },
      },
      vertexShader: [
        "varying vec2 vUv;",
        "void main() {",
        "vUv = uv;",
        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
        "}",
      ].join("\n"),
      fragmentShader: [
        "uniform sampler2D tDiffuse;",
        "uniform float time;",
        "uniform float amount;",
        "uniform float size;",
        "varying vec2 vUv;",
        "float rand(vec2 co){",
        "return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);",
        "}",
        "void main() {",
        "vec2 p = vUv;",
        "vec4 color = texture2D(tDiffuse, p);",
        "float xs = floor(gl_FragCoord.x / size);",
        "float ys = floor(gl_FragCoord.y / size);",
        "vec4 snow = vec4(rand(vec2(xs * time,ys * time))*amount);",
        "gl_FragColor = color+ snow;",
        "}",
      ].join("\n"),
    };
  new (class extends e {
    constructor(e) {
      super(),
        (this.options = t({ init: !0, define: null, waitFullLoad: !0 }, e)),
        (this.store = new Map()),
        (this.registry = new Map()),
        this.options.define &&
          (this.defineAll(this.options.define),
          this.options.init && this.init());
    }
    init() {
      try {
        const t = this,
          e = (function () {
            if (
              "interactive" === document.readyState ||
              "complete" === document.readyState
            )
              return Promise.resolve(t.start()).then(function () {});
            document.addEventListener("DOMContentLoaded", () => t.start(), {
              once: !0,
            });
          })();
        return Promise.resolve(e && e.then ? e.then(function () {}) : void 0);
      } catch (t) {
        return Promise.reject(t);
      }
    }
    start() {
      try {
        const t = this;
        function e() {
          return Promise.resolve(t.executeAll("init")).then(function () {
            return Promise.resolve(t.executeAll("enter")).then(function () {
              return Promise.resolve(t.executeAll("complete")).then(
                function () {}
              );
            });
          });
        }
        t.registry.forEach((e, n) => {
          e.assign
            ? t.queryAll(e.assign).forEach((e) => {
                t.attach(n, e, null, !1);
              })
            : t.attach(n, null, null, !1);
        });
        const n = (function () {
          if (t.options.waitFullLoad)
            return Promise.resolve(t.waitFullLoad()).then(function () {});
        })();
        return Promise.resolve(n && n.then ? n.then(e) : e());
      } catch (i) {
        return Promise.reject(i);
      }
    }
    refresh(t, e, n) {
      void 0 === t && (t = !0),
        void 0 === e && (e = !0),
        void 0 === n && (n = !0);
      try {
        const i = this,
          r = [];
        return (
          i.registry.forEach((s, a) => {
            const o = i.store.get(a);
            o &&
              o.forEach((o, l) => {
                s.assign
                  ? n && o.el && !o.el.isConnected && r.push(i.detach(a, l, e))
                  : t && r.push(i.executeInstance(o, "refresh"));
              }),
              s.assign &&
                i.queryAll(s.assign).forEach((e) => {
                  const n = o && o.filter((t) => t.el && e.isSameNode(t.el))[0];
                  n
                    ? t && r.push(i.executeInstance(n, "refresh"))
                    : r.push(i.attach(a, e));
                });
          }),
          t && i.trigger("refresh"),
          Promise.all(r)
        );
      } catch (t) {
        return Promise.reject(t);
      }
    }
    executeAll(t) {
      void 0 === t && (t = "init");
      try {
        const e = this,
          n = [];
        return (
          e.trigger(t),
          e.store.forEach((i) => {
            i.forEach((i) => n.push(e.executeInstance(i, t)));
          }),
          Promise.all(n)
        );
      } catch (t) {
        return Promise.reject(t);
      }
    }
    executeInstance(t, e) {
      void 0 === e && (e = "init");
      try {
        const n = "on" + e.charAt(0).toUpperCase() + e.slice(1);
        return t[n]
          ? Promise.resolve((t._executors[e] = t[n]()))
          : Promise.resolve();
      } catch (t) {
        return Promise.reject(t);
      }
    }
    wait(t, e, n) {
      void 0 === e && (e = "init"), void 0 === n && (n = 0);
      try {
        const i = this;
        return Promise.resolve(i.waitInstance(i.get(t, n), e));
      } catch (t) {
        return Promise.reject(t);
      }
    }
    waitAll(t, e) {
      void 0 === e && (e = "init");
      try {
        const t = this,
          n = [];
        return (
          t.store.forEach((i) => {
            i.forEach((i) => n.push(t.waitInstance(i, e)));
          }),
          Promise.all(n)
        );
      } catch (t) {
        return Promise.reject(t);
      }
    }
    waitInstance(t, e) {
      void 0 === e && (e = "init");
      try {
        return Promise.resolve(t._executors[e]);
      } catch (t) {
        return Promise.reject(t);
      }
    }
    waitFullLoad() {
      try {
        return Promise.resolve(
          new Promise((t) => {
            "complete" === document.readyState
              ? t()
              : window.addEventListener("load", () => t());
          })
        );
      } catch (t) {
        return Promise.reject(t);
      }
    }
    attach(t, e, n, i) {
      void 0 === i && (i = !0);
      try {
        const r = this,
          s = n || r.registry.get(t).options,
          a = new (0, r.registry.get(t).component)(r, e, s);
        r.store.has(t) || r.store.set(t, []),
          r.store.get(t).push(a),
          (a._namespace = t);
        const o = (function () {
          if (i)
            return Promise.resolve(r.executeInstance(a, "init")).then(
              function () {}
            );
        })();
        return Promise.resolve(
          o && o.then
            ? o.then(function () {
                return a;
              })
            : a
        );
      } catch (t) {
        return Promise.reject(t);
      }
    }
    detach(t, e, n) {
      void 0 === e && (e = 0), void 0 === n && (n = !0);
      try {
        const i = this,
          r = i.store.get(t).splice(e, 1)[0],
          s = (function () {
            if (n)
              return Promise.resolve(i.executeInstance(r, "destroy")).then(
                function () {}
              );
          })();
        return Promise.resolve(
          s && s.then
            ? s.then(function () {
                return r;
              })
            : r
        );
      } catch (t) {
        return Promise.reject(t);
      }
    }
    define(t, e, n, i) {
      this.registry.set(t, { assign: n, component: e, options: i });
    }
    defineAll(t) {
      t.forEach((t) => {
        this.define(t.namespace, t.component, t.assign, t.options);
      });
    }
    get(t, e) {
      void 0 === e && (e = 0);
      const n = this.store.get(t);
      return n ? n[e] : null;
    }
    getAll(t) {
      return this.store.get(t);
    }
    find(t, e, n) {
      void 0 === n && (n = 0);
      const i = this.findAll(t, e);
      return i ? i[n] : null;
    }
    findAll(t, e) {
      const n = e ? [this.store.get(e) || []] : this.store,
        i = [];
      return (
        n.forEach((e) => {
          i.push(
            ...e.filter(
              (e) =>
                e.el && ("string" == typeof t ? e.el.matches(t) : e.el === t)
            )
          );
        }),
        i
      );
    }
    query(t) {
      return "string" == typeof t
        ? document.querySelector(t)
        : "object" == typeof t
        ? t
        : null;
    }
    queryAll(t) {
      return "string" == typeof t
        ? Array.from(document.querySelectorAll(t))
        : "object" == typeof t
        ? t
        : [];
    }
  })({
    define: [
      {
        namespace: "layout",
        component: class extends n {
       
          onEnter() {
            try {
              return to.refresh(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }
          onComplete() {
            try {
              return this.loadLazyImages(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }
          onLeave() {
            try {
              
            } catch (t) {
              return Promise.reject(t);
            }
          }
          onRefresh() {
            try {
              return (
                this.flushLenis(),
                to.clearMatchMedia(),
                to.killAll(),
                Promise.resolve()
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }
     
          flushLenis() {
            this.lenis && (this.lenis.stop(), this.lenis.start());
          }
   
          loadLazyImages() {
            this.app
              .queryAll("img[loading=lazy]")
              .forEach((t) => t.setAttribute("loading", "eager"));
          }
        },
      },
      {
        namespace: "cursor",
        component: class extends n {
          constructor() {
            super(...arguments), this.initFollower();
          }
          initFollower() {
            window.matchMedia("(pointer:fine)").matches &&
              (this.follower = new Fo({
                className: "cw-cursor-craftwaves",
                innerClassName: "cw-cursor-inner-craftwaves",
                textClassName: "cw-cursor-text-craftwaves",
                mediaClassName: "cw-cursor-media-craftwaves",
                mediaBoxClassName: "cw-cursor-media-box-craftwaves",
                iconSvgClassName: "cw-svgsprite-craftwaves",
                iconSvgSrc: "/assets/img/sprites/svgsprites.svg",
                skewing: 1.5,
                skewingMedia: 1.5,
              }));
          }
        },
      },
      {
        namespace: "loader",
        assign: ".cw-loader-craftwaves",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.fill = this.el.querySelectorAll(".cw-loader_overlay-fill-craftwaves")),
              (this.word = this.el.querySelectorAll(".cw-loader_overlay-word-craftwaves")),
              (this.wordSpan = this.el.querySelectorAll(
                ".cw-loader_overlay-word-craftwaves span"
              )),
              (this.percent = this.el.querySelector(
                ".cw-loader_overlay-percent-craftwaves"
              )),
              (this.percentSpan = this.el.querySelector(
                ".cw-loader_overlay-percent-craftwaves span"
              )),
              (this.loaded = !1),
              (this.hideTl = this.tlHide()),
              (this.showTl = this.tlShow()),
              (this.movementTl = this.tlMovement()),
              this.reset();
          }
          onInit() {
            try {
              const t = this;
              return Promise.resolve(document.fonts.ready).then(function () {
                return Promise.resolve(t.show()).then(function () {});
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }
          onEnter() {
            try {
              const t = this;
              return (
                (t.loaded = !0),
                Promise.resolve(new Promise((e) => (t.enterResolver = e))).then(
                  function () {}
                )
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }
          onLeave() {
            try {
              return this.show(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }
          show() {
            try {
              const t = this;
              return (
                document.documentElement.classList.add("loader"),
                Promise.resolve(t.showTl.play(0)).then(function () {})
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }
          hide() {
            try {
              const t = this;
              return (
                document.documentElement.classList.remove("loader"),
                t.showTl.pause(),
                t.movementTl.pause(),
                Promise.resolve(t.hideTl.play(0)).then(function () {})
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }
          add(t) {
            void 0 === t && (t = 1), (this.count.total = this.count.total + t);
          }
          tick() {
            this.count.current++,
              (this.count.progress = this.count.current / this.count.total),
              (this.count.percent = 100 * this.count.progress),
              this.count.percent > this.count.percentLast &&
                this.val(this.count.percent);
          }
          reset() {
            (this.count = {
              total: 0,
              current: 0,
              progress: 0,
              percent: 0,
              percentLast: 0,
            }),
              this.val(0);
          }
          val(t) {
            this.percentSpan.innerHTML = Math.floor(t) + "%";
          }
          hideIfLoaded() {
            this.loaded && this.hide();
          }
          tlShow() {
            const t = new Yi.timeline({ paused: !0 });
            return (
              t.fromTo(
                [this.wordSpan, this.percentSpan],
                { y: "105%" },
                { y: "0%", duration: 1.8, stagger: 0.15, ease: "expo.out" }
              ),
              t.add(() => {
                this.loaded
                  ? t.add(() => this.hide(), "-=0.7")
                  : this.movementTl.play();
              }, "-=1"),
              t
            );
          }
          tlHide() {
            const t = new Yi.timeline({ paused: !0 });
            return (
              t.fromTo(
                [this.wordSpan, this.percentSpan],
                { y: "0%" },
                { y: "-105%", duration: 1.8, stagger: 0.07, ease: "expo.inOut" }
              ),
              t.to(this.fill, { opacity: 0 }, 0.7),
              t.add(() => this.enterResolver(), 1.1),
              t.set(this.el, { pointerEvents: "none" }, 1),
              t.set(this.el, { display: "none" }),
              t
            );
          }
          tlMovement() {
            const t = new Yi.timeline({ repeat: -1, paused: !0 });
            return (
              t.to(
                this.word[0],
                { x: "0%", duration: 1.8, ease: "expo.out" },
                0
              ),
              t.to(
                this.word[1],
                { x: "25%", duration: 2, ease: "expo.out" },
                "-=1.8"
              ),
              t.add(() => this.hideIfLoaded(), "-=0.8"),
              t.to(
                this.word[0],
                { y: "100%", duration: 1.8, ease: "expo.out" },
                "-=0.8"
              ),
              t.add(() => this.hideIfLoaded(), "-=0.9"),
              t.to(
                this.word[0],
                { x: "25%", duration: 1.8, ease: "expo.out" },
                "-=0.7"
              ),
              t.to(
                this.word[1],
                { x: "48%", duration: 1.8, ease: "expo.out" },
                "-=2"
              ),
              t.to(
                this.word[2],
                { x: "0%", duration: 1.8, ease: "expo.out" },
                "-=1.8"
              ),
              t.to(
                this.word[3],
                { x: "8%", duration: 1.8, ease: "expo.out" },
                "-=1.4"
              ),
              t.add(() => this.hideIfLoaded(), "-=0.8"),
              t.to(
                this.word[0],
                { x: "0%", duration: 1.8, ease: "expo.out" },
                "-=0.7"
              ),
              t.to(
                this.word[1],
                { x: "25%", duration: 1.8, ease: "expo.out" },
                "-=1.6"
              ),
              t.to(
                this.word[2],
                { x: "20%", duration: 1.8, ease: "expo.out" },
                "-=1.8"
              ),
              t.to(
                this.word[3],
                { x: "0%", duration: 1.8, ease: "expo.out" },
                "-=1.8"
              ),
              t.add(() => this.hideIfLoaded(), "-=0.8"),
              t.to(
                this.word[0],
                { y: "0%", duration: 1.8, ease: "expo.out" },
                "-=0.8"
              ),
              t.to(
                this.word[0],
                { x: "17%", duration: 1.8, ease: "expo.out" },
                "-=0.7"
              ),
              t.to(
                this.word[1],
                { x: "5%", duration: 1.8, ease: "expo.out" },
                "-=1.8"
              ),
              t.to(
                this.word[2],
                { x: "31%", duration: 1.8, ease: "expo.out" },
                "-=2"
              ),
              t.to(
                this.word[3],
                { x: "0%", duration: 1.8, ease: "expo.out" },
                "-=1.8"
              ),
              t.add(() => this.hideIfLoaded(), "-=0.8"),
              t
            );
          }
        },
      },
      {
        namespace: "divider",
        assign: ".cw-divider-craftwaves",
        component: class extends n {
          constructor() {
            super(...arguments),
              this.injectSvg(),
              this.bindMouseMove(),
              this.bindResizeObserver();
          }
          onInit() {
            try {
              return this.magicShow(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }
          magicShow() {
            to.create({ trigger: this.el, animation: this.tlShow() });
          }
          tlShow() {
            const t = new Yi.timeline();
            return (
              t.set(this.svg, { transformOrigin: "left center" }),
              t.from(this.svg, { scaleX: 0, duration: 3, ease: "expo.out" }),
              t
            );
          }
          getPathD(t, e, n) {
            return (
              t || (t = this.el.offsetWidth / 2),
              e || (e = 100),
              void 0 === n && (n = this.el.offsetWidth),
              "M0,100 Q" + t + "," + e + " " + n + ",100"
            );
          }
          injectSvg() {
            (this.el.innerHTML =
              "<svg><path d='" + this.getPathD() + "'/></svg>"),
              (this.svg = this.el.querySelector("svg")),
              (this.path = this.el.querySelector("path"));
          }
          update() {
            Yi.killTweensOf(this.path),
              this.path.setAttribute("d", this.getPathD());
          }
          bindMouseMove() {
            if (to.isTouch) return;
            let t = 0;
            this.el.addEventListener("mousemove", (e) => {
              const n = this.svg.getBoundingClientRect(),
                i = e.pageX - window.pageXOffset - n.left,
                r = e.pageY - window.pageYOffset - n.top;
              t || (t = r < 100 ? 50 : -50);
              const s = i,
                a = 2 * r - 100 + t;
              Yi.to(this.path, {
                attr: { d: this.getPathD(s, a) },
                duration: 0.2,
                overwrite: !0,
              });
            }),
              this.el.addEventListener("mouseleave", () => {
                (t = 0),
                  Yi.to(this.path, {
                    attr: { d: this.getPathD() },
                    duration: 2,
                    ease: "elastic.out(1, 0.2)",
                  });
              });
          }
          bindResizeObserver() {
            (this.updateDebounced = (function (t, e, n) {
              var i,
                r,
                s,
                a,
                o,
                l,
                c = 0,
                u = !1,
                h = !1,
                d = !0;
              if ("function" != typeof t)
                throw new TypeError("Expected a function");
              function p(e) {
                var n = i,
                  s = r;
                return (i = r = void 0), (c = e), (a = t.apply(s, n));
              }
              function f(t) {
                var n = t - l;
                return void 0 === l || n >= e || n < 0 || (h && t - c >= s);
              }
              function m() {
                var t = Vo();
                if (f(t)) return g(t);
                o = setTimeout(
                  m,
                  (function (t) {
                    var n = e - (t - l);
                    return h ? sl(n, s - (t - c)) : n;
                  })(t)
                );
              }
              function g(t) {
                return (o = void 0), d && i ? p(t) : ((i = r = void 0), a);
              }
              function v() {
                var t = Vo(),
                  n = f(t);
                if (((i = arguments), (r = this), (l = t), n)) {
                  if (void 0 === o)
                    return (function (t) {
                      return (c = t), (o = setTimeout(m, e)), u ? p(t) : a;
                    })(l);
                  if (h) return clearTimeout(o), (o = setTimeout(m, e)), p(l);
                }
                return void 0 === o && (o = setTimeout(m, e)), a;
              }
              return (
                (e = il(e) || 0),
                Oo(n) &&
                  ((u = !!n.leading),
                  (s = (h = "maxWait" in n) ? rl(il(n.maxWait) || 0, e) : s),
                  (d = "trailing" in n ? !!n.trailing : d)),
                (v.cancel = function () {
                  void 0 !== o && clearTimeout(o),
                    (c = 0),
                    (i = l = r = o = void 0);
                }),
                (v.flush = function () {
                  return void 0 === o ? a : g(Vo());
                }),
                v
              );
            })(this.update.bind(this), 30)),
              (this.resizeObserver = new ResizeObserver(() =>
                this.updateDebounced()
              )),
              this.resizeObserver.observe(this.el);
          }
        },
      },
      {
        namespace: "button",
        assign: ".cw-btn-craftwaves",
        component: class extends n {
          constructor() {
            super(...arguments), (this.layout = this.app.get("layout"));
          }
          bindModalOpen() {
            this.el.dataset.modalOpen &&
              this.el.addEventListener("click", (t) => {
                const e = this.app.find(this.el.dataset.modalOpen, "modal");
                e && (t.preventDefault(), t.stopPropagation(), e.open());
              });
          }
        
        },
      },
      {
        namespace: "navbar",
        assign: ".cw-navbar-craftwaves",
        component: class extends n {
          constructor() {
            super(...arguments);
          }
        },
      },
      {
        namespace: "menu",
        assign: ".cw-menu-craftwaves",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.opened = !1),
              (this.toggleBtn = this.el.querySelector(
                ".cw-menu-toggle-craftwaves button"
              )),
              (this.box = this.el.querySelector(".cw-menu-box-craftwaves")),
              (this.backdrop = this.el.querySelector(".cw-menu-backdrop-craftwaves")),
              (this.fill = this.el.querySelector(".cw-menu-fill-craftwaves")),
              (this.content = this.el.querySelector(".cw-menu-content-craftwaves"));
          }
          onInit() {
            try {
              const t = this;
              return (
                (t.tlClose = t.tlHide()),
                (t.tlOpen = t.tlShow()),
                t.bindToggle(),
                t.magicInverse(),
                Promise.resolve()
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }
          onLeave() {
            try {
              const t = this;
              return t.opened && t.hide(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }
          bindToggle() {
            this.toggleBtn.addEventListener("click", () => this.toggle()),
              this.backdrop.addEventListener("click", () => this.hide()),
              this.tlClose.eventCallback("onComplete", () => {
                this.box.classList.remove("-visible");
              }),
              this.el.addEventListener("mouseenter", () => {
                var t;
                this.el.classList.contains("-inverse") &&
                  (null == (t = this.app.get("cursor").follower) ||
                    t.addState("-inverse"));
              }),
              to.isTouch ||
                Rl(this.toggleBtn, {
                  leaveSpeed: 2,
                  leaveEase: "elastic.out(1,0.25)",
                });
          }
          toggle() {
            this.opened ? this.hide() : this.show();
          }
          show() {
            var t;
            (this.opened = !0),
              this.el.classList.add("-open"),
              document.documentElement.classList.add("menu-open"),
              this.tlClose.pause(),
              this.tlOpen.play(0),
              this.el.classList.contains("-inverse") &&
                (null == (t = this.app.get("cursor").follower) ||
                  t.removeState("-inverse"));
          }
          hide() {
            var t;
            (this.opened = !1),
              this.el.classList.remove("-open"),
              document.documentElement.classList.remove("menu-open"),
              this.tlOpen.pause(),
              this.tlClose.play(0),
              this.el.classList.contains("-inverse") &&
                (null == (t = this.app.get("cursor").follower) ||
                  t.addState("-inverse"));
          }
          tlShow() {
            const t = new Yi.timeline({ paused: !0 });
            return (
              t.set(this.box, { display: "block" }, 0),
              t.fromTo(
                this.backdrop,
                { opacity: 0 },
                { opacity: 1, duration: 0.5 },
                0
              ),
              t.fromTo(
                this.fill,
                { scaleX: 0 },
                { scaleX: 1, ease: "expo.out", duration: 1 },
                0
              ),
              t.fromTo(
                this.content,
                { xPercent: 50 },
                { xPercent: 0, ease: "expo.out", duration: 1 },
                0
              ),
              t.fromTo(
                this.content,
                { opacity: 0 },
                { opacity: 1, duration: 0.5 },
                0.15
              ),
              t
            );
          }
          tlHide() {
            const t = new Yi.timeline({ paused: !0 });
            return (
              t.fromTo(
                this.backdrop,
                { opacity: 1 },
                { opacity: 0, duration: 0.4 },
                0
              ),
              t.fromTo(
                this.fill,
                { scaleX: 1 },
                { scaleX: 0, duration: 0.4 },
                0
              ),
              t.fromTo(
                this.content,
                { xPercent: 0 },
                { xPercent: 20, duration: 0.4 },
                0
              ),
              t.fromTo(
                this.content,
                { opacity: 1 },
                { opacity: 0, duration: 0.1 },
                0
              ),
              t.set(this.box, { display: "none" }),
              t
            );
          }
          magicInverse() {
            document.querySelectorAll("[data-menu-inverse]").forEach((t) => {
              to.create({
                trigger: t,
                start: "top top+=50px",
                end: "bottom top+=70px",
                toggleClass: { targets: this.el, className: "-inverse" },
                refreshPriority: -99999,
              });
            });
          }
        },
      },
      {
        namespace: "video",
        assign: "video",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.video = this.el),
              (this.loader = this.app.get("loader")),
              (this.source = this.el.querySelectorAll("source"));
          }
          onInit() {
            try {
              const t = this;
              return Promise.resolve(t.app.waitInstance(t.loader)).then(
                function () {
                  return (
                    t.loader.add(),
                    Promise.resolve(t.startLoad()).then(function () {
                      t.loader.tick(), t.startObserver();
                    })
                  );
                }
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }
          startLoad() {
            try {
              const t = this;
              return t.el.dataset.src || t.source.length
                ? Promise.resolve(
                    new Promise((e) => {
                      const n = setTimeout(() => e(), 15e3);
                      t.el.addEventListener(
                        "suspend",
                        () => {
                          clearInterval(n), e();
                        },
                        { once: !0 }
                      ),
                        t.el.dataset.src && (t.el.src = t.el.dataset.src),
                        t.source.length > 0 &&
                          t.source.forEach((t) => {
                            t.src = t.dataset.src;
                          }),
                        t.el.load();
                    })
                  ).then(function () {})
                : Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }
          startObserver() {
            (this.observer = new IntersectionObserver((t) => {
              t.forEach((t) => {
                t.isIntersecting ? t.target.play() : t.target.pause();
              });
            })),
              this.observer.observe(this.el);
          }
        },
      },
      {
        namespace: "intouch",
        assign: ".cw-intouch-craftwaves",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.video = this.el.querySelector(".cw-intouch-video-craftwaves"));
          }
          onInit() {
            try {
              const t = this;
              return t.handleEnter(), t.initMagnetic(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }
          onEnter() {
            try {
              const t = this;
              return t.enterTl
                ? Promise.resolve(t.app.wait("loader", "enter")).then(
                    function () {
                      return Promise.resolve(t.enterTl.play()).then(
                        function () {}
                      );
                    }
                  )
                : Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }
          handleEnter() {
            this.el.offsetWidth && (this.enterTl = this.tlEnter());
          }
          tlEnter() {
            const t = new Yi.timeline({ paused: !0 });
            return (
              t.from(this.el, { scale: 0, duration: 2, ease: "expo.out" }), t
            );
          }
          initMagnetic() {
            to.isTouch ||
              Rl(this.video, {
                box: this.el,
                xDelta: 0.08,
                yDelta: 0.08,
                leaveSpeed: 2,
                leaveEase: "elastic.out(1,0.25)",
              });
          }
        },
      },
      {
        namespace: "intro",
        assign: ".cw-intro",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.header = this.el.querySelector(".cw-intro-header-craftwaves")),
              (this.details = this.el.querySelector(".cw-intro-details-craftwaves")),
              (this.detail = this.el.querySelectorAll(".cw-intro-detail-craftwaves")),
              (this.figure = this.el.querySelector(".cw-intro-figure-craftwaves")),
              (this.figureMedia = this.el.querySelector(
                ".cw-intro-figure-media"
              )),
              (this.bottom = this.el.querySelector(".cw-intro-bottom-craftwaves"));
          }
          onInit() {
            try {
              const t = this;
              return (t.enterTl = t.tlEnter()), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }
          onEnter() {
            try {
              const t = this;
              return Promise.resolve(t.app.wait("loader", "enter")).then(
                function () {
                  t.enterTl.play();
                }
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }
          tlEnter() {
            const t = new Yi.timeline({ paused: !0 }),
              e = this.header.querySelectorAll(".-word"),
              n = this.header.querySelector(".cw-btn_cta-craftwaves");
            return (
              Yi.set(e, { y: "110%" }),
              t.set([e, this.detail, this.figureMedia], {
                willChange: "transform",
              }),
              t.to(
                e,
                {
                  y: 0,
                  duration: 2,
                  stagger: 0.3,
                  ease: "expo.out",
                  force3D: !0,
                },
                0
              ),
              t.add(zl(n), 0.2),
              t.from(this.figureMedia, { opacity: 0, duration: 0.3 }, 0.8),
              t.from(
                this.figureMedia,
                { y: "40%", duration: 2, ease: "expo.out", force3D: !0 },
                0.8
              ),
              t.from(
                this.detail,
                { y: 30, duration: 2, stagger: 0.2, ease: "expo.out" },
                0.8
              ),
              t.from(
                this.detail,
                { opacity: 0, duration: 0.3, stagger: 0.2 },
                1
              ),
              t.set([e, this.detail, this.figureMedia], { willChange: "auto" }),
              t
            );
          }
       
       
          tlParallax() {
            const t = new Yi.timeline();
            return (
              t.set(this.figure, { willChange: "transform" }),
              t.to(this.figure, { y: "10%", duration: 1, ease: "none" }, 0),
              t.set(this.figure, { willChange: "auto" }),
              t
            );
          }
        },
      },
      {
        namespace: "focused",
        assign: ".cw-focused",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.text = this.el.querySelector(".cw-focused-text-craftwaves"));
          }
          onInit() {
            try {
              const t = this;
              return Promise.resolve(document.fonts.ready).then(function () {
                return Promise.resolve(t.app.wait("loader")).then(function () {
                  t.magicShow();
                });
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }
          magicShow() {
            this.text && Ll(this.text);
          }
        },
      },
      {
        namespace: "overview",
        assign: ".cw-overview",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.bg = this.el.querySelector(".cw-overview-bg-craftwaves")),
              (this.content = this.el.querySelector(".cw-overview-content-craftwaves")),
              (this.header = this.el.querySelector(".cw-overview-header-craftwaves")),
              (this.caption = this.el.querySelectorAll(".cw-overview-caption-craftwaves")),
              (this.icon = this.el.querySelector(".cw-overview-icon-craftwaves")),
              (this.text = this.el.querySelector(".cw-overview-text-craftwaves")),
              (this.tag = this.el.querySelectorAll(".cw-overview-tag-craftwaves")),
              (this.reel = this.el.querySelector(".cw-overview-reel-craftwaves")),
              (this.offset = this.el.querySelector(".cw-overview-offset-craftwaves")),
              (this.figure = this.el.querySelector(".cw-overview-figure-craftwaves")),
              (this.figureBg = this.el.querySelector(".cw-overview-figure-bg-craftwaves")),
              (this.figureMedia = this.el.querySelector(
                ".cw-overview-figure-media-craftwaves"
              )),
              (this.cursor = this.app.get("cursor")),
              (this.layout = this.app.get("layout"));
          }
          onInit() {
            try {
              const t = this;
              return Promise.resolve(document.fonts.ready).then(function () {
                return Promise.resolve(t.app.wait("loader")).then(function () {
                  t.initReeller(),
                    t.bindOffsetMouse(),
                    t.magicOffset(),
                    t.magicParallax(),
                    t.magicShow();
                });
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }
          initReeller() {
            this.reel &&
              (this.reeller = new Xl({
                container: this.reel,
                wrapper: ".cw-overview-reel-wrap-craftwaves",
                itemSelector: ".cw-overview-reel-item-craftwaves",
                speed: 10,
              
              }));
          }
          magicShow() {
            var t, e;
            if (
              (this.header &&
                Ll(this.header.firstElementChild, {
                  type: "lines",
                  stagger: 0.3,
                }),
              this.icon && Ul(this.icon),
              this.caption.length &&
                this.caption.forEach((t) => {
                  Ll(t, { stagger: 0.1 });
                }),
              this.text && Ll(this.text),
              this.tag.length &&
                ((t = this.tag),
                void 0 === e && (e = {}),
                to.create({ trigger: t, animation: Ol(t, e), once: !0 })),
              this.figure)
            ) {
              const t = Yi.matchMedia();
              t.add("(max-width:767px), (orientation:portrait)", () => {
                Fl(this.figure, this.figureMedia.querySelector("video"), {
                  innerFrom: 1.2,
                });
              }),
                t.add("(min-width:768px), (orientation:landscape)", () => {
                  this.figureBg &&
                    to.create({
                      trigger: this.figure,
                      animation: this.tlStretchFigure(),
                      invalidateOnRefresh: !0,
                      once: !0,
                    });
                });
            }
          }
          tlStretchFigure() {
            return Yi.fromTo(
              this.figureBg,
              { width: () => this.figure.offsetHeight },
              {
                width: () => this.figure.offsetWidth,
                duration: 3,
                ease: "expo.out",
                clearProps: "width",
              }
            );
          }
          magicParallax() {
            to.create({
              trigger: this.el,
              animation: this.tlParallax(),
              start: "top bottom",
              end: "bottom top",
              scrub: !0,
            });
          }
          tlParallax() {
            const t = new Yi.timeline();
            return (
              this.bg &&
                t.fromTo(
                  this.bg,
                  { yPercent: -30 },
                  { yPercent: 30, ease: "none" },
                  0
                ),
              t
            );
          }
          bindOffsetMouse() {
            to.isTouch ||
              window.addEventListener("mousemove", (t) => {
                if (!this.offseted || this.offsetStopped) return;
                const e = this.offset.getBoundingClientRect(),
                  n = this.figure.getBoundingClientRect(),
                  i = parseInt(window.getComputedStyle(this.figure).marginLeft),
                  r = t.clientY - e.top - n.height / 2,
                  s = t.clientX - e.left - n.width / 2 - i;
                Yi.to(this.figure, {
                  y: r,
                  x: s,
                  duration: 1.2,
                  ease: "expo.out",
                  overwrite: !0,
                });
              });
          }
          magicOffset() {
            this.offset &&
              this.figure &&
              (to.saveStyles([this.figure]),
              to.matchMedia({
                "(min-width:1024px)": () => {
                  to.create({
                    trigger: this.offset,
                    start: "top top",
                    endTrigger: this.el,
                    end: "bottom top",
                    pin: !0,
                    pinSpacing: !1,
                    onEnter: () => this.startOffset(),
                    onLeaveBack: () => this.revertOffset(),
                    onToggle: (t) => {
                      let { progress: e, direction: n, isActive: i } = t;
                      this.toggleOffset(!i);
                    },
                  });
                },
              }));
          }
          startOffset() {
            var t;
            (this.offseted = !0), this.figure.classList.add("-offsetted");
            const e =
              null == (t = this.cursor) || null == (t = t.follower)
                ? void 0
                : t.pos;
            if (
              (Yi.set(this.figure, { willChange: "transform" }),
              (null == e ? void 0 : e.y) > 0 && (null == e ? void 0 : e.x) > 0)
            ) {
              const t = this.offset.getBoundingClientRect(),
                n = this.figure.getBoundingClientRect(),
                i = parseInt(window.getComputedStyle(this.figure).marginLeft),
                r = e.y - t.top - n.height / 2,
                s = e.x - t.left - n.width / 2 - i;
              Yi.to(this.figure, {
                y: r,
                x: s,
                duration: 1.2,
                ease: "expo.out",
                overwrite: !0,
              });
            }
          }
          revertOffset() {
            (this.offseted = !1),
              this.figure.classList.remove("-offsetted"),
              Yi.set(this.figure, { willChange: "auto" }),
              Yi.to(this.figure, {
                y: 0,
                x: 0,
                duration: 2,
                ease: "expo.out",
                overwrite: !0,
              });
          }
          toggleOffset(t) {
            (this.offsetStopped = t),
              !this.offsetStopped && this.offseted && this.startOffset();
          }
        },
      },
      {
        namespace: "greeting",
        assign: ".cw-greeting-craftwaves",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.bg = this.el.querySelector(".cw-greeting-bg-craftwaves")),
              (this.bgMedia = this.bg.querySelector(".cw-greeting-bg-media-craftwaves")),
              (this.header = this.el.querySelector(".cw-greeting-header-craftwaves")),
              (this.text = this.el.querySelector(".cw-greeting-text-craftwaves"));
          }
          onInit() {
            try {
              const t = this;
              return Promise.resolve(t.app.wait("loader")).then(function () {
                t.magicParallax(), t.magicShow();
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }
          magicShow() {
            this.header &&
              Ll(this.header.firstElementChild, {
                type: "lines",
                stagger: 0.2,
              }),
              this.text && Ll(this.text);
          }
          magicParallax() {
            to.create({
              trigger: this.el,
              animation: this.tlParallax(),
              start: "top bottom",
              end: "bottom top",
              scrub: 2,
            });
          }
          tlParallax() {
            const t = new Yi.timeline();
            return (
              t.set(this.bgMedia, { willChange: "transform" }),
              t.to(this.bgMedia, { xPercent: -50, ease: "none" }),
              t.set(this.bgMedia, { willChange: "auto" }),
              t
            );
          }
        },
      },
      {
        namespace: "showcase",
        assign: ".cw-showcase-craftwaves",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.layout = this.app.get("layout")),
              (this.header = this.el.querySelector(".cw-showcase-header-craftwaves")),
              (this.item = this.el.querySelectorAll(".cw-showcase-item-craftwaves")),
              this.initItems();
          }
          onInit() {
            try {
              const t = this;
              return Promise.resolve(t.app.wait("loader")).then(function () {
                t.magicShow();
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }
          initItems() {
            (this.reellers = []),
              this.item.forEach((t, e) => {
                const n = t.querySelector(".cw-showcase-item-reel-craftwaves"),
                  i = new Xl({
                    container: n,
                    wrapper: ".cw-showcase-item-reel-wrap-craftwaves",
                    itemSelector: ".cw-showcase-item-reel-item-craftwaves",
                    speed: 10,
                  
                  });
                this.reellers.push(i), this.magicParallax(t);
              });
          }
          magicShow() {
            this.header &&
              Ll(this.header.firstElementChild, {
                type: "lines",
                stagger: 0.3,
              });
          }
          magicParallax(t) {
            to.create({
              trigger: t,
              animation: this.tlParallax(t),
              start: "top bottom",
              end: "bottom top",
              scrub: !0,
            });
          }
          tlParallax(t) {
            const e = new Yi.timeline(),
              n = t.querySelector(".cw-showcase-item-bg-craftwaves");
            return (
              e.set(n, { scale: 1.05, willChange: "transform" }),
              e.fromTo(n, { yPercent: -20 }, { yPercent: 20, ease: "none" }),
              e.set(n, { willChange: "auto" }),
              e
            );
          }
        },
      },
      {
        namespace: "brandreel",
        assign: ".cw-brandreel-craftwaves",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.layout = this.app.get("layout")),
              (this.figure = this.el.querySelector(".cw-brandreel-figure-craftwaves")),
              (this.text = this.el.querySelector(".cw-brandreel-text-craftwaves")),
              (this.reel = this.el.querySelectorAll(".cw-brandreel-reel-craftwaves"));
          }
          onInit() {
            try {
              const t = this;
              return t.initReellers(), t.magicShow(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }
          initReellers() {
            (this.reellers = []),
              this.reel.forEach((t, e) => {
                const n = new Xl({
                  container: t,
                  wrapper: ".cw-brandreel-reel-wrap-craftwaves",
                  itemSelector: ".cw-brandreel-reel-item-craftwaves",
                  speed: 20,
              
                });
                this.reellers.push(n);
              });
          }
          magicShow() {
            this.figure && Ul(this.figure, { duration: 3 }),
              this.text && Ll(this.text);
          }
        },
      },
      {
        namespace: "postcard",
        assign: ".cw-postcard-craftwaves",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.item = this.el.querySelectorAll(".cw-postcard-item-craftwaves")),
              this.bindOpen();
          }
          bindOpen() {
            const t = to.isTouch;
            this.item.forEach((e) => {
              if (t)
                e.addEventListener("click", () => {
                  e.classList.toggle("-open");
                });
              else {
                let t;
                e.addEventListener("mouseenter", () => {
                  clearInterval(t), e.classList.add("-open");
                }),
                  e.addEventListener("mouseleave", () => {
                    clearInterval(t),
                      (t = setTimeout(() => e.classList.remove("-open"), 1e3));
                  });
              }
            });
          }
        },
      },
      {
        namespace: "achievement",
        assign: ".cw-achievement-craftwaves",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.text = this.el.querySelector(".cw-achievement-text-craftwaves")),
              (this.items = this.el.querySelector(".cw-achievement-items-craftwaves")),
              (this.item = this.el.querySelectorAll(".cw-achievement-item-craftwaves"));
          }
          onInit() {
            try {
              const t = this;
              return Promise.resolve(document.fonts.ready).then(function () {
                t.magicShow(), t.magicShowItems();
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }
          magicShow() {
            this.text && Ll(this.text);
          }
          magicShowItems() {
            const t = Yi.matchMedia();
            t.add("(max-width:767px)", () => {
              this.item.forEach((t) => {
                const e = t.querySelector(".cw-achievement-item-bg-craftwaves"),
                  n = t.querySelector(".cw-achievement-item-figure-craftwaves"),
                  i = t.querySelector(".cw-achievement-item-title-craftwaves"),
                  r = t.querySelector(".cw-achievement-item-text-craftwaves");
                Fl(e, n), Ll(i), Ll(r);
              });
            }),
              t.add("(min-width:768px)", () => {
                this.item.forEach((t) => {
                  to.create({
                    trigger: t,
                    animation: this.tlStretchItem(t),
                    invalidateOnRefresh: !0,
                    once: !0,
                  });
                });
              });
          }
          tlStretchItem(t) {
            const e = new Yi.timeline(),
              n = t.querySelector(".cw-achievement-item-bg-craftwaves"),
              i = t.querySelector(".cw-achievement-item-figure-craftwaves"),
              r = t.querySelector(".cw-achievement-item-title-craftwaves"),
              s = t.querySelector(".cw-achievement-item-text-craftwaves");
            return (
              e.fromTo(
                i,
                { x: () => this.items.offsetWidth / 2 - i.offsetWidth / 2 },
                { x: 0, duration: 3, ease: "expo.out" },
                0
              ),
              e.fromTo(
                n,
                { width: () => t.offsetHeight },
                {
                  width: () => this.items.offsetWidth,
                  duration: 3,
                  ease: "expo.out",
                  clearProps: "width",
                },
                0
              ),
              e.add(Pl(r), 0.6),
              e.add(Pl(s), 0.8),
              e
            );
          }
        },
      },
      {
        namespace: "outro",
        assign: ".cw-outro",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.header = this.el.querySelector(".cw-outro-header-craftwaves")),
              (this.caption = this.el.querySelector(".cw-outro-caption-craftwaves")),
              (this.social = this.el.querySelectorAll(".cw-outro-social-craftwaves")),
              (this.location = this.el.querySelectorAll(".cw-outro-location-craftwaves")),
              this.initReeller();
          }
          onInit() {
            try {
              const t = this;
              return Promise.resolve(t.app.wait("loader")).then(function () {
                t.magicShow();
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }
          initReeller() {
            to.isTouch ||
              this.social.forEach((t) => {
                const e = t.querySelector(".cw-outro-social-reel-craftwaves"),
                  n = new Xl({
                    container: e,
                    wrapper: ".cw-outro-social-reel-wrap-craftwaves",
                    itemSelector: ".cw-outro-social-reel-item-craftwaves",
                    autoStop: !1,
                    speed: 3,
                  });
                t.addEventListener("mouseenter", () => n.reverse()),
                  t.addEventListener("mouseleave", () => n.pause());
              });
          }
          magicShow() {
            this.header &&
              Ll(this.header.firstElementChild, {
                type: "lines",
                stagger: 0.3,
              }),
              this.caption && Ll(this.caption, { stagger: 0.1 }),
              this.social.length &&
                this.social.forEach((t) => {
                  to.create({
                    trigger: t,
                    start: "center bottom",
                    animation: this.tlShowSocialItem(t),
                    once: !0,
                  });
                }),
              this.location.length &&
                this.location.forEach((t) => {
                  to.create({
                    trigger: t,
                    start: "center bottom",
                    animation: this.tlShowLocationItem(t),
                    once: !0,
                  });
                });
          }
          tlShowSocialItem(t) {
            const e = new Yi.timeline(),
              n = t.querySelector(".cw-outro-social-title-craftwaves"),
              i = t.querySelector(".cw-outro-social-divider-craftwaves"),
              r = t.querySelector(".cw-outro-social-arr-craftwaves");
            return (
              Yi.set(i, { scaleX: 0, transformOrigin: "left center" }),
              e.to(
                i,
                { scaleX: 1, duration: 3, stagger: 0.3, ease: "expo.out" },
                0
              ),
              e.add(Pl(n, { duration: 2.5 }), 0),
              e.add(Il(r), 0.5),
              e
            );
          }
         
        },
      },
      {
        namespace: "footer",
        assign: ".cw-footer",
        component: class extends n {
          constructor() {
            super(...arguments),
              (this.header = this.el.querySelector(".cw-footer-header-craftwaves")),
              (this.bgMedia = this.el.querySelector(".cw-footer-bg-media-craftwaves")),
              (this.bgVideo = this.bgMedia.querySelector("video")),
              (this.action = this.el.querySelector(".cw-footer-action-craftwaves")),
              (this.actionBtn = this.action.querySelector("a")),
              (this.tag = this.el.querySelectorAll(".cw-footer-tag-craftwaves")),
              (this.link = this.el.querySelectorAll(".cw-footer-link-craftwaves")),
              (this.sceneVisible = !1);
          }
          onInit() {
            try {
              const t = this;
              return Promise.resolve(t.loadScene()).then(function () {
                t.magicShow();
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }
          loadScene() {
            try {
              const t = this;
              return (
                to.isTouch ||
                  ((t.bgVideo.style.display = "none"),
                  t.bgVideo.pause(),
                  to.create({
                    trigger: t.el,
                    onToggle: (e) => {
                      let { progress: n, direction: i, isActive: r } = e;
                      (t.sceneVisible = r),
                        r ? t.bgVideo.play() : t.bgVideo.pause();
                    },
                  }),
                  (t.sceneTexture = new xg(t.bgVideo)),
                  (t.sceneTexture.minFilter = 1006),
                  (t.sceneTexture.magFilter = 1006),
                  (t.sceneMaterial = new Ad({ map: t.sceneTexture })),
                  (t.sceneGeometry = new Ip(1600, 900, 1, 1)),
                  (t.scenePlane = new op(t.sceneGeometry, t.sceneMaterial)),
                  (t.scenePlane.z = 0),
                  (t.sceneFov = 45),
                  (t.sceneCamera = new xp(
                    t.sceneFov,
                    t.bgMedia.offsetWidth / t.bgMedia.offsetHeight,
                    20,
                    3e3
                  )),
                  (t.sceneCamera.position.z = 1e3),
                  (t.sceneMain = new _g()),
                  t.sceneMain.add(t.scenePlane),
                  (t.sceneRenderer = new vg({
                    antialias: !1,
                    alpha: !1,
                    powerPreference: "high-performance",
                  })),
                  t.sceneRenderer.setSize(
                    t.bgMedia.offsetWidth,
                    t.bgMedia.offsetHeight
                  ),
                  t.bgMedia.appendChild(t.sceneRenderer.domElement),
                  (t.sceneComposer = new Kg(t.sceneRenderer)),
                  (t.sceneRenderPass = new Zg(t.sceneMain, t.sceneCamera)),
                  (t.sceneBadTVPass = new qg(Jg)),
                  (t.sceneStaticPass = new qg($g)),
                  t.sceneComposer.addPass(t.sceneRenderPass),
                  t.sceneComposer.addPass(t.sceneBadTVPass),
                  t.sceneComposer.addPass(t.sceneStaticPass),
                  (t.sceneBadTVPass.uniforms.distortion.value = 0),
                  (t.sceneBadTVPass.uniforms.distortion2.value = 0),
                  (t.sceneBadTVPass.uniforms.speed.value = 0.22),
                  (t.sceneBadTVPass.uniforms.rollSpeed.value = 0),
                  (t.sceneStaticPass.uniforms.amount.value = 0.03),
                  (t.sceneStaticPass.uniforms.size.value = 3),
                  Yi.ticker.add((e) => {
                    t.sceneVisible &&
                      (t.sceneComposer.render(0.1),
                      (t.sceneBadTVPass.uniforms.time.value = e),
                      (t.sceneStaticPass.uniforms.time.value = e));
                  }),
                  window.addEventListener("resize", () => {
                    setTimeout(() => {
                      if (
                        (t.sceneRenderer.setSize(
                          t.bgMedia.offsetWidth,
                          t.bgMedia.offsetHeight
                        ),
                        (t.sceneCamera.aspect =
                          t.bgMedia.offsetWidth / t.bgMedia.offsetHeight),
                        t.sceneCamera.updateProjectionMatrix(),
                        t.sceneCamera.aspect > 16 / 9)
                      ) {
                        const e = Math.tan((t.sceneFov / 2) * zg),
                          n = t.sceneCamera.aspect / (16 / 9);
                        t.sceneCamera.fov = 2 * (Math.atan(e / n) * kg);
                      } else t.sceneCamera.fov = t.sceneFov;
                    }, 1e3);
                  }),
                  t.actionBtn.addEventListener("mouseenter", () => {
                    Yi.to(t.sceneBadTVPass.uniforms.distortion, {
                      value: 5,
                      duration: 0.5,
                    }),
                      Yi.to(t.sceneStaticPass.uniforms.amount, {
                        value: 0.1,
                        duration: 0.5,
                      });
                  }),
                  t.actionBtn.addEventListener("mouseleave", () => {
                    Yi.to(t.sceneBadTVPass.uniforms.distortion, {
                      value: 0,
                      duration: 0.5,
                    }),
                      Yi.to(t.sceneStaticPass.uniforms.amount, {
                        value: 0.03,
                        duration: 0.5,
                      });
                  })),
                Promise.resolve()
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }
          magicShow() {
            var t, e;
            this.header &&
              Ll(this.header.firstElementChild, {
                type: "lines",
                stagger: 0.3,
              }),
              this.actionBtn &&
                ((t = this.actionBtn),
                void 0 === e && (e = {}),
                to.create({ trigger: t, animation: zl(t, e), once: !0 })),
              this.tag.length &&
                this.link.length &&
                (function (t, e) {
                  void 0 === e && (e = {}),
                    to.create({ trigger: t, animation: Bl(t, e), once: !0 });
                })([this.tag, this.link]);
          }
        },
      },
    ],
  });
})();
